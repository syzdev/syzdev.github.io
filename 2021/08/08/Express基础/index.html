<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content=""><meta name="author" content="syz"><meta name="description" content=""><title>Express基础 | syzdev</title><link rel="apple-touch-icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/color-scheme.css"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/comments.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script defer type="text/javascript" src="/plugins/jquery.min.js"></script><link href="/plugins/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">syzdev</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/about/"><a href="/about/">关于</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="/plugins/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">Express基础</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2021-08-08 17:21:22 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E5%89%8D%E7%AB%AF/" title="前端"><b>#</b> 前端</a></span></span></div><div class="markdown-body"><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性用来创建各种Web应用。</p><ul><li>提供了方便简洁的路由定义方式；</li><li>对获取HTTP请求参数进行了简化处理；</li><li>对模板引擎支持程度高，方便渲染动态HTML页面；</li><li>提供了中间件机制有效控制HTTP请求；</li><li>拥有大量第三方中间件对功能进行扩展。</li></ul><p>可以使用 <code>npm install express</code> 命令安装Express，安装后包含两个文件夹：</p><ul><li><code>node_modules</code>：包含所有依赖包；</li><li><code>package-lock.json</code>：所有依赖包的清单。</li></ul><p>再在根目录新建文件<code>server.js</code>，具体使用方法见第3节。</p><h1 id="2-原生nodejs与express框架路由实现对比"><a class="markdownIt-Anchor" href="#2-原生nodejs与express框架路由实现对比"></a> 2 原生Node.js与Express框架路由实现对比</h1><h2 id="21-原生nodejs路由"><a class="markdownIt-Anchor" href="#21-原生nodejs路由"></a> 2.1 原生Node.js路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取客户端的请求路径</span></span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url)</span><br><span class="line">  <span class="comment">// 对请求路径进行判断，不同的路径地址响应不同的内容</span></span><br><span class="line">  <span class="keyword">if</span> (pathname == <span class="string">&#x27;/&#x27;</span> || pathname == <span class="string">&#x27;index&#x27;</span>) &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;欢迎来到首页！&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">&#x27;/other&#x27;</span>) &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;欢迎来到其他页面！&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">&#x27;/about&#x27;</span>) &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;欢迎来到关于页面！&#x27;</span>) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;抱歉，没有找到相关页面！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="22-express路由"><a class="markdownIt-Anchor" href="#22-express路由"></a> 2.2 Express路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当客户端以get方式访问/时</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对客户端做出响应</span></span><br><span class="line">  res.send(<span class="string">&#x27;使用get方式请求了/路由&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当客户端以post方式访问/about路由时</span></span><br><span class="line">app.post(<span class="string">&#x27;/about&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;使用post方式请求了/about路由&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-express框架简单使用"><a class="markdownIt-Anchor" href="#3-express框架简单使用"></a> 3 Express框架简单使用</h1><p>启动一个Express网站服务器并开启一个“/”的路由监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.引入Express框架，并创建Express实例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.创建网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义路由</span></span><br><span class="line"><span class="comment">// 第一个参数是请求的路径，&#x27;/&#x27;代表根路径localhost:3000</span></span><br><span class="line"><span class="comment">// 第二个参数是一个函数，req是request的缩写，表示客户端提交过来的数据</span></span><br><span class="line"><span class="comment">// res是respond的缩写，表示要响应回的数据</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// send()方法，响应给客户端信息</span></span><br><span class="line">  <span class="comment">// 1. send方法内部会检测响应内容的类型</span></span><br><span class="line">  <span class="comment">// 2. send方法会自动设置http状态码</span></span><br><span class="line">  <span class="comment">// 3. send方法会帮我们自动设置响应的内容类型及编码</span></span><br><span class="line">  res.send(<span class="string">&#x27;Hello Express!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.监听端口，第二个参数回调函数启动成功后执行的内容</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;网站服务器启动成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输入<code>node server.js</code>启动服务器，但因node项目在每次编辑后都要重新启动才会生效，所以使用<code>nodemon</code>工具来自动启动服务，推荐全局安装，命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><p>安装成功后就可以使用命令<code>nodemon server.js</code>来启动服务。</p><h1 id="4-中间件"><a class="markdownIt-Anchor" href="#4-中间件"></a> 4 中间件</h1><p>中间件就是一系列方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。<br><img src="https://img-blog.csdnimg.cn/img_convert/75024b07c5a7148392d71bb36f66c5e4.png"><br>中间件主要由两部分构成，中间件方法以及请求处理函数。<br>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。<br>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  req.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(req.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用 <code>next()</code> 方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><h2 id="41-万能中间件-appuse"><a class="markdownIt-Anchor" href="#41-万能中间件-appuse"></a> 4.1 万能中间件 <code>app.use</code></h2><p><code>app.use</code> 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>app.use</code> 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/about&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="42-中间件的应用"><a class="markdownIt-Anchor" href="#42-中间件的应用"></a> 4.2 中间件的应用</h2><ol><li>路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录过程模拟</span></span><br><span class="line">app.get(<span class="string">&#x27;/admin&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用户没有登录</span></span><br><span class="line">  <span class="keyword">let</span> isLogin = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">    <span class="comment">// 如果用户登录，让请求继续向下执行</span></span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;您还没有登录，不能访问当前页面！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;您已经登录，可以访问当前页面！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;当前网站正在维护。。。&#x27;</span>)</span><br><span class="line">  <span class="comment">// 由于没有使用next()传递给下一个中间件，所以会停留在此处</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义404页面，把中间件定义在最后面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 为客户端响应404状态码以及提示信息</span></span><br><span class="line">  res.status(<span class="number">404</span>).send(<span class="string">&#x27;当前访问的页面是不存在的。&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="43-处理错误中间件"><a class="markdownIt-Anchor" href="#43-处理错误中间件"></a> 4.3 处理错误中间件</h2><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个错误实例并抛出</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;程序发生了未知错误！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 为客户端响应500状态码以及提示信息</span></span><br><span class="line">  res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>throw new Error('程序发生了未知错误！')</code> 实际上是一个同步代码，如果异步代码在执行过程中出现了错误，这样是无法捕捉到的。这个时候需要手动的触发错误处理中间件，当异步API出错时，需要调用 <code>next()</code> 方法，并把错误传入 <code>next()</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;/file-does-not-exist&#x27;</span>, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">      next(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="44-捕获错误"><a class="markdownIt-Anchor" href="#44-捕获错误"></a> 4.4 捕获错误</h2><p>在nodejs中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢？</p><p><code>try catch</code> 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。下面代码中把读取文件改造成支持异步函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> readFile(<span class="string">&#x27;/aaa.js&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    next(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="45-构建模块化路由"><a class="markdownIt-Anchor" href="#45-构建模块化路由"></a> 4.5 构建模块化路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"><span class="comment">// 将路由和请求路径进行匹配</span></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>, home)</span><br><span class="line"><span class="comment">// 在home路由下继续创建二级路由</span></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 访问路径/home/index</span></span><br><span class="line">  res.send(<span class="string">&#x27;欢迎来到主页！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/9e94cc15cc9903fee57529a3f72c1c5f.png"><h1 id="5-get参数的获取"><a class="markdownIt-Anchor" href="#5-get参数的获取"></a> 5 GET参数的获取</h1><p>Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收地址栏中问号后面的参数</span></span><br><span class="line"><span class="comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.query) </span><br><span class="line">  <span class="comment">// &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="6-post参数的获取"><a class="markdownIt-Anchor" href="#6-post参数的获取"></a> 6 POST参数的获取</h1><p>Express中接收post请求参数需要借助第三方包 body-parser。它其实是Express官方提供的，官方为了让包体积更加小巧，将一些工具剥离出来，供开发者按需安装。<br>安装命令： <code>npm install body-parser</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置body-parser模块，拦截所有请求</span></span><br><span class="line"><span class="comment">// extended: false 方法内部使用querystring模块处理请求参数的格式</span></span><br><span class="line"><span class="comment">// extended: true 方法内部使用第三方模块qs处理请求参数的格式</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;))</span><br><span class="line"><span class="comment">// 接收请求</span></span><br><span class="line">app.post(<span class="string">&#x27;/add&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接收请求参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注：可以直接使用<code>app.use(express.json());</code>代替body-parser。<br>【1】<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61551926/express-json-vs-body-parser">https://stackoverflow.com/questions/61551926/express-json-vs-body-parser</a><br>【2】<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/37434">https://cloud.tencent.com/developer/ask/37434</a></p></blockquote><h1 id="7-express路由参数"><a class="markdownIt-Anchor" href="#7-express路由参数"></a> 7 Express路由参数</h1><p>在定义时，可以显式定义请求接收的参数，在url后面用冒号加上参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localhost:3000/find/123</span></span><br><span class="line">app.get(<span class="string">&#x27;/find/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params) <span class="comment">// &#123;id: 123&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果要传递多个参数，可以继续添加斜杠和冒号。</p><h1 id="8-静态资源的处理"><a class="markdownIt-Anchor" href="#8-静态资源的处理"></a> 8 静态资源的处理</h1><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>现在，public目录下面的文件就可以访问了。</p><ul><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/images/kitten.jpg</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/js/app.js">http://localhost:3000/js/app.js</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/images/bg.png</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/hello.html</a></li></ul><p>除此之外，还可以控制路径，可以在添加一个参数<code>static</code>，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;static&#x27;</span>, express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>再访问静态资源的时候就要在url中加入<code>static</code>，如：<a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/static/hello.html</a>。</p><h1 id="9-跨域处理"><a class="markdownIt-Anchor" href="#9-跨域处理"></a> 9 跨域处理</h1><p>参考资料：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904126246027278#heading-1">https://juejin.cn/post/6844904126246027278#heading-1</a><br>现在如有接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    name: <span class="string">&#x27;syz&#x27;</span>,</span><br><span class="line">    age: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该接口的访问地址是：<a target="_blank" rel="noopener" href="http://localhost:3000/user">http://localhost:3000/user</a>。使用静态资源处理，在public文件夹中新建<code>index.html</code>。<br><img src="https://img-blog.csdnimg.cn/img_convert/051aeede036bcaad264484b59c8751d5.png"><br>此时通过<a target="_blank" rel="noopener" href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>可以访问，在<code>body</code>中添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  fetch(<span class="string">&#x27;http://localhost:3000/user&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>再次访问<a target="_blank" rel="noopener" href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>，就可以在Console中看到输出的对象：<code>&#123;name: &quot;syz&quot;, age: &quot;18&quot;&#125;</code>。<br>这是数据是可以正常访问到的，此时右键<code>index.html</code>，利用vscode插件Live server打卡，该插件会启动一个以5500为端口的服务：<br><img src="https://img-blog.csdnimg.cn/img_convert/65641336c65f576e5cc3aabe886f2520.png"><br>访问地址为：<a target="_blank" rel="noopener" href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>，此时可以发现Console无法请求到数据了，并报了跨域错误。<br><img src="https://img-blog.csdnimg.cn/img_convert/4c2b76613205517ac580af56ff9a6510.png"><br>处理跨域问题需要用到第三方库：<code>npm i cors</code>，在<code>server.js</code>中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入cors，返回的是一个函数，直接()执行，执行后是一个Express中间件，app.use使用它即可</span></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)())</span><br></pre></td></tr></table></figure><p>再访问<a target="_blank" rel="noopener" href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>即可获取到数据。</p></div><div class="prev-or-next"><div class="post-foot-next"><a href="/2020/05/01/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" target="_self"><i class="iconfont icon-chevronleft"></i> <span>上一页</span></a></div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2021-08-08 17:21:22 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E5%89%8D%E7%AB%AF/" title="前端"><b>#</b> 前端</a></span></span></div><div class="post-foot-prev"><a href="/2021/08/10/%E6%B3%A8%E5%86%8CCesium%20ion%E6%95%99%E7%A8%8B/" target="_self"><span>下一页</span> <i class="iconfont icon-chevronright"></i></a></div></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8E%9F%E7%94%9Fnodejs%E4%B8%8Eexpress%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94"><span class="toc-text">2 原生Node.js与Express框架路由实现对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%8E%9F%E7%94%9Fnodejs%E8%B7%AF%E7%94%B1"><span class="toc-text">2.1 原生Node.js路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-express%E8%B7%AF%E7%94%B1"><span class="toc-text">2.2 Express路由</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-express%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">3 Express框架简单使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">4 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%B8%87%E8%83%BD%E4%B8%AD%E9%97%B4%E4%BB%B6-appuse"><span class="toc-text">4.1 万能中间件 app.use</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.2 中间件的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">4.3 处理错误中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF"><span class="toc-text">4.4 捕获错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1"><span class="toc-text">4.5 构建模块化路由</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-get%E5%8F%82%E6%95%B0%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">5 GET参数的获取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-post%E5%8F%82%E6%95%B0%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">6 POST参数的获取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-express%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0"><span class="toc-text">7 Express路由参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">8 静态资源的处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86"><span class="toc-text">9 跨域处理</span></a></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/syzdev"><i class="iconfont icon-github"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get();a.innerHTML="",r.addEventListener("input",(function(){var e='<ul class="search-result-list">',n=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach((function(t){var r=!0;t.title&&""!==t.title.trim()||(t.title="Untitled");var a=t.title.trim(),c=a.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),l=t.url,o=-1,u=-1,h=-1;if(""!==i?n.forEach((function(e,t){o=c.indexOf(e),u=i.indexOf(e),o<0&&u<0?r=!1:(u<0&&(u=0),0==t&&(h=u))})):r=!1,r){e+="<li><a href='"+l+"' class='search-result-title'>"+a+"</a>";var d=s;if(h>=0){var p=h-20,f=h+80;p<0&&(p=0),0==p&&(f=100),f>d.length&&(f=d.length);var m=d.substr(p,f);n.forEach((function(e){var t=new RegExp(e,"gi");m=m.replace(t,'<span class="search-keyword">'+e+"</span>")})),e+='<p class="search-result-abstract">'+m+"...</p>"}e+="</li>"}})),-1===(e+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=e}}))},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",(function(){$("#search-input").val(""),$("#search-result").html("")}))},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script></div></div></body></html>