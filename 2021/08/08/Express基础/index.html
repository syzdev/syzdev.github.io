<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>Express基础 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Express基础"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-08 17:21" pubdate>2021年8月8日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 35 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Express基础</h1><div class="markdown-body"><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性用来创建各种Web应用。</p><ul><li>提供了方便简洁的路由定义方式；</li><li>对获取HTTP请求参数进行了简化处理；</li><li>对模板引擎支持程度高，方便渲染动态HTML页面；</li><li>提供了中间件机制有效控制HTTP请求；</li><li>拥有大量第三方中间件对功能进行扩展。</li></ul><p>可以使用 <code>npm install express</code> 命令安装Express，安装后包含两个文件夹：</p><ul><li><code>node_modules</code>：包含所有依赖包；</li><li><code>package-lock.json</code>：所有依赖包的清单。</li></ul><p>再在根目录新建文件<code>server.js</code>，具体使用方法见第3节。</p><h1 id="2-原生nodejs与express框架路由实现对比"><a class="markdownIt-Anchor" href="#2-原生nodejs与express框架路由实现对比"></a> 2 原生Node.js与Express框架路由实现对比</h1><h2 id="21-原生nodejs路由"><a class="markdownIt-Anchor" href="#21-原生nodejs路由"></a> 2.1 原生Node.js路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取客户端的请求路径</span><br>  <span class="hljs-keyword">let</span> &#123;pathname&#125; = url.parse(req.url)<br>  <span class="hljs-comment">// 对请求路径进行判断，不同的路径地址响应不同的内容</span><br>  <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/&#x27;</span> || pathname == <span class="hljs-string">&#x27;index&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到首页！&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/other&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到其他页面！&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/about&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到关于页面！&#x27;</span>) <br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.end(<span class="hljs-string">&#x27;抱歉，没有找到相关页面！&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="22-express路由"><a class="markdownIt-Anchor" href="#22-express路由"></a> 2.2 Express路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 当客户端以get方式访问/时</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 对客户端做出响应</span><br>  res.send(<span class="hljs-string">&#x27;使用get方式请求了/路由&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 当客户端以post方式访问/about路由时</span><br>app.post(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;使用post方式请求了/about路由&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="3-express框架简单使用"><a class="markdownIt-Anchor" href="#3-express框架简单使用"></a> 3 Express框架简单使用</h1><p>启动一个Express网站服务器并开启一个“/”的路由监听：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.引入Express框架，并创建Express实例</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2.创建网站服务器对象</span><br><span class="hljs-keyword">const</span> app = express()<br><br><span class="hljs-comment">// 3.定义路由</span><br><span class="hljs-comment">// 第一个参数是请求的路径，&#x27;/&#x27;代表根路径localhost:3000</span><br><span class="hljs-comment">// 第二个参数是一个函数，req是request的缩写，表示客户端提交过来的数据</span><br><span class="hljs-comment">// res是respond的缩写，表示要响应回的数据</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// send()方法，响应给客户端信息</span><br>  <span class="hljs-comment">// 1. send方法内部会检测响应内容的类型</span><br>  <span class="hljs-comment">// 2. send方法会自动设置http状态码</span><br>  <span class="hljs-comment">// 3. send方法会帮我们自动设置响应的内容类型及编码</span><br>  res.send(<span class="hljs-string">&#x27;Hello Express!&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 4.监听端口，第二个参数回调函数启动成功后执行的内容</span><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;网站服务器启动成功！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>输入<code>node server.js</code>启动服务器，但因node项目在每次编辑后都要重新启动才会生效，所以使用<code>nodemon</code>工具来自动启动服务，推荐全局安装，命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">npm install -g nodemon<br></code></pre></div></td></tr></table></figure><p>安装成功后就可以使用命令<code>nodemon server.js</code>来启动服务。</p><h1 id="4-中间件"><a class="markdownIt-Anchor" href="#4-中间件"></a> 4 中间件</h1><p>中间件就是一系列方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1602549/1611556383029-e0421db1-1b3f-48a7-ac86-d1ac8c967ca7.png" srcset="/img/loading.gif" lazyload><br>中间件主要由两部分构成，中间件方法以及请求处理函数。<br>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。<br>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  req.name = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  next()<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(req.name)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用 <code>next()</code> 方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><h2 id="41-万能中间件-appuse"><a class="markdownIt-Anchor" href="#41-万能中间件-appuse"></a> 4.1 万能中间件 <code>app.use</code></h2><p><code>app.use</code> 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.url)<br>  next()<br>&#125;)<br></code></pre></div></td></tr></table></figure><p><code>app.use</code> 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.url)<br>  next()<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="42-中间件的应用"><a class="markdownIt-Anchor" href="#42-中间件的应用"></a> 4.2 中间件的应用</h2><ol><li>路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 登录过程模拟</span><br>app.get(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 用户没有登录</span><br>  <span class="hljs-keyword">let</span> isLogin = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (isLogin) &#123;<br>    <span class="hljs-comment">// 如果用户登录，让请求继续向下执行</span><br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;您还没有登录，不能访问当前页面！&#x27;</span>)<br>  &#125;<br>&#125;)<br><br>app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;您已经登录，可以访问当前页面！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><ol start="2"><li>网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;当前网站正在维护。。。&#x27;</span>)<br>  <span class="hljs-comment">// 由于没有使用next()传递给下一个中间件，所以会停留在此处</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><ol start="3"><li>自定义404页面，把中间件定义在最后面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 为客户端响应404状态码以及提示信息</span><br>  res.status(<span class="hljs-number">404</span>).send(<span class="hljs-string">&#x27;当前访问的页面是不存在的。&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="43-处理错误中间件"><a class="markdownIt-Anchor" href="#43-处理错误中间件"></a> 4.3 处理错误中间件</h2><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 创建一个错误实例并抛出</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;程序发生了未知错误！&#x27;</span>)<br>&#125;)<br><br>app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 为客户端响应500状态码以及提示信息</span><br>  res.status(<span class="hljs-number">500</span>).send(err.message)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p><code>throw new Error('程序发生了未知错误！')</code> 实际上是一个同步代码，如果异步代码在执行过程中出现了错误，这样是无法捕捉到的。这个时候需要手动的触发错误处理中间件，当异步API出错时，需要调用 <code>next()</code> 方法，并把错误传入 <code>next()</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  fs.readFile(<span class="hljs-string">&#x27;/file-does-not-exist&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) &#123;<br>      next(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.send(result)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="44-捕获错误"><a class="markdownIt-Anchor" href="#44-捕获错误"></a> 4.4 捕获错误</h2><p>在nodejs中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢？</p><p><code>try catch</code> 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。下面代码中把读取文件改造成支持异步函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>).promisify<br><span class="hljs-keyword">const</span> readFile = promisify(fs.readFile)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/aaa.js&#x27;</span>)<br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    next(err)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="45-构建模块化路由"><a class="markdownIt-Anchor" href="#45-构建模块化路由"></a> 4.5 构建模块化路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建路由对象</span><br><span class="hljs-keyword">const</span> home = express.Router()<br><span class="hljs-comment">// 将路由和请求路径进行匹配</span><br>app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)<br><span class="hljs-comment">// 在home路由下继续创建二级路由</span><br>home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 访问路径/home/index</span><br>  res.send(<span class="hljs-string">&#x27;欢迎来到主页！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2021/png/1602549/1611580982180-4318d766-5a38-4e41-bf8d-f0c3a3589936.png" srcset="/img/loading.gif" lazyload><h1 id="5-get参数的获取"><a class="markdownIt-Anchor" href="#5-get参数的获取"></a> 5 GET参数的获取</h1><p>Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 接收地址栏中问号后面的参数</span><br><span class="hljs-comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.query) <br>  <span class="hljs-comment">// &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;&#125;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="6-post参数的获取"><a class="markdownIt-Anchor" href="#6-post参数的获取"></a> 6 POST参数的获取</h1><p>Express中接收post请求参数需要借助第三方包 body-parser。它其实是Express官方提供的，官方为了让包体积更加小巧，将一些工具剥离出来，供开发者按需安装。<br>安装命令： <code>npm install body-parser</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入body-parser模块</span><br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br><span class="hljs-comment">// 配置body-parser模块，拦截所有请求</span><br><span class="hljs-comment">// extended: false 方法内部使用querystring模块处理请求参数的格式</span><br><span class="hljs-comment">// extended: true 方法内部使用第三方模块qs处理请求参数的格式</span><br>app.use(bodyParser.urlencoded(&#123;<span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span>&#125;))<br><span class="hljs-comment">// 接收请求</span><br>app.post(<span class="hljs-string">&#x27;/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接收请求参数</span><br>  <span class="hljs-built_in">console</span>.log(req.body)<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>注：可以直接使用<code>app.use(express.json());</code>代替body-parser。<br>【1】<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61551926/express-json-vs-body-parser">https://stackoverflow.com/questions/61551926/express-json-vs-body-parser</a><br>【2】<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/37434">https://cloud.tencent.com/developer/ask/37434</a></p></blockquote><h1 id="7-express路由参数"><a class="markdownIt-Anchor" href="#7-express路由参数"></a> 7 Express路由参数</h1><p>在定义时，可以显式定义请求接收的参数，在url后面用冒号加上参数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// localhost:3000/find/123</span><br>app.get(<span class="hljs-string">&#x27;/find/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.params) <span class="hljs-comment">// &#123;id: 123&#125;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>如果要传递多个参数，可以继续添加斜杠和冒号。</p><h1 id="8-静态资源的处理"><a class="markdownIt-Anchor" href="#8-静态资源的处理"></a> 8 静态资源的处理</h1><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br>app.use(express.static(path.join(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)))<br></code></pre></div></td></tr></table></figure><p>现在，public目录下面的文件就可以访问了。</p><ul><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/images/kitten.jpg</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/js/app.js">http://localhost:3000/js/app.js</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/images/bg.png</a></li><li><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/hello.html</a></li></ul><p>除此之外，还可以控制路径，可以在添加一个参数<code>static</code>，</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-string">&#x27;static&#x27;</span>, express.static(path.join(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)))<br></code></pre></div></td></tr></table></figure><p>再访问静态资源的时候就要在url中加入<code>static</code>，如：<a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/static/hello.html</a>。</p><h1 id="9-跨域处理"><a class="markdownIt-Anchor" href="#9-跨域处理"></a> 9 跨域处理</h1><p>参考资料：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904126246027278#heading-1">https://juejin.cn/post/6844904126246027278#heading-1</a><br>现在如有接口：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(&#123;<br>    name: <span class="hljs-string">&#x27;syz&#x27;</span>,<br>    age: <span class="hljs-string">&#x27;18&#x27;</span>,<br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>该接口的访问地址是：<a target="_blank" rel="noopener" href="http://localhost:3000/user">http://localhost:3000/user</a>。使用静态资源处理，在public文件夹中新建<code>index.html</code>。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1602549/1614411146963-1144a4b8-46db-4d6f-9338-bf2611b5631f.png" srcset="/img/loading.gif" lazyload><br>此时通过<a target="_blank" rel="noopener" href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>可以访问，在<code>body</code>中添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;<br>  fetch(<span class="hljs-string">&#x27;http://localhost:3000/user&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>再次访问<a target="_blank" rel="noopener" href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>，就可以在Console中看到输出的对象：<code>&#123;name: &quot;syz&quot;, age: &quot;18&quot;&#125;</code>。<br>这是数据是可以正常访问到的，此时右键<code>index.html</code>，利用vscode插件Live server打卡，该插件会启动一个以5500为端口的服务：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1602549/1614411082845-8bcd5311-8795-4553-94c1-cf21543a0429.png" srcset="/img/loading.gif" lazyload><br>访问地址为：<a target="_blank" rel="noopener" href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>，此时可以发现Console无法请求到数据了，并报了跨域错误。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1602549/1614411173204-1edb2b1f-6740-4753-a7ea-3516ed997c1f.png" srcset="/img/loading.gif" lazyload><br>处理跨域问题需要用到第三方库：<code>npm i cors</code>，在<code>server.js</code>中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入cors，返回的是一个函数，直接()执行，执行后是一个Express中间件，app.use使用它即可</span><br>app.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)())<br></code></pre></div></td></tr></table></figure><p>再访问<a target="_blank" rel="noopener" href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>即可获取到数据。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2020/05/01/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"><span class="hidden-mobile">HTTPS是如何工作的</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>