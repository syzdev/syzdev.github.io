<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>操作系统原理第六章：进程同步 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="操作系统原理第六章：进程同步"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-16 19:41" pubdate>2020年3月16日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 64 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统原理第六章：进程同步</h1><div class="markdown-body"><h1 id="1-进程同步背景"><a class="markdownIt-Anchor" href="#1-进程同步背景"></a> 1 进程同步背景</h1><p>对于之前所提到的生产者消费者问题，采用共享内存解决生产者消费者问题时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 个缓冲区最多只能用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个，那么为什么有一个是用不了的呢？这是因为在判断缓冲区空或满时，用取余计算实现的，之所以牺牲一个位置是为了让缓冲区空和缓冲区满两种状态有两种不同的表达式，若是换一种方法，设置一个计数变量 <code>count</code> ，<code>count</code> 的值表示当前缓冲区已经使用的容量，<code>count = 0</code> 表示缓冲区空，<code>count = BUFFER_SIZE</code>表示缓冲区满（<code>BUFFER_SIZE</code>为缓冲区大小），这样就解决了牺牲一个缓冲区容量的问题，如下图：<br><img src="https://img-blog.csdnimg.cn/20200316142855825.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>下面是实现生产者添加商品的伪代码，若不能理解该过程可以查阅数据结构中<strong>循环队列</strong>的内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 生产者调用的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enter</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>    <span class="hljs-comment">// 缓冲区已经满无法继续添加</span><br>    <span class="hljs-keyword">while</span> (count == BUFFER_SIZE); <br>    <span class="hljs-comment">// 添加一个商品到缓冲区</span><br>    buffer[in] = item;<br>    in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    count++; <span class="hljs-comment">// 计数加一</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是实现消费者消费商品的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 消费者调动的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    Object item;<br>    <span class="hljs-comment">// 当前缓冲区没有商品，无法消费</span><br>    <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>); <br>    <span class="hljs-comment">// 从缓冲区移除一个商品</span><br>    item = buffer[out];<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    count--; <span class="hljs-comment">// 商品总数减一</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述思想看起来是没有问题的，但是在实现过程中会出现问题，问题就出在 <code>count</code> 的<strong>自增</strong>和<strong>自减</strong>操作，由于<code>count++</code> 和 <code>count--</code>属于高级指令，所以在机器执行过程中是分为三个步骤的，中间还有一步转交给寄存器的操作，如下图：<br><img src="https://img-blog.csdnimg.cn/20200316144246835.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>所以当一条高级指令分解成三个指令时，多个程序并发时就会出现问题，现假设 <code>count = 5</code>，若生产一个商品，再消费一个商品，最后 <code>count</code> 的值还是等于 <code>5</code>，可在并发执行时就不一定会这样，见下面的例子（注：以下例子只是情况的一种，在并发执行时会有非常多的不确定性），最终 <code>count</code> 的值等于 <code>4</code>：<br><img src="https://img-blog.csdnimg.cn/20200316144549242.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>由以上的例子可知，对共享数据的并发访问可能导致数据的不一致性，要保持数据的一致性，就需要一种保证并发进程的正确执行顺序的机制，解决有界缓冲区问题的共享内存方法是在数据 <code>count</code> 上存在<strong>竞争条件</strong>。</p><blockquote><p><strong>竞争条件</strong>：若干个并发的进程（线程）都可以访问和操纵同一个共享数据，从而执行结果就取决于并发进程对这个数据的访问次序，为了保证数据的一致性，需要有同步机制来保证多个进程对共享数据的<strong>互斥访问</strong>。</p></blockquote><p>进程的类型分为两种，一种是<strong>独立进程</strong>，它独立执行，不受其他进程的影响；另一种就是<strong>协作进程</strong>，如刚刚所讲的生产者和消费者问题，这两个进程就属于协作进程。进程间资源访问冲突也分为两种，一种是共享变量的修改冲突，如上面的 <code>count</code> 值，另一种则是操作顺序冲突，比如某个作业 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span>，需要作业 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 提供数据进行计算，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 提供不了数据，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 会受到影响。</p><p>进程间的制约关系分为如下两种：</p><ul><li><strong>间接制约</strong>：有些资源需要互斥使用，因此各进程进行竞争，独占分配到的部分或全部共享资源，进程的这种关系为<strong>进程的互斥</strong>；</li><li><strong>直接制约</strong>：进行协作，具体来说，一个进程运行到某一点时要求另一伙伴进程为它提供消息，在未获得消息之前，该进程处于等待状态，获得消息后被唤醒进入就绪态，进程的这种关系为<strong>进程的同步</strong>。</li></ul><p>由于多个进程相互竞争资源，若各个进程互不相让，此时就会发生<strong>死锁</strong>想象。</p><h1 id="2-临界区"><a class="markdownIt-Anchor" href="#2-临界区"></a> 2 临界区</h1><p>临界资源即共享资源，对于临界资源，多个进程必须互斥的对它进行访问，在进程中某些代码会访问到临界资源，这段代码就叫做<strong>临界区 (critical section)</strong>，即进程中访问临界资源的<strong>一段代码</strong>，实现进程对临界资源的互斥访问就是让各进程互斥的进入自己的临界区，也就是说当某个进程在临界区中执行时，其他进程都不能访问自己临界区，这样就保证了某个时间内只有一个进程在临界区内使用临界资源，这样就实现了临界资源的互斥访问。</p><p>临界区的执行在时间上是互斥的，进程必须请求允许进入临界区，也就是说当某个进程想进入临界区时，比如进行某种操作来判断当前临界区是否有进程在执行，在具体实现时也是利用代码来判断的，整个进程的访问过程分为以下三个区：</p><ul><li><strong>进入区 (entry section)</strong>：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应“正在访问临界区”标志；</li><li><strong>退出区 (exit section)</strong>：用于将&quot;正在访问临界区&quot;标志清除；</li><li><strong>剩余区 (remainder section)</strong>：代码中的其余部分。</li></ul><p>临界区互斥问题的解决方案要满足如下三个要求：</p><ul><li><strong>互斥</strong>：假定进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 在其临界区内执行，其他任何进程将被排斥在自己的临界区之外；</li><li><strong>有空让进</strong>：临界区虽没有进程执行，但有些进程需要进入临界区，不能无限期地延长下一个要进入临界区进程的等待时间；</li><li><strong>有限等待</strong>：在一个进程提出进入临界区的请求和该请求得到答复的时间内，其他进程进入临界区的次数必须是有限的。</li></ul><h2 id="21-进程的互斥"><a class="markdownIt-Anchor" href="#21-进程的互斥"></a> 2.1 进程的互斥</h2><p>如何实现进程间的互斥？这里举一个现实中游乐园的滑滑梯例子，滑滑梯一次只能进一个小朋友，当有很多小朋友想要玩的时候，那么一个解决办法是让他们<strong>轮流</strong>来玩，另一个解决办法是提出想玩滑滑梯<strong>申请</strong>。在解决进程间的互斥问题时，也是借助了这两个思想，这里介绍几种算法。</p><hr><p><strong>算法1</strong>：设立一个两进程公用的整型变量 <code>turn</code> ，用来描述允许进入临界区的进程标识有两个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> ， 如果 <code>turn = i</code>，那么进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 允许在其临界区执行，即采用轮流的方式，用 <code>turn</code> 表示当前运行哪个进程进入临界区。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (turn != i); <span class="hljs-comment">// 判断是否轮到 Pi </span><br>    critical section; <span class="hljs-comment">// 执行临界区</span><br>turn = j; <span class="hljs-comment">// 执行完临界区就轮到下一个 Pj</span><br>    remainder section; <span class="hljs-comment">// 执行剩余区</span><br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (turn != j); <span class="hljs-comment">// 判断是否轮到 Pj</span><br>    critical section; <span class="hljs-comment">// 执行临界区</span><br>turn = i; <span class="hljs-comment">// 执行完临界区就轮到下一个 Pi</span><br>    remainder section; <span class="hljs-comment">// 执行剩余区</span><br></code></pre></div></td></tr></table></figure><p>对于之前提到的临界区互斥问题的三个要求，该算法显然是满足第一个互斥要求的，实际上该算法是强制轮流进入临界区，没有考虑进程的实际需要，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 执行完临界区，<code>turn</code> 也转交给了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span>，但此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 不需要使用临界区，这时临界区处于空闲状态，但 <code>turn</code> 这时不属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 依然无法执行临界区，容易造成资源利用不充分，所以不满足第二个要求有空让进，也不满足第三个要求有限等待。</p><hr><p><strong>算法2</strong>：由于算法1 只保存了哪个进程能进入临界区，没有保存进程的状态，所以算法2 设立一个标志数组 <code>flag[]</code>，用来描述进程是否准备进入临界区，初值均为 <code>FALSE</code>，先<strong>申请</strong>后检查 ，可防止两个进程同时进入临界区。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[i] = TURE; <span class="hljs-comment">// Pi 申请执行临界区</span><br><span class="hljs-keyword">while</span> (flag[j]); <span class="hljs-comment">// 判断 Pj 是不是在执行临界区或它也想执行临界区</span><br>    critical section;<br>flag[i] = FALSE; <span class="hljs-comment">// Pi 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[j] = TURE; <span class="hljs-comment">// Pj 申请执行临界区</span><br><span class="hljs-keyword">while</span> (flag[i]); <span class="hljs-comment">// 判断 Pi 是不是在执行临界区或它也想执行临界区</span><br>    critical section;<br>flag[j] = FALSE; <span class="hljs-comment">// Pj 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p>该算法显然满足互斥要求，因为每次执行临界区前都会判断对方是否在执行临界区或是否也想进入临界区，设想某个时刻 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 都申请执行临界区，这样会导致双方谁也不能执行临界区，所以不满足有空让进的要求，算法2 对比算法1 的优点是不用交替进入，可连续使用，不用等待对方，缺点就是两进程可能都进入不了临界区。</p><hr><p><strong>算法3</strong>：在算法2 的基础上进一步改进，同样是要先申请执行临界区，但要把 <code>turn</code> 改为对方，然后再进行检查若当前对方在执行临界区或对方想要执行临界区且 <code>turn</code> 也是对方，那么就要等待对方执行完。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[i] = TURE; <span class="hljs-comment">// Pi 申请执行临界区</span><br>turn = j; <span class="hljs-comment">// 让 Pj 下次执行</span><br><span class="hljs-keyword">while</span> (flag[j] &amp;&amp; turn == j); <span class="hljs-comment">// 判断 Pj 是不是在执行临界区或它也想执行临界区且当且turn为它</span><br>    critical section;<br>flag[i] = FALSE; <span class="hljs-comment">// Pi 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[j] = TURE; <span class="hljs-comment">// Pj 申请执行临界区</span><br>turn = i; <span class="hljs-comment">// 让 Pi 下次执行</span><br><span class="hljs-keyword">while</span> (flag[i] &amp;&amp; turn == i); <span class="hljs-comment">// 判断 Pi 是不是在执行临界区或它也想执行临界区且当且turn为它</span><br>    critical section;<br>flag[j] = FALSE; <span class="hljs-comment">// Pj 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p>算法3 解决了算法1 和算法2 的缺点，同时算法3 具有先到先入，后到等待的特点。</p><h1 id="3-信号量"><a class="markdownIt-Anchor" href="#3-信号量"></a> 3 信号量</h1><p>可以用临界区解决互斥问题，它们是平等进程间的一种协商机制，之前所提到的轮流和申请都是基于两个进程的临界区模型所提出来的，当进程数目过多的时候，显然要引入新的机制来解决互斥问题，操作系统可从进程管理者的角度来处理互斥的问题，<strong>信号量 (Semaphore)</strong> 就是操作系统提供的管理公有资源的有效手段。</p><p>信号量是在1965年，由荷兰学者 Dijkstra 提出（所以 P、V 分别是荷兰语的 test (proberen)、increment (verhogen)），信号量是一种卓有成效的进程同步机制，用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。</p><p>信号量是一个整型变量，<strong>信号量代表可用资源实体的数量</strong>。除了初始化之外，仅能通过两个不可分割的<strong>原子操作</strong>访问，即 <code>P(S)</code> 和 <code>V(S)</code>，简称为 P，V 操作。</p><blockquote><p><strong>原子操作</strong>：指的是操作系统内最小的操作单位，它执行时不可中断的。</p></blockquote><p>由于 <code>S</code> 代表当前可用资源的数量，当 <code>S &lt;= 0</code>时，会一直等待资源，所以存在<strong>忙等现象</strong>，又称自旋锁，此时 CPU 的利用率是不高的，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(S); <span class="hljs-comment">// 申请资源</span><br>    <span class="hljs-keyword">while</span> (S &lt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// 当前没有可用资源就要一直等待</span><br>S--; <span class="hljs-comment">// 若有资源，就要总资源数减一</span><br>V(S); <span class="hljs-comment">// 使用完资源要释放资源</span><br>S++; <span class="hljs-comment">// 释放资源</span><br></code></pre></div></td></tr></table></figure><p>为了解决忙等现象，引入了一种不需要忙等的方案，它将 <code>S--</code> 操作提前了，先减再判断 <code>S</code> 的值，若判断的 <code>S &lt; 0</code>，就让进程进入阻塞状态（通常是设置一个阻塞进程队列），在释放资源时，若 <code>S &gt;= 0</code>，则要唤醒阻塞的进程，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(S); <span class="hljs-comment">// 申请资源</span><br>    S--; <span class="hljs-comment">// 总资源数减一</span><br>    <span class="hljs-keyword">if</span> (S &lt; <span class="hljs-number">0</span>) &#123;<br>        block; <span class="hljs-comment">// 若当前无可用资源，则将该进程阻塞</span><br>    &#125;<br>V(S); <span class="hljs-comment">// 使用完资源要释放资源</span><br>    S++; <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (S &gt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup; <span class="hljs-comment">// 若当前有可用资源，则将之前阻塞的进程唤醒</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>S是与临界区内所使用的公用资源有关的信号量：</p><ul><li><code>P(S)</code>：表示申请一个资源；</li><li><code>V(S)</code>：表示释放一个资源。</li></ul><p>一般来说初始化指定一个非负整数值，表示空闲资源总数，在信号量经典定义下，信号量 <code>S</code> 的值不能为负，后面的定义下可能为负，因为后面的定义是先做 <code>S--</code>：</p><ul><li><code>S &gt;= 0</code> ：<code>S</code> 表示可供并发进程使用的资源数；</li><li><code>S &lt; 0</code> ：<code>S</code> 绝对值就是正在等待进入临界区的进程数。</li></ul><p>在用信号量解决问题的时候，首先要分清楚这个问题是个同步问题，还是一个互斥问题，若是一个互斥问题，那么就要找到互斥的临界资源是什么，并把临界资源抽象成信号量，然后给信号量赋初值并给出正确的 P，V 操作。</p><h1 id="4-哲学家进餐问题"><a class="markdownIt-Anchor" href="#4-哲学家进餐问题"></a> 4 哲学家进餐问题</h1><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着<strong>5支筷子</strong>（注意是5支而不是5双），每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐，问题模型如下图：<br><img src="https://img-blog.csdnimg.cn/20200316172542134.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>先考虑该问题是一个同步问题还是一个互斥问题，显然它是一个互斥问题，因为他们要共同竞争筷子使用权，那么临界资源就是筷子，把临界资源抽象成信号量为 <code>Semaphore chopStick[] = new Semaphore[5];</code>，即一个容量为 5 的数组。</p><p>哲学家思考和进餐的过程如下面的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Repeat<br>    思考;<br>    取chopStick[i]; <span class="hljs-comment">// 一根筷子</span><br>    取chopStick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]； <span class="hljs-comment">// 取旁边一根筷子</span><br>    进餐;<br>    放chopStick[i]; <span class="hljs-comment">// 放回筷子</span><br>    放chopStick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]； <span class="hljs-comment">// 放回筷子</span><br>Until <span class="hljs-literal">false</span>;<br></code></pre></div></td></tr></table></figure><p>用信号量表示的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 取左边的筷子</span><br>    chopStick[i].P();<br>    <span class="hljs-comment">// 取右边的筷子</span><br>    chopStick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].P();<br>    <span class="hljs-comment">// 进餐</span><br>    <span class="hljs-comment">// 放回左边的筷子</span><br>    chopStick[i].V();<br>    <span class="hljs-comment">// 放回右边的筷子</span><br>    chopStick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].V();<br>    <span class="hljs-comment">// 思考</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>用信号量实现保证了互斥，但是这种实现下可能会出现死锁，当五个哲学家每人拿起了他左边的筷子，则桌子上筷子全部被拿完了，而没有一个哲学家凑齐了两支筷子，造成了都无法进餐的窘境，解决这个死锁的方法有如下几种：</p><ul><li>最多允许四个哲学家同时就坐，此时至少有一个哲学家能够同时拿起两支筷子；</li><li>同时拿起两支筷子，若某个哲学家要进餐时，要求他同时拿起一双，若不能同时拿起两支，就不能进餐；</li><li>非对称解决，处于奇数位置的哲学家限制他只能拿左边的筷子， 处于偶数位置的哲学家限制他只能拿右边的筷子，这样无论如何都会有一个哲学家能同时拿起两支筷子。</li></ul><h1 id="5-生产者消费者问题"><a class="markdownIt-Anchor" href="#5-生产者消费者问题"></a> 5 生产者消费者问题</h1><p>问题描述：若干进程通过有限的共享缓冲区交换数据。其中，&quot;生产者&quot;进程不断写入，而&quot;消费者&quot;进程不断读出；共享缓冲区共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 个，任何时刻只能有一个进程可对共享缓冲区进行操作，问题模型如下图：<br><img src="https://img-blog.csdnimg.cn/20200316173814260.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>由于进程之间是共享了临界资源，所以他们之间肯定是互斥关系，所以要设置临界区保证进程间互斥访问，由于生产者生产商品给消费者使用，他们之间也存在着同步关系。</p><p>缓冲区的大小是固定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span>，当缓冲区满的时候，生产者是不能再生产商品的，当缓冲区为空的时候消费者是不能消费商品的，我们可以抽象以下变量：</p><ul><li><code>full</code>：表示缓冲区满的数量，也就是可用商品的个数，它的初值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> ；</li><li><code>empty</code>：表示缓冲区空的数量，也就是还可以生产多少商品的个数，它的初值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> ；</li><li><code>mutex</code>：表示访问缓冲区的互斥，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 。</li></ul><p>每生产一个商品就要进行 <code>full++</code> 操作，每消费一个商品就要进行 <code>empty++</code> 操作，<code>full</code> 和 <code>empty</code> 满足关系式 <code>full + empty = N</code>。对于生产者来说它一开始要生产商品放到缓冲区里面，而缓冲区是互斥的，生产的时候还要看缓冲区里面是否还有空位，有空位才能够生产，所以对应的有两对 P，V 操作，一对是关于互斥信号量 <code>mutex</code> 的操作，一对是关于资源信号量 <code>empty</code> 的操作。在实现的时候要注意每个进程中各个 P 操作的次序是非常重要的，应先检查资源数目，再检查是否互斥，否则可能出现死锁。</p><p>对于生产者操作的伪代码如下；</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(empty); <span class="hljs-comment">// 申请空位 empty--</span><br>P(mutex); <span class="hljs-comment">// 申请占用缓冲区</span><br><span class="hljs-comment">// 生产一个商品放入缓冲区</span><br>V(mutex); <span class="hljs-comment">// 释放占用的缓冲区</span><br>V(full); <span class="hljs-comment">// 添加商品 full++</span><br></code></pre></div></td></tr></table></figure><p>对于消费者操作的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(full); <span class="hljs-comment">// 申请消费一个商品 full--</span><br>P(mutex); <span class="hljs-comment">// 申请占用缓冲区</span><br><span class="hljs-comment">// 消费缓冲区中的一个商品</span><br>V(mutex); <span class="hljs-comment">// 释放占用的缓冲区</span><br>V(empty); <span class="hljs-comment">// 增加一个空位 empty++</span><br></code></pre></div></td></tr></table></figure><p>用信号量表示生产者的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enter</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>    empty.P(); <span class="hljs-comment">// 申请缓冲区中的一个空位</span><br>    mutex.P(); <span class="hljs-comment">// 申请占用缓冲区</span><br>    <span class="hljs-comment">// 添加一个商品到缓冲区</span><br>    buffer[in] = item;<br>    in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    mutex.V(); <span class="hljs-comment">// 释放占用缓冲区</span><br>    full.V(); <span class="hljs-comment">// 增加一个商品</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>用信号量表示消费者的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    full.P(); <span class="hljs-comment">// 申请消费一个商品</span><br>    mutex.P(); <span class="hljs-comment">// 申请占用缓冲区</span><br>    <span class="hljs-comment">// 从缓冲区消费一个商品</span><br>    Object item = buffer[out];<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    mutex.V(); <span class="hljs-comment">// 释放占用的缓冲区</span><br>    empty.V(); <span class="hljs-comment">// 增加一个空位</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-读写问题"><a class="markdownIt-Anchor" href="#6-读写问题"></a> 6 读写问题</h1><p>问题描述：对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个。</p><p>读写问题存在以下三种关系：</p><ul><li><strong>读者和写者</strong>：互斥关系，写者在写的时候读者不可以读，读者在读的时候写者不可以写；</li><li><strong>写者和写者</strong>：互斥关系，同一时刻只能有一个写者进行写操作；</li><li><strong>读者和读者</strong>：没有限制，多个读者可以同时读。</li></ul><p>那么可以从两个方面来考虑这个问题，即有读者来会怎么样和有写者来会怎么样。</p><p>当有读者来的时候：</p><ul><li>如果当前系统中没有读者也没有写者，那么新来的读者可以直接读，一旦这个读者开始读的时候，后面来的读者都可以读，但是后来的写者是不可以写的；</li><li>当一个读者到来的时候，发现有一个写者正在等待，因为之前已经到来了读者并且现在在读，那么这个时候来的读者便可以直接读；</li><li>当一个读者到来的时候，发现有一个写者正在写，那么该读者就不能读，并且后面来的读者都要等待，除非这个写者写完。</li></ul><p>当写者到来时：</p><ul><li>若当前没有读者，写者可以直接写；</li><li>若当前有读者，写者便要等待读者读完；</li><li>若当前正有写者在写，那么该写者要等待。</li></ul><p>总结来说就是写者是跟任何人互斥的，读者与读者是允许的，并且可以发现<strong>只有第一个和最后一个读者是会影响写者的</strong>，那么如何知道哪个读者是第一个来的，哪个读者是最后一个走的呢？我们的解决方法是设置一个变量来统计读者的个数，初值可以设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>，来一个读者就加一，走一个读者就减一，这里引入一个共享变量必然会成为临界资源，对于这个临界资源是肯定要对它进行保护的，采用的信号量机制如下：</p><ul><li>信号量 <code>Wmutex</code> 表示&quot;允许写&quot;，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>；</li><li>公共变量 <code>Rcount</code> 表示“正在读”的进程数，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>；</li><li>信号量 <code>Rmutex</code> 为了保护临界资源 <code>Rcount</code>，它表示对 <code>Rcount</code> 的互斥操作，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</li></ul><p>写者的操作伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(Wmutex); <span class="hljs-comment">// 申请写信号量</span><br>    write; <span class="hljs-comment">// 写</span><br>V(Wmutex);  <span class="hljs-comment">// 释放写信号量</span><br></code></pre></div></td></tr></table></figure><p>读者的操作相对复杂，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(Rmutex); <span class="hljs-comment">// 申请对 Rcount 的使用</span><br>    <span class="hljs-keyword">if</span> (Rcount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前读者是第一个读者</span><br>        <span class="hljs-comment">// 若允许他读，则要不允许后来的写者写</span><br>        <span class="hljs-comment">// 要将写操作的信号量做 P 操作</span><br>        P(Wmutex);<br>    &#125;<br>    ++Rcount; <span class="hljs-comment">// 读者数加一，上下对 Rmutex 的P，V操作实际上是为了保护 Rcount</span><br>V(Rmutex);<br>    …<br>    read; <span class="hljs-comment">// 读</span><br>    …<br>P(Rmutex);<br>    --Rcount; <span class="hljs-comment">// 读完之后读者数减一，上下对 Rmutex 的P，V操作实际上是为了保护 Rcount</span><br>    <span class="hljs-keyword">if</span> (Rcount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前读者是最后一个离开的读者</span><br>        <span class="hljs-comment">// 此时应该释放写操作，对写操作做 V 操作</span><br>        V(Wmutex);<br>    &#125;<br>V(Rmutex);<br></code></pre></div></td></tr></table></figure><h1 id="7-pv操作总结"><a class="markdownIt-Anchor" href="#7-pv操作总结"></a> 7 P，V操作总结</h1><p>信号量 <code>S</code> 为一个整型的变量，它描述的是当前可用资源的数目，当 <code>S &gt; 0</code> 时表示有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span></span></span></span> 个资源可用，当 <code>S = 0</code> 时表示无资源可用，当 <code>S &lt; 0</code> 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">| S |</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord">∣</span></span></span></span>表示 <code>S</code> 等待队列中的进程个数，<code>P(S)</code> 表示申请一个资源，<code>V(S)</code> 表示释放一个资源，信号量的初值应该大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 。</p><p>P，V 操作必须<strong>成对出现</strong>，有一个 P 操作就一定有一个 V 操作，且有以下规律：</p><ul><li><strong>当为互斥操作时</strong>：它们处于同一进程；</li><li><strong>当为同步操作时</strong>：它们不在同一进程中出现。</li></ul><p>对于前后相连的两个<code>P(S1)</code> 和 <code>P(S2)</code>，顺序是至关重要的，同步 P 操作应该放在互斥 P 操作前（如生产者消费者问题）。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%AD%BB%E9%94%81/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统原理第七章：死锁</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/"><span class="hidden-mobile">操作系统原理第五章：CPU调度</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>