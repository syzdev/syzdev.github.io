<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>操作系统原理第三章：进程 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="操作系统原理第三章：进程"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-14 18:41" pubdate>2020年3月14日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 45 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统原理第三章：进程</h1><div class="markdown-body"><h1 id="1-进程概念"><a class="markdownIt-Anchor" href="#1-进程概念"></a> 1 进程概念</h1><p>操作系统的基本特性是并发与共享，即在系统中同时存在几个相互独立的程序，他们交叉地运行并共享资源，在这样的过程中就会出现诸多问题，比如多个程序就要进行资源的竞争，程序之间的合作和协同，程序之间的通信，要解决这些问题，用程序的概念已经不能描述程序在内存中运行的状态 ，必须引入新的概念，即<strong>进程</strong>。</p><h2 id="11-顺序执行环境"><a class="markdownIt-Anchor" href="#11-顺序执行环境"></a> 1.1 顺序执行环境</h2><p><strong>顺序环境</strong>计算机系统只有一个程序在运行，该程序独占系统中所有资源，其执行不受外界影响，下图是顺序执行的两个作业的执行过程图：<br><img src="https://img-blog.csdnimg.cn/2020031415422352.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>顺序执行的特征：</p><ul><li><strong>顺序性</strong>：按照程序结构所指定的次序（可能有分支或循环）；</li><li><strong>封闭性</strong>：独占系统的资源；</li><li><strong>可再现性</strong>：初始条件相同则结果相同。</li></ul><h2 id="12-并发执行环境"><a class="markdownIt-Anchor" href="#12-并发执行环境"></a> 1.2 并发执行环境</h2><p><strong>并发环境</strong>一定时间内，物理机器上有两个或两个以上的程序同处于开始运行但尚未结束的状态，并且次序不是事先确定的，如下图所示：<br><img src="https://img-blog.csdnimg.cn/202003141545256.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>并发执行的特征：</p><ul><li><strong>间断(异步)性</strong>：“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li><li><strong>失去封闭性</strong>：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征；</li><li><strong>失去可再现性</strong>：失去封闭性导致失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征。</li></ul><blockquote><p>例如：观察者/报告者，有两个循环程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span>，它们共享一个变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span>。程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 每执行一次时都要做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">＝</mi><mi>N</mi><mi mathvariant="normal">＋</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">N＝N＋1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">＝</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">＋</span><span class="mord">1</span></span></span></span> 操作；程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 每执行一次时，都要做 <code>print(N)</code> 操作，然后再将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 置成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>，程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 以不同的速度运行。可能出现多报或漏报。（假定某时刻变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span> ）：</p><ul><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 之前，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=6，N=6，N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>；</li><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 之后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>5</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=5，N=0，N=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>；</li><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 之间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>5</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=5，N=6，N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>。</li></ul></blockquote><p>因此多道程序设计对操作系统提出了新的要求：</p><ul><li>如何描述并发程序的执行：引入进程及其状态；</li><li>如何实现并发程序运行：进程控制与调度；</li><li>如何处理资源的竞争与程序间的合作：并发控制与通信；</li><li>如何解决死锁：死锁策略。</li></ul><h2 id="13-进程的定义"><a class="markdownIt-Anchor" href="#13-进程的定义"></a> 1.3 进程的定义</h2><p>为了描述程序在并发执行时对系统资源的共享，我们需要一个<strong>描述程序执行时动态特征</strong>的概念，这就是<strong>进程</strong>，一个具有一定独立功能的<strong>程序</strong>在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程，相比程序，程序是一个静态的实体，而进程是一个动态的实体，引入多进程，提高了对硬件资源的利用率，但又带来额外的空间和时间开销，增加了操作系统的复杂性。一个进程包括如下内容：</p><ul><li>程序代码 (Program code)；</li><li>当前活动 (Current activity)；</li><li>相关数据 (Related data)：栈、堆、数据段，栈通常是一些临时数据，如函数参数，返回地址，局部变量等，堆通常是程序运行时申请的动态内存，数据段通常是全局变量。</li></ul><p>进程和程序的区别：</p><ul><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件、静态和可以复制；</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存；</li><li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）；</li><li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><p>进程的特征：</p><ul><li><strong>结构特征</strong>：进程实体=程序段+相关的数据段+PCB；</li><li><strong>动态性</strong>：进程的实质是进程实体的一次执行过程，因此动态性是进程的最基本的特征；</li><li><strong>并发性</strong>：多个进程实体同存在于内存中，且能在一段时间内同时运行。是最重要的特征；</li><li><strong>独立性</strong>：指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位；</li><li><strong>异步性</strong>：进程按各自独立的、不可预知的速度向前推进。</li></ul><p>进程描述信息：</p><ul><li>处于某种状态（运行、就绪、等待）；</li><li>进程控制块 PCB（数据结构）；</li><li>进程的执行程序（一个可执行文件）；</li><li>进程位于某个队列（就绪、等待某事件队列）；</li><li>占用某些系统资（内存，打开某些文件、处理机、外设）。</li></ul><h1 id="2-进程状态"><a class="markdownIt-Anchor" href="#2-进程状态"></a> 2 进程状态</h1><p>进程在执行时，会不断地改变其状态，进程有以下的状态：</p><ul><li><strong>新建 (new)</strong>：创建进程，构造了进程标识符，创建了管理进程所需的表格；</li><li><strong>就绪 (ready)</strong>：进程等待分配处理器，存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行（有多个进程处于此状态），如进程所分配的时间片用完后，会用运行状态转换为就绪状态，等待下一次分配时间片；</li><li><strong>运行 (running)</strong>：指令在执行，当进程由调度/分派程序分派后，得到 CPU 控制权，它的程序正在运行（在系统中，总只有一个进程处于此状态）；</li><li><strong>等待 (waiting)</strong>：进程等待某些事件发生，进程正在等待某个事件的发生（如等待 I/O 的完成），而暂停执行，即使给它 CPU 时间，它也无法执行；</li><li><strong>终止 (terminated)</strong>：进程执行完毕，终止后进程移入该状态，它不再有执行资格，表格和其它信息暂时由辅助程序保留，如为处理用户帐单而累计资源使用情况的帐务程序，当数据不再需要后，进程 (和它的表格) 被删除。</li></ul><p>各个状态之间的转换关系：<br><img src="https://img-blog.csdnimg.cn/20200314162920463.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p><h1 id="3-进程控制块pcb"><a class="markdownIt-Anchor" href="#3-进程控制块pcb"></a> 3 进程控制块PCB</h1><p>上面说到进程有多种状态，但操作系统该如何知晓当前进程的状态呢？所以我们要把进程的状态保存下来，这里就引入了一种描述进程信息的数据结构，<strong>进程控制块PCB</strong> (Process Control Block)：</p><ul><li>PCB (Process Control Block) 是一个专门的数据结构，系统用它来记录进程的外部特征，描述进程的运动变化过程；</li><li>PCB 是进程管理和控制的最重要的数据结构，在创建进程时，建立 PCB，并伴随进程运行的全过程，直到进程撤消而撤消，<strong>跟随进程的生命周期</strong>；</li><li>PCB 是系统感知进程存在的<strong>唯一</strong>标志，进程与 PCB 是一一对应的，有一个进程就会有一个 PCB，有一个 PCB就会有一个进程；</li><li>PCB 经常被系统访问，如：调度程序、资源分配程序、中断处理程序等，所以 PCB 应<strong>常驻内存。</strong></li></ul><h2 id="31-进程控制块pcb中的内容"><a class="markdownIt-Anchor" href="#31-进程控制块pcb中的内容"></a> 3.1 进程控制块PCB中的内容</h2><p>进程控制块 PCB 保存了同进程有关的信息，一般有下面这些必要内容：</p><ul><li><strong>进程状态 (Process state)</strong>：说明进程当前所处的状态；</li><li><strong>程序计数器 (Program counter)</strong>：指向执行程序的下个指令的地址；</li><li><strong>CPU寄存器 (CPU registers)</strong>：当进程因某种原因不能继续占用 CPU 时（如等待打印机），释放 CPU，这时就要将 CPU 的各种状态信息保护起来，为将来再次得到处理机恢复 CPU 的各种状态，继续运行；</li><li><strong>CPU调度信息 (CPU scheduling information)</strong>：包括CPU优先级，调度队列指针等；</li><li><strong>内存管理信息 (Memory-management information)</strong>：包括基址寄存器，界限寄存器以及页表或段表等；</li><li><strong>计账信息 (Accounting information)</strong>：包括 CPU 时间，实际使用时间，作业或进程数量等；</li><li><strong>I/O状态信息 (I/O status information)</strong>：包括分配给进程的 I/O 设备列表，打开文件列表等；<br><img src="https://img-blog.csdnimg.cn/2020031416482165.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></li></ul><h2 id="32-pcb的组织方式"><a class="markdownIt-Anchor" href="#32-pcb的组织方式"></a> 3.2 PCB的组织方式</h2><p>系统把 PCB 组织在一起，并放在内存的固定区域，就构成了 <strong>PCB 表</strong>，PCB 表的个数决定了系统中最多可同时存在的进程个数，称为系统的<strong>并发度</strong>，PCB表的组织方式有两种：</p><ul><li><strong>链接方式</strong>：一般通过链表的方式；</li><li><strong>索引方式</strong>：建立索引表。</li></ul><h1 id="4-操作系统调度"><a class="markdownIt-Anchor" href="#4-操作系统调度"></a> 4 操作系统调度</h1><p>在操作系统中多个程序并发的执行，但在单 CPU 机器中只有一个CPU，那么到底由哪一个程序来使用 CPU 呢？这就是一个调度问题，进程一般会在下面这些队列被调度：</p><ul><li><strong>作业队列</strong>：在系统中的所有进程的集合；</li><li><strong>就绪队列</strong>：在主内存中的，就绪并等待执行的所有进程的集合；</li><li><strong>设备队列</strong>：等待某一 I/O 设备的进程队列。</li></ul><p>其实上面所讲的进程状态的变化，实际上是在这些队列上不停的迁移，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200314170547449.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>进程调度的描述图：<br><img src="https://img-blog.csdnimg.cn/20200314174218497.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:55%"><br>在操作系统的调度分为不同级别的调度：</p><ul><li><strong>长程调度（或作业调度）</strong>：选择可以进入就绪队列的进程，也可以说是从外存中选择进入内存的调度过程；</li><li><strong>短程调度（或 CPU 调度）</strong>：选择可被下一个执行并分配 CPU；</li><li><strong>中程调度</strong>：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上（ 挂起 ），降低多道程序的度。当这些进程重新具备运行条件时，再从外存上调入内存：<br><img src="https://img-blog.csdnimg.cn/2020031417525324.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:90%"></li></ul><p>在操作系统中进程可以分为两类：</p><ul><li><strong>I/O 型进程</strong>：花费 I/O 时间多于计算，许多短 CPU 处理；</li><li><strong>CPU 型进程</strong>：花费更多时间于计算，许多长 CPU 处理。</li></ul><p>可以试想若是调度选择的大多数都是 I/O 型进程，少数 CPU 型进程，那么各个进程会在 CPU 上执行短暂的时间后转到 I/O 设备上，此时 I/O 设备就非常的忙碌，而 CPU 就相对空闲，反之 CPU 型的进程过多，也会造成 CPU 的忙碌，而 I/O 设备的空闲，这显然不是高效的调度方式。</p><p>当进程在运行中发生了中断，如 I/O 操作，那么会执行 CPU 的切换。如下图所示，在切换时要保存当前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">PCB_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="mord mathdefault" style="margin-right:.07153em">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的信息，然后加入切换的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">PCB_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="mord mathdefault" style="margin-right:.07153em">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 信息，然后运行完成后再恢复 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">PCB_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="mord mathdefault" style="margin-right:.07153em">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的信息：<br><img src="https://img-blog.csdnimg.cn/20200314175440965.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:60%"><br>上述切换的过程，我们称为<strong>上下文切换</strong>，当 CPU 切换至另一个进程时，系统必须保存旧进程状态并为新进程调入所保留的状态，而上下文切换的时间开销较重，在切换时，系统没有做有用的工作，时间取决于硬件的支持。</p><h1 id="5-进程操作"><a class="markdownIt-Anchor" href="#5-进程操作"></a> 5 进程操作</h1><p>进程是有生命周期的：产生、运行、暂停、终止。对进程的这些操作叫进程控制，对进程的操作如下图。进程控制的职责是对系统中进程实施有效的管理，它是CPU管理的一部分（还有进程同步、通信和调度）；当系统允许多进程并发执行时，为了实现共享、协调并发进程的关系，处理机管理必须对进程实行有效的管理。<br><img src="https://img-blog.csdnimg.cn/20200314175950745.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="6-创建进程"><a class="markdownIt-Anchor" href="#6-创建进程"></a> 6 创建进程</h1><p>进程创建的时机有以下几种：</p><ul><li><strong>作业调度</strong>：批处理系统中，作业调度程序调度到某个作业以后，就把这个作业装入内存，并分配必要的资源，创建进程，插入就绪队列；</li><li><strong>用户登录</strong>：在分时系统中，用户在终端键入登录命令后，若是合法用户，系统建立一个进程，并插入就绪队列；</li><li><strong>提供服务</strong>：用户向系统提出请求后，系统专门建立一个进程为用户服务。如打印请求；</li><li><strong>应用请求</strong>：应用进程的需要，由它自己创建一个新进程，使新进程以并发运行方式完成特定任务（输入数据并将处理结果输出到表格上）。</li></ul><blockquote><p>一个进程创建之后还可以创建进程，也就是父进程创建子进程，如此轮流创建进程下去，构成一个进程树，典型 UNIX 系统中的进程树如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020031418084236.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>关于资源共享问题，有如下三种情况：</p><ul><li>父进程子进程共享所有的资源；</li><li>子进程共享父进程资源的子集；</li><li>父进程和子进程无资源共享。</li></ul><p>关于进程执行问题，有如下两种情况：</p><ul><li>父进程和子进程并发执行；</li><li>父进程等待，直到子进程终止。</li></ul><p>关于进程地址空间问题，有如下两种情况：</p><ul><li>子女复制双亲；</li><li>子女有一个程序被调入。</li></ul></blockquote><h1 id="7-进程通信共享存储"><a class="markdownIt-Anchor" href="#7-进程通信共享存储"></a> 7 进程通信：共享存储</h1><p>由生产者-消费者问题讨探进程之间是如何共享存储，生产者-消费者问题是一类问题的抽象，它描述的是一类事物提供另一类事物所需的资源，比如某一个进程提供计算数据，另一个进程负责计算输出结果，不提供数据就无法进行计算输出，此时提供计算数据的进程就是生产者，负责计算输出的进程就是消费者，如下图所示，这个问题抽象出来的数据模型就是<strong>共享队列</strong>：<br><img src="https://img-blog.csdnimg.cn/202003141817488.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></p><h1 id="8-进程通信消息传递"><a class="markdownIt-Anchor" href="#8-进程通信消息传递"></a> 8 进程通信：消息传递</h1><p>消息传递是操作系统中的一个机制，能够使进程之间进行消息传递，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.13889em">P</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="mord mathdefault">Q</span></span></span></span> 要通信，需要建立通信连接，通过 <code>send/receive</code> 交换消息，通信链路的实现分为两种，一种是物理上的通过电子线路的实现，另一种是逻辑上的实现，我们主要考虑的是逻辑上的实现，连接的建立分为两种：</p><ul><li><p><strong>直接通信</strong>：进程必须显式的命名，如 <code>send (P, message)</code> 向进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.13889em">P</span></span></span></span> 发消息，<code>receive(Q, message)</code> 从进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="mord mathdefault">Q</span></span></span></span> 收消息，这种情况下连接自动建立，连接精确的与一对在通信的进程相关，在每一对之间就存在一个连接，连接可以无向，但通常是双向的，这种通信方式的缺点就是受模块化限制，比如某个时候进程 P 名字被修改，那么所有代码都需要修改。直接通信也有一个特殊的通信方式就是<strong>非对称通信方式 (asymmetric communication)</strong>，也就是说发送消息的时候是显示命名的，但接收消息的时候不指明接收方。</p></li><li><p><strong>间接通信</strong>：进程双方不是直接建立连接的，而是通过一个媒介，可以想象成一个<strong>信箱</strong>或<strong>端口</strong>，每个信箱都有一个唯一的 ID，不管是发送消息还是接收消息，都是通过这个信箱来完成的，如 <code>send(A, message)</code> 为向信箱 A 发送消息，<code>receive(A, message)</code> 为从信箱 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 接收消息，此时仅当进程共有一个信箱时连接才能建立，连接可同多个进程相关，每一对进程可共享多个通信连接，连接可是无向或双向的，但是为了确定发送者和接受者的唯一性，间接通信允许一个连接最多同 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 个进程相关，并且只允许一个时刻有一个进程执行接受操作，通过允许系统任意选择接收者，发送者被通知谁是接收者，这样发送方和接收方就被唯一的确定。相应的对信箱也有对应的操作，如创建新的信箱，通过信箱发送和接收消息，通信结束后销毁信箱等。</p></li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统原理第四章：线程</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"><span class="hidden-mobile">操作系统原理第二章：操作系统结构</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>