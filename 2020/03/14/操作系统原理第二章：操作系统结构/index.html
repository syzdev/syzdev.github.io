<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>操作系统原理第二章：操作系统结构 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="操作系统原理第二章：操作系统结构"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-14 14:31" pubdate>2020年3月14日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 48 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统原理第二章：操作系统结构</h1><div class="markdown-body"><h1 id="1-计算机硬件"><a class="markdownIt-Anchor" href="#1-计算机硬件"></a> 1 计算机硬件</h1><h2 id="11-计算机体系结构"><a class="markdownIt-Anchor" href="#11-计算机体系结构"></a> 1.1 计算机体系结构</h2><p>计算机的多种设备都是通过<strong>系统总线 (system bus)</strong> 连接在一起，这样就构成了一个基本的计算机系统，如下图，可以发现图中有很多的<strong>控制器 (controller)</strong>，事实上每个设备都对应着一个<strong>控制器 (controller)</strong>。<br><img src="https://img-blog.csdnimg.cn/20200314115650167.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:55%"></p><p>在这样的体系结构下，有如下特征：</p><ul><li>I/O 设备与 CPU 可并行运行；</li><li>每一设备控制器负责一个设备类型；</li><li>每一设备控制器有一<strong>局部缓存 (local buffer)</strong>；</li><li>CPU 通过局部缓存与主存交换数据；</li><li>I/O 从设备到设备控制器有局部缓存；</li><li>设备控制器通过引起<strong>中断 (interrupt)</strong> 通知 CPU 操作已完成。</li></ul><h2 id="12-中断机制"><a class="markdownIt-Anchor" href="#12-中断机制"></a> 1.2 中断机制</h2><p>中断指的是 CPU 在执行程序的时候出现了某些异常突发情况，需要紧急处理，CPU 必须暂停当前的任务去处理紧急突发事件，处理完之后又返回原程序被打断的地方去继续执行，中断通常分为以下两种：</p><ul><li><strong>硬件中断 (hardware interrupt)</strong>：设备控制器通知 CPU 它所做的操作已经完成，会触发一个中断；</li><li><strong>软件中断 (software interrupt)</strong>：一种是异常，指的是系统在执行过程中出现的错误，如除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 操作或无效的内存访问，另一种是<strong>系统调用 (system call)。</strong></li></ul><p>为什么需要中断呢？为什么有了中断后就能实现多道呢？如下图，用户程序一开始是在 CPU 上执行的，当执行到某个时间点的时候（图中横轴 <code>transfer done</code>）会触发一个中断，CPU 在延迟一点时间后会收到这个中断，收到中断后会去处理这个中断，也就是会从高电平的 <code>user process executing</code> 跳到低电平 <code>I/O interrupt processing</code>，中断处理完成后又会回到原来的用户程序继续执行，有了这样的中断机制带来的好处是在 CPU 执行的过程中，I/O 设备也在执行，能够使系统更高效，响应性更好<br><img src="https://img-blog.csdnimg.cn/20200314121222299.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></p><blockquote><p>为什么说有了通道技术和中断机制后才真正地实现了多道？</p><ul><li><strong>通道</strong>是一种控制外部设备的硬件结构，它独立于 CPU 运行，因此 I/O 操作能和 CPU 并行运行，但以前CPU 依然要发送指令询问通道是否完成工作，若未完成，CPU 则要一直询问直到通道工作完成，虽然引入通道技术提高了效率，但是并未实现真正的多道并行；</li><li><strong>中断</strong>和通道结合起来就实现了多道，CPU 启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，通过中断机构向 CPU 发出中断请求，CPU 则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作，这样，就真正做到了 CPU 与 I/O 设备并行工作。</li></ul></blockquote><p>现代操作系统是中断驱动的，中断将控制权转移到中断服务程序，所谓中断服务程序就是中断出现后要去执行处理的那一段程序代码，实现控制权转移的方法如下：</p><ul><li>在中断服务程序中有单独的一段代码，来确定当前中断属于哪种类型的中断；</li><li>会有一个<strong>通用的历程</strong>去检查中断信息，当中断发生时，就会调用中断服务程序；</li><li>当检查到中断时，要求能快速处理，这里的实现方法是利用<strong>中断向量 (interrupt vector)</strong>，中断向量就存储了服务历程的地址。</li></ul><p>下表列出了常见的中断向量，中断号及其功能：</p><table><thead><tr><th>中断向量</th><th>中断号</th><th>中断功能</th></tr></thead><tbody><tr><td>00~03</td><td>0</td><td>除法溢出中断</td></tr><tr><td>04~07</td><td>1</td><td>单步 (用于DEBUG)</td></tr><tr><td>08~0B</td><td>2</td><td>非屏蔽中断 (NMI)</td></tr><tr><td>0C~0F</td><td>3</td><td>断点中断 (用于DEBUG)</td></tr><tr><td>10~13</td><td>4</td><td>溢出中断</td></tr><tr><td>14~17</td><td>5</td><td>打印屏幕</td></tr><tr><td>18~1F</td><td>6，7</td><td>保留</td></tr></tbody></table><h2 id="13-io操作"><a class="markdownIt-Anchor" href="#13-io操作"></a> 1.3 I/O操作</h2><p>使用 I/O 操作需要具备以下条件：</p><ul><li>设备与设备控制器相连；</li><li>本地缓冲器，一组寄存器；</li><li>设备驱动程序。</li></ul><p>有两种常见的 I/O 操作：</p><ul><li><strong>同步 (Synchronous)</strong>：当启动 I/O 操作时，直到 I/O 操作结束后，控制权才会返回到用户程序，也就是说你运行了一个程序，但突然触发了 I/O，那么你的程序要等待这次 I/O 操作结束后，才会运行；</li><li><strong>异步 (Asynchronous)</strong>：当启动 I/O 操作时，控制权会立马转到用户程序，那么此时 I/O 操作是否运行结束是通过中断机制来实现的。</li></ul><p>下图是同步和异步的比较：<br><img src="https://img-blog.csdnimg.cn/20200314130412353.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></p><h1 id="2-硬件保护"><a class="markdownIt-Anchor" href="#2-硬件保护"></a> 2 硬件保护</h1><p>当计算机执行过程中，计算机硬件需要提供一些支持能够保证计算机能够正确的运行，在早期的操作系统中为单用户系统，程序员可完全控制系统，在后来的批处理操作系统中，通过读取卡片来录入程序和数据，此时有可能会把其他程序当作当前程序的数据输入进去了，在这个时候就需要提供一些保护，而后的多道批处理系统就更为复杂，它运行多个程序并发执行，多个程序竞争某些资源，当一个程序在执行过程中，它有可能会修改到其他程序的代码或数据，甚至可能会修改操作系统，这时为了能够让计算机正确执行，必须提供一些保护。</p><p>那么解决的方法就是当程序在执行非法指令或访问不属于自己的地址空间内存时把控制权交给操作系统，甚至情况严重时可以直接终止程序。</p><h2 id="21-实现保护两状态操作"><a class="markdownIt-Anchor" href="#21-实现保护两状态操作"></a> 2.1 实现保护两状态操作</h2><p>共享系统资源要求操作系统确保当前程序不会引起其他程序的运行错误，我们的方法是<strong>两状态操作</strong>，即至少在两个运行状态之间提供硬件支持：</p><ul><li><strong>用户态 (User mode)</strong>：代表用户执行；</li><li><strong>管态，特权模式或系统模式 (Monitor mode)</strong>：代表操作系统执行。</li></ul><p>那么计算机是如何区分这两种状态呢？在计算机中实现的方法很简单，只需要一个位的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 就可以区分，这个位叫做模式位 (mode bit) ，表示当前模式 <code>monitor (0) or user (1)</code>，这个模式位可以放在 <code>PSW</code> 中（PSW 是 Program Status Word 的缩写，即程序状态字），当系统引导启动时，硬件处于管态，在用户模式下执行用户进程，如下图：<br><img src="https://img-blog.csdnimg.cn/2020031413212956.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>若在用户程序中出现了问题，就会触发中断，出现中断或陷阱，硬件切换到管态，一旦切换到管态，控制权就转交给了操作系统，由操作系统来处理这些中断错误信息，那么操作系统如何知道用户程序执行了非法操作呢？在操作系统中把只能由管态执行的指令称为<strong>特权指令 (Privileged instructions)</strong>，若用户程序执行到了特权指令，那么就可判断当前操作为非法操作，可能会引发错误，但是有时候用户程序要执行特权指令怎么办？操作系统中提供了<strong>系统调用 (system call)</strong> 方式，可以让用户程序合法的使用特权指令，<strong>系统调用实际上会触发软中断</strong>，那么就会<strong>从用户态切换到了管态</strong>，控制权也转交给了操作系统。在处于管态下，特权指令是可以直接执行的。</p><p>使用这种方法，也可以对所有的 I/O 操作进行保护，我们把所有的 I/O 操作定义为特权指令，用户不能直接用 I/O 指令，必须通过系统调用，确保用户程序不能在管态下控制计算机，下图是系统调用执行 I/O 操作的过程：<br><img src="https://img-blog.csdnimg.cn/20200314132931819.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>既然系统调用是通过软中断来实现的，那么也要保护中断机制不能被破坏，所以必须保护中断向量和中断服务程序，而程序都是在内存中，所以问题也转换为了对某些内存的保护，因此要划分进程能够运行的合法空间，划分合法空间用到了两个寄存器，通俗来讲这两个寄存器就是来划分合法空间地址的起点和空间的大小，有了这两个值，那么就唯一确定了这一块内存空间：</p><ul><li><strong>基址寄存器 (base register)</strong>：指出起始地址；</li><li><strong>界限寄存器 (limit register)</strong>：指出空间大小。</li></ul><p>如下图的 <code>job2</code> 就被两个寄存器唯一确定了：<br><img src="https://img-blog.csdnimg.cn/20200314133801309.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>在具体实现时，CPU每得到一个地址，都需要去检测该地址的合法性，流程图如下：<br><img src="https://img-blog.csdnimg.cn/20200314133941214.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></p><h2 id="22-cpu保护"><a class="markdownIt-Anchor" href="#22-cpu保护"></a> 2.2 CPU保护</h2><p>需防止用户程序陷入死循环或者不调用系统服务且不将控制权返回到操作系统，解决的方法就是使用<strong>定时器 (timer)</strong>，也就是说当从管态切换到用户态时，设置了一个定时器，当定时器时间到的时候就会触发一个中断，那么控制权就会转交给操作系统，操作系统又重新获得了控制权。</p><h1 id="3-操作系统服务"><a class="markdownIt-Anchor" href="#3-操作系统服务"></a> 3 操作系统服务</h1><p>操作系统是覆盖在计算机硬件系统上的第一层软件，对于这个复杂的软件系统，必须清楚其设计的目标是什么，应该提供哪些服务，通常会考虑以下三个方面：</p><ul><li>提供的服务 (services it provides)；</li><li>为用户和程序提供的接口 (interface to users and programmers)；</li><li>各组成部分及其相互连接 (components and their interconnections)。</li></ul><h2 id="31-提供的服务"><a class="markdownIt-Anchor" href="#31-提供的服务"></a> 3.1 提供的服务</h2><p>针对用户要提供的服务：</p><ul><li><strong>用户接口 (User interface)</strong>：通过这些接口，用户能够访问到操作系统提供的功能，几乎所有的操作系统都有用户接口，常见的表现形式分为<strong>命令行 Command-Line (CLI)</strong> 和 <strong>图形用户界面 Graphics User Interface (GUI)</strong>；</li><li><strong>执行程序 (Program execution)</strong>：能够把程序调入内存，并转交给 CPU 处理的能力；</li><li><strong>I/O操作 (I/O operations)</strong>：由于用户程序不能直接执行 I/O 操作，操作系统必须提供手段完成 I/O 操作；</li><li><strong>文件系统操作 (File-system manipulation)</strong>：读、写、创建和删除文件的能力；</li><li><strong>通信 (Communications)</strong>：运行的进程在同一计算机或由网络连接的不同系统中交换信息。通过共享存储器或消息传递实现；</li><li><strong>错误检测 (Error detection)</strong>：探测在 CPU 与内存硬件中，在 I/O 设备中，或在用户程序中的错误，确保正确运算。</li></ul><p>针对提高系统效率要提供的服务：</p><ul><li><strong>资源分配 (Resource allocation)</strong>：把资源分配给多个用户或多个同时运行的作业；</li><li><strong>帐务 (Accounting)</strong>：跟踪和记录用户对资源的使用，用于帐单和统计哪些资源已经分配出去了，哪些资源是可用的等等；</li><li><strong>保护 (Protection)</strong>：确保对资源的所有访问均在控制中。</li></ul><p>下图是整个操作系统提供的服务结构图：<br><img src="https://img-blog.csdnimg.cn/20200314135642462.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p><h1 id="4-系统调用"><a class="markdownIt-Anchor" href="#4-系统调用"></a> 4 系统调用</h1><p>根据上面的服务结构图可以找到 <code>system calls</code>，他处在的位置是操作系统众多服务之上，用户接口之下，它的功能就是给用户提供方法来使用系统服务，系统调用提供在运行程序和操作系统之间的接口，系统调用由于接近底层，不方便使用 ，并且不同的操作系统的系统调用使用都有差别，所以实际上大多数程序员在开发时都是直接使用 <strong>API ( level Application Program Interface)</strong>，API 实际上就是系统调用的封装，里面可能封装了一个或多个系统调用，常见的系统 API 有 Win32 API for Windows，Java API for the Java virtual machine (JVM) 等等。</p><h2 id="41-系统调用的处理过程"><a class="markdownIt-Anchor" href="#41-系统调用的处理过程"></a> 4.1 系统调用的处理过程</h2><p>系统调用的处理过程如下：</p><ol><li>当用户使用系统调用时，产生一条相应的指令；</li><li>CPU 在执行到该指令时发生<strong>中断</strong>，发出有关的信号给陷入处理机构；</li><li>处理机构在收到了 CPU 发来的信号后，启动相关的处理程序去完成该系统调用所要求的功能；</li><li>在处理系统调用之前，陷入处理机构还需保存处理机现场（PSW、PC、系统调用号、用户栈指针、通用寄存器、用户定义的参数等）。</li></ol><p>不同的系统调用对应着不同的子程序代码段，我们通过入口地址表，使每个入口地址与相应的系统程序对应，陷入处理程序用系统调用功能号查找入口地址表，得到该系统程序的入口地址，并执行之，系统调用处理结束后，要恢复处理机现场，从而用户程序可以继续执行，过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200314140710410.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></p><h2 id="42-系统调用传递参数的方式"><a class="markdownIt-Anchor" href="#42-系统调用传递参数的方式"></a> 4.2 系统调用传递参数的方式</h2><p>在系统调用时，难免需要传递一些参数来实现特定的功能，有三种常用方式用于在运行程序和操作系统之间的参数传递：</p><ul><li><strong>寄存器</strong>中的参数传递，寄存器容量较小，故只适用于少量且小的参数传递；</li><li>参数存在内存的一张<strong>表</strong>中，表地址作为寄存器的参数传递，如下图所示，若传递的参数比较大的时候，先把参数放到内存里，这些参数在内存中的地址就放在寄存器 (register) 中，当使用系统调用时就会查找寄存器然后取出地址再转到内存中去寻找参数：<br><img src="https://img-blog.csdnimg.cn/20200314141018597.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></li><li>程序把参数压入<strong>栈</strong>，由操作系统弹出。</li></ul><h2 id="43-系统调用的分类"><a class="markdownIt-Anchor" href="#43-系统调用的分类"></a> 4.3 系统调用的分类</h2><p>系统调用的分类如下：</p><ul><li>进程控制 (process control)；</li><li>文件管理 (file management)；</li><li>设备管理 (device management)；</li><li>信息维护 (information maintenance )；</li><li>通信 (communications)。</li></ul><h1 id="5-操作系统结构"><a class="markdownIt-Anchor" href="#5-操作系统结构"></a> 5 操作系统结构</h1><p>这一节主要讨论的问题是操作系统中各个组件之间的关系，操作系统的早期非常简单，如 MS-DOS 以最小的空间提供最多的功能，它并不划分模块。</p><p>在 MS-DOS 中，应用程序可直接访问 BIOS 例程，来直接操纵设备，当然这受限于当时的硬件，Intel8088 没提供双模式和硬件保护，这使得 DOS 别无选择只能任由应用程序访问 BIOS，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200314141552827.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>而在 UNIX 中，受硬件功能限制，早期 UNIX 只是有限的结构化。UNIX 包括 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 个分离的部分：</p><ul><li>系统程序 (Systems programs )；</li><li>内核 (The kernel)：包括了在物理硬件之上，系统调用之下的一切。提供文件系统，CPU调度，存储管理，和其他操作系统功能 ，每一层有大量的功能，如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020031414183889.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></li></ul><h2 id="51-层次化系统结构"><a class="markdownIt-Anchor" href="#51-层次化系统结构"></a> 5.1 层次化系统结构</h2><p>操作系统划分为若干层，在低层上构建高层。底层（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 层）为硬件，最高层（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 层）为用户层，在设计时考虑模块化，层的选择是每层只使用低层次的功能和服务，由此分层的基本原则是每一层都使用其底层所提供的功能和服务，以便于系统调试和验证，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200314142119323.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></p><p>最早使用层次化操作系统的是 THE 操作系统，它有如下六层：<br><img src="https://img-blog.csdnimg.cn/2020031414224570.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>分层有如下优点：</p><ul><li>低层和高层可分别实现（便于扩充）；</li><li>高层错误不会影响到低层，便于调试、利于功能的增删改；</li><li>调用关系清晰（高层对低层单向依赖），避免递归调用，有利于保证设计和实现的正确性。</li></ul><p>分层有如下缺点：</p><ul><li>系统中所有进程的控制转移、通讯等任务全部交给系统的核心去管理，要花费一定的代价。</li></ul><h2 id="52-微内核"><a class="markdownIt-Anchor" href="#52-微内核"></a> 5.2 微内核</h2><p>微内核 (Microkernels) 对层次进行进一步的划分，通过划分系统程序和用户程序，把所有不必要的部件移出内核，形成一个小内核，微内核提供最少量的进程管理、存储管理，以及通信功能。</p><p>微内核操作系统由两大部分组成：</p><ul><li>运行在核心态的内核，即保留下来的核心功能；</li><li>运行在用户态并以 C/S 方式运行的进程层，即移出去的不必要功能。</li></ul><p>移出去的功能通过一种 Server 运行，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200314142853765.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p><p>微内核与传统操作系统相比，有如下特点：</p><ul><li><strong>内核精巧</strong>：通常内核只由任务管理、虚存管理和进程间通信 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 个部分组成。传统操作系统内核中的许多部分都被移出内核，采取服务器方式实现；</li><li><strong>面向多处理机和分布式系统</strong>：基于微内核的操作系统，在内核中引入了多处理机调度和管理机制，并引入了细粒度并发机制，即线程，使得多个处理机可以在同一个任务中并行地执行；</li><li><strong>基于客户／服务器体系结构</strong>：在微内核结构的操作系统中，任务间通信机制，消息机制是系统的基础，操作系统的各种功能都以服务器方式实现，向用户提供服务。用户对服务器的请求是以消息传递的方式传给服务器的。</li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统原理第三章：进程</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"><span class="hidden-mobile">操作系统原理第一章：操作系统概述</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>