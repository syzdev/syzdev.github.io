<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content=""><meta name="author" content="syz"><meta name="description" content=""><title>操作系统原理第十章：文件系统 | syzdev</title><link rel="apple-touch-icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/color-scheme.css"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/comments.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script defer type="text/javascript" src="/plugins/jquery.min.js"></script><link href="/plugins/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img src="/img/avatar.png" alt=""></a><div class="nickname"><a href="/">syzdev</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/about/"><a href="/about/">关于</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async type="text/javascript" src="/plugins/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">操作系统原理第十章：文件系统</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-21 16:14:10 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"><b>#</b> 操作系统原理</a></span></span></div><div class="markdown-body"><h1 id="1-文件概念及文件逻辑结构"><a class="markdownIt-Anchor" href="#1-文件概念及文件逻辑结构"></a> 1 文件概念及文件逻辑结构</h1><p>文件对用户来说是连续的逻辑地址空间，它是存储在磁盘上的，文件是记录在外存上的具有名字的相关信息的集合，文件里面通常保存数据或程序。</p><h2 id="11-文件的分类"><a class="markdownIt-Anchor" href="#11-文件的分类"></a> 1.1 文件的分类</h2><p>文件的分类可以按照如下类别来分：</p><ul><li>按用途分类可以分为：系统文件，库文件，用户文件；</li><li>按按信息保存期限分类可以分为：临时文件，永久文件，档案文件；</li><li>按文件的保护方式分类可以分为：只读文件，读写文件，只执行文件；</li><li>按文件的逻辑结构分类可以分为：流式文件，记录式文件；</li><li>按文件的物理结构分类可以分为：顺序（连续）文件，链接文件，索引文件；</li><li>按信息流向分类可以分为：输入文件，输出文件，输入/输出文件 (存储设备)；</li><li>按文件中的数据分类可以分为：源文件，目标文件，可执行文件；</li><li>按文件的性质分类可以分为：普通文件，目录文件，特殊文件。</li></ul><h2 id="12-文件的属性"><a class="markdownIt-Anchor" href="#12-文件的属性"></a> 1.2 文件的属性</h2><p>无论将文件如何来分类，文件都有一些共性的东西，我们称之为文件的属性，通常有如下属性：</p><ul><li>文件名：唯一的以人们可以理解的方式保存的信息；</li><li>类型：需要可以支持多种类型的系统；</li><li>位置：指向文件在设备上的存储位置的指针；</li><li>大小：当前文件的大小；</li><li>保护：控制对文件的读取，改写和执行的权限；</li><li>时间，日期和用户身份：保护和安全需要的数据。</li></ul><p>上述的这些文件属性信息会保存在磁盘上的目录结构中。</p><h2 id="13-文件结构"><a class="markdownIt-Anchor" href="#13-文件结构"></a> 1.3 文件结构</h2><p>用户和文件系统往往从不同的角度对待同一个文件的：</p><ul><li><strong>用户</strong>：从使用的角度，按信息的使用和处理方式组织文件；</li><li><strong>文件系统</strong>：从文件的存储和检索的角度，根据用户对文件的存取方式和存储介质的特性组织文件，决定用户文件存放在存储介质上的方式。</li></ul><p>这样就导致了文件有两种形式的结构，即文件的逻辑结构和文件的物理结构：</p><ul><li><strong>逻辑结构</strong>：用户对文件的组织结构；</li><li><strong>物理结构</strong>：文件在外存储器上的存储结构。</li></ul><p>物理结构直接影响存储空间的使用和检索文件信息的速度，逻辑文件保存到存储介质上的工作由文件系统来做，这样可减轻用户的负担。</p><p>文件从<strong>逻辑结构</strong>上分成二种形式，一种是<strong>无结构的流式文件</strong>，另一种是<strong>有结构的记录式文件</strong>：</p><ul><li><strong>流式文件</strong>：指对文件内信息不再划分单位，它是依次的一串字符流构成的文件；</li><li><strong>记录式文件</strong>：是用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位称为一个逻辑记录（简称记录）。记录的长度可分为定长和不定长记录两类。</li></ul><p>我们重点讨论的是<strong>记录式的文件</strong>，记录文件有顺序、索引、索引顺序文件几种。</p><ul><li><strong>顺序文件</strong>：顺序文件的所有记录按键值的约定次序组织，记录可以是定长的，也可以是变长的，顺序文件常用于批量记录读取。对于定长记录文件，若要查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 个记录，可根据下式得到相对于第一个记录首址的地址：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi><mo>∗</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">A_i =i*d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">d</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">d</span></span></span></span> 为记录的长度）。对于非定长记录文件，若要查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 个记录，则需要有每个记录的长度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mo>∑</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i =∑d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-.25001em"></span><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">d</span></span></span></span> 为记录的长度），不支持直接存取。</li><li><strong>索引文件</strong>：为解决非定长记录文件无法直接存取问题，往往建立一张索引表，记录下每个记录的长度及指向该记录的指针，从而方便了直接存取，索引表就类似于书的目录，指明了每个章节都在哪一页。索引文件对主文件中的记录按需要的数据项（一个或几个）建索引表，为每个记录设置一个表项，索引文件本身是顺序文件组织。</li><li><strong>索引顺序文件</strong>：事实上索引文件给每个数据项建立索引表这样的开销是比较大的，于是就有了索引顺序文件， 索引顺序文件先将顺序文件中的所有记录分为若干个组；再为顺序文件建立一张索引表，表中记录每个组的第一个记录，该索引项包含记录的键值和指向该记录的指针。它是顺序文件和索引文件的结合，检索时，先根据关键字去检索索引表，找到该记录所在组的第一个记录的位置，然后再利用顺序查找法去查找主文件，找到所需记录。如下图，给每个姓名首字母都分了组，然后在索引表中只用保存每个组的首地址即可，找到首地址后，再在组内进行顺序查找：<br><img src="https://img-blog.csdnimg.cn/20200321133758895.png" alt="在这里插入图片描述" style="zoom:50%"></li></ul><h1 id="2-文件访问方式"><a class="markdownIt-Anchor" href="#2-文件访问方式"></a> 2 文件访问方式</h1><p>前面提到文件有多种存储结构，在访问文件时，所采用的方式也是和文件的组织方式密切相关，常用的存取方式有如下两种：</p><ul><li>顺序存取 (Sequential access)；</li><li>直接/随机存取 (Direct access)。</li></ul><h2 id="21-顺序存取"><a class="markdownIt-Anchor" href="#21-顺序存取"></a> 2.1 顺序存取</h2><p>顺序存取是最简单的访问方式，它就是按照文件信息的逻辑顺序依次存取：</p><ul><li>在记录文件中：按记录的排列顺序来存取；</li><li>在流式文件中：反映为当前读写指针的变化，在存取完一段信息后，读写指针自动加上这段信息的长度，以便指出下次存取时的位置。</li></ul><p>顺序存储示意图如下图所示，<strong>当前指针 (Current position)</strong> 可以向后读，也可以回到起始位置：<br><img src="https://img-blog.csdnimg.cn/20200321134451787.png" alt="在这里插入图片描述" style="zoom:80%"></p><h2 id="22-直接随机存取"><a class="markdownIt-Anchor" href="#22-直接随机存取"></a> 2.2 直接/随机存取</h2><p>直接/随机存取可以直接定位到文件中的任何一个记录，而不需要像顺序存取一样要把路径中的所有记录过一遍。</p><p>对于连续文件 (固定长度)，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 个记录的地址 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">addr_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为首记录地址，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">L</span></span></span></span> 为记录长度) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>p</mi><mi>t</mi><mi>r</mi><mo>=</mo><mi>a</mi><mi>d</mi><mi>d</mi><msub><mi>r</mi><mn>0</mn></msub><mo>+</mo><mi>i</mi><mo>∗</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">rptr=addr_0+i*L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">L</span></span></span></span>，在非定长文件中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">L</span></span></span></span> 的值不固定，所以<strong>非定长文件不支持随机存储</strong>。</p><p>对于索引文件，是支持随机存取的，因为我们可以先随机查找索引表，再取地址。</p><h2 id="23-文件的存储设备"><a class="markdownIt-Anchor" href="#23-文件的存储设备"></a> 2.3 文件的存储设备</h2><p>文件的访问方式不仅和文件的存储方式有关，还和文件的存储设备有关，因为文件时保存在存储设备上的，文件自身也带有物理设备的特性。</p><p>文件的存储设备主要有磁带，磁盘，光盘等，存储设备的特性可以决定文件的存取方法，对于上述的几种存储设备，它们都是以块为单位存储数据的，因此文件的存储设备常常划分为若干大小相等的物理块，以块为单位进行信息的存储、传输。</p><p>以磁带为例，磁带可以永久保存大容量数据，它是一种顺序存取设备，即前面的物理块被存取访问之后，才能存取后续物理块的内容。磁带存取速度较慢：主要用于后备存储，或存储不经常用的信息，或用于传递数据的介质，现在磁带已经基本上被淘汰了。下图是磁带存储示意图：<br><img src="https://img-blog.csdnimg.cn/20200321135504685.png" alt="在这里插入图片描述" style="zoom:67%"><br>再以磁盘为例，磁盘是一种随机存储设备，它既可以顺序存取，也可以随机存取。它可以直接定位到某个磁道上的某个扇区，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321135647401.png" alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="3-文件的物理结构"><a class="markdownIt-Anchor" href="#3-文件的物理结构"></a> 3 文件的物理结构</h1><p>用户按逻辑结构使用文件，文件的物理结构对用户来说是不必关心的，但对文件系统来说却是至关重要的，因为它直接影响存储空间的使用和检索文件信息的速度。文件系统按物理结构管理文件，当用户请求读写文件时，文件系统必须实现文件的逻辑结构与物理结构之间的转换。</p><p>文件的物理结构指的是文件在外存的存放组织形式，文件的物理结构与存储设备的特性有很大关系，前面提到过文件的存储设备通常划分为大小相等的物理块，物理块是分配及传输信息的基本单位，一个物理块中可以存放若干个逻辑记录，一个逻辑记录也可以存放在若干个物理块中。</p><p>所以文件的物理结构取决于外存的分配方式，当采用连续分配方式时，就是<strong>顺序结构</strong>；当采用链接分配方式时，就是<strong>链接结构</strong>；当采用索引分配方式时，就是<strong>索引结构</strong>。</p><h2 id="31-顺序结构"><a class="markdownIt-Anchor" href="#31-顺序结构"></a> 3.1 顺序结构</h2><p>这是最简单的物理文件结构，它将逻辑上连续的文件信息依次存放在外存连续的物理块中。如下图表示磁盘的存储空间，当文件要存储的时候，就为它找一段连续的存储空间存放，图中相同颜色的物理块表示一个文件，可以发现它们都是连续存放的。当我们需要找到某个文件的时候，要知道文件的首地址和长度，而这两个值都是保存在目录中的：<br><img src="https://img-blog.csdnimg.cn/20200321141734474.png" alt="在这里插入图片描述" style="zoom:50%"><br>在这种分配方式下，每一个文件占用一个连续的磁盘块的集合，它的实现也非常简单，只需要起始块号和长度。同时它也可以随机存取，因为目录中保存了起始地址和长度，可以直接定位到某个文件。若是存储在磁盘中，其所需的磁盘寻道次数和寻道时间也比较少。</p><p>这种分配方式也有不足的地方，如现在有一个文件需要占据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个物理块，若查询内存剩余容量可以发现剩余有 $15 $个内存块（以上图为例），但是依然无法分配，因为并没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个<strong>连续</strong>的物理块，这个时候就出现了<strong>外碎片</strong>问题。</p><p>另外这种分配方式下<strong>文件不能动态增长</strong>，由于分配方式时顺序的，所以存储的方向也是固定的，如果某个文件要添加内容，可能导致物理块不够用，比如文件 <code>tr</code> 想增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 个物理块，就无法完成。</p><h2 id="32-链接结构"><a class="markdownIt-Anchor" href="#32-链接结构"></a> 3.2 链接结构</h2><p>顺序结构最大的问题就是外碎片问题，造成这个问题的主要原因就是顺序分配，参照内存中解决外碎片的方法，文件的物理结构也可以采用离散的分配方式，即采用链接结构。</p><p>在链接分配方式下按所需分配磁盘块，通过链接指针链接在一起，如下图只需要知道起始块和最后一块即可：<br><img src="https://img-blog.csdnimg.cn/2020032114561627.png" alt="在这里插入图片描述" style="zoom:67%"><br>可以发现一个文件的物理块分散在磁盘的各个地方，在这种分配方式下<strong>消除了外碎片问题</strong>，但是缺点是<strong>无法支持随机存取</strong>了，若想知道文件的逻辑第三个物理块，则必须从首个物理块开始找到第三个块，而不能直接定位到第三个物理块。同时由于是指针链接，<strong>指针占据了一定的空间</strong>，而且存取速度较慢，物理块离散的分布，在磁盘存储中会带来更多的寻道次数和寻道时间。另外在这种分配方式下，只要磁盘中还有空间，文件时可以动态增长的。</p><p>解决指针占据空间的问题可以将多个块组成簇，以簇为单位分配，指针占用百分比减少，但增加内碎片，比如规定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span> 个物理块为一个簇，每次分配都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span> 个物理块为单位分配。</p><p>为了支持随机存取，引入了<strong>文件分配表FAT (File allocation table )</strong>，每个磁盘会有一张文件分配表，里面的表项是和磁盘的物理块个数是一一对应的，每个表项存的内容就是该物理块的下一个物理块在什么地方，如下图所示，要找到某个文件只需要知道文件的起始地址就可以了，这样就间接的实现了随机存取，若要寻找文件逻辑上的第三个物理块，则只需要查询文件分配表即可，查找速度会非常快。：<br><img src="https://img-blog.csdnimg.cn/20200321150927147.png" alt="在这里插入图片描述" style="zoom:80%"></p><h2 id="33-索引结构"><a class="markdownIt-Anchor" href="#33-索引结构"></a> 3.3 索引结构</h2><p>回顾顺序结构和链接结构，顺序结构支持随机存取，但有外碎片；链接结构没有外碎片，但不能直接存取，虽然引入的 FAT 可以随机存取，但需要占用较大的内存空间。</p><p><strong>事实上，打开某个文件时，只需知道该文件所在的盘块号</strong>， 一个文件的信息存放在若干不连续物理块中，系统<strong>为每个文件建立一个索引表</strong>，并将这些块的块号存放在索引表中，一个索引表就是磁盘块地址数组，其中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 个条目指向文件的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 块，如下图，所有灰色的物理块同属于一个文件 <code>jeep</code>，文件目录中会保存这个文件的索引表的编号，在索引表会找到该文件对应的所有物理块。这个索引表也是需要保存的，我们把它也保存在磁盘中，图中的物理块 <code>19</code>，叫做<strong>索引块</strong>：<br><img src="https://img-blog.csdnimg.cn/20200321151643634.png" alt="在这里插入图片描述" style="zoom:67%"><br>可以发现索引分配是支持随机存取的，由于它也是一种离散的分配方式，所以它也没有外碎片。索引分配显然也是支持文件动态增长的。但是要建立索引表放在磁盘上，所以索引表是要占据磁盘空间的，同时因为是离散分配，也无法避免的增加了较多的寻道次数和寻道时间。</p><p>由于文件的大小是不定的，所以合理的设计索引表会提高检索速度，也能减少空间开销。当文件很小的时候，一张索引表就可以解决，当文件很大的时候，一张索引表可能就放不下了，因此有如下两种方案：</p><ul><li><strong>链接模式</strong>：将一个大文件的一个索引表接着一个索引表，链接起来，相当于将多个小的索引表拼凑成一个大索引表来满足大文件的存储需求；</li><li><strong>多级索引</strong>: : 将一个大文件的所有索引表（二级索引） 的地址放在另一个索引表（主索引，一级索引）中，也就是索引表的每个表项又指向了另一张索引表，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321152927102.png" alt="在这里插入图片描述" style="zoom:80%"></li></ul><blockquote><p>在两级索引分配方式，若每个盘块大小为 <code>1KB</code>，每个盘块号占 <code>4 Byte</code>，则一个索引块中可存放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 个盘块号，则两级索引最多可包含的盘块号总数为 <code>64K</code> 个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>256</mn><mo>∗</mo><mn>256</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（256*256）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord cjk_fallback">（</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord cjk_fallback">）</span></span></span></span>。因此，所允许的文件的最大长度为<code>64 MB</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>64</mn><mi>K</mi><mo>∗</mo><mn>1</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（64K*1KB）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord cjk_fallback">（</span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:.07153em">K</span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mord cjk_fallback">）</span></span></span></span>。</p></blockquote><h1 id="4-目录"><a class="markdownIt-Anchor" href="#4-目录"></a> 4 目录</h1><p>有些系统保存了上百万的文件，为了管理这些数据，需要组织它们，所以引入了<strong>目录管理</strong>，文件目录通常分为两部分：</p><ul><li>磁盘可以分成一个或多个<strong>分区</strong>；</li><li>每个分区都包含了存储在分区中的文件的信息，这些信息保存在<strong>设备目录</strong>中，设备目录记录分区上所有文件的各种信息。</li></ul><p>目录是一个包含着所有文件信息的节点的集合，每一个目录项对应着一个文件，如下图：<br><img src="https://img-blog.csdnimg.cn/20200321153822181.png" alt="在这里插入图片描述" style="zoom:67%"><br>目录本身也是要保存下来的，目录和文件都是保存在磁盘上的，在目录中通常会保存文件的名称、类型、地址、当前长度、最大长度、最后访问时间、数据最后更新时间、所有者 ID、保护信息等信息。</p><p>这些信息具体保存在<strong>文件控制块 FCB</strong> 中，用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的盘物理地址。文件控制块的有序集合称为文件目录，即一个文件控制块 FCB 就是一个文件目录项。文件控制块 FCB 中保存的内容大致可以分为如下三类：</p><ul><li><strong>文件基本信息</strong>：文件名，用户名，文件地址，文件长度，文件逻辑结构，文件物理结构；</li><li><strong>存取控制信息</strong>：文件存取权限；</li><li><strong>管理信息</strong>：共享计数，文件的建立日期，保存期限，最后修改日期，最后访问日期。</li></ul><h2 id="41-目录结构"><a class="markdownIt-Anchor" href="#41-目录结构"></a> 4.1 目录结构</h2><p>目录中就是所有文件控制块 FCB 的集合，对 FCB 的管理应该满足如下要求：</p><ul><li><strong>效率</strong>：快速的定位一个文件；</li><li><strong>命名</strong>：方便用户，两个用户可以有相同名字的不同文件，相同的文件可以有不同的名字。</li></ul><p>下图就是最简单的单级目录结构，每个文件对应着一个 FCB 表项，在单级目录结构中，要找到一个文件则要遍历 FCB，而且由于是单级结构，不允许出现重命名，也不允许分组。：<br><img src="https://img-blog.csdnimg.cn/20200321155315972.png" alt="在这里插入图片描述" style="zoom:50%"><br>为解决一级目录文件命名冲突，并提高对目录文件检索速度而改进，可以把目录分为两级：</p><ul><li><strong>一级称为主文件目录（MFD）</strong>：给出用户名，用户子目录所在的物理位置；</li><li><strong>二级称为用户文件目录（UFD，又称用户子目录）</strong>：给出该用户所有文件的 FCB。</li></ul><p>这样在不同主文件目录下的不同文件可以重名，而且用户要查找文件只需要在自己的主目录下查找即可，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321155907353.png" alt="在这里插入图片描述" style="zoom:80%"><br>在二级目录结构下依然是无法分组的，为了解决这个问题引入了<strong>树型目录结构</strong>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321160037707.png" alt="在这里插入图片描述" style="zoom:80%"><br>在树形目录结构下，层次结构清晰，便于管理和保护，有利于文件分类，解决重名问题，提高文件检索速度。但查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。由于树形的叶子是不会重合的，所以不支持文件共享。</p><p>在有些系统中要求实现文件共享，这就引入了<strong>无环图结构目录</strong>，如下图所示，两个分支下的 <code>count</code> 都指向了同一个文件：<br><img src="https://img-blog.csdnimg.cn/20200321160345448.png" alt="在这里插入图片描述" style="zoom:80%"><br>在这种方式下，当某一方去修改这个文件时，如删除了这个文件，那么另一方指向这个文件的指针就是一个<strong>悬挂指针</strong>，解决方案有两种：</p><ul><li>设置一个断点来按期检查当前是否有悬挂指针，若有就删除悬挂指针；</li><li>通过表项保留计数来解决，文件的共享次数是通过一个计数器来实现的，当某一方删除这个文件的时候，我们并不删除这个文件，而是把这个计数器减一，当这个计数器为 <code>1</code> 时，这个文件就是一个独享文件，当这个计数器为 <code>0</code> 时，这个文件就真正的被删除了。</li></ul><p>在有的系统中要求文件可以指向目录，这就引入了普通图结构目录，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321160909319.png" alt="在这里插入图片描述" style="zoom:80%"><br>这种结构下就会出现环，当查找某个文件时就可能陷入某个环，保证无环的方式有如下几种：</p><ul><li>只允许链接到文件而不允许链接到子目录；</li><li>垃圾收集机制，定期检查是否有环；</li><li>每次添加一个链接时都用一个检测算法判断会不会产生环；</li></ul></div><div class="prev-or-next"><div class="post-foot-next"><a href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" target="_self"><i class="iconfont icon-chevronleft"></i> <span>上一页</span></a></div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-21 16:14:10 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"><b>#</b> 操作系统原理</a></span></span></div><div class="post-foot-prev"><a href="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8/" target="_self"><span>下一页</span> <i class="iconfont icon-chevronright"></i></a></div></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">1 文件概念及文件逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1.1 文件的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">1.2 文件的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.3 文件结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">2 文件访问方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96"><span class="toc-text">2.1 顺序存取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E7%9B%B4%E6%8E%A5%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96"><span class="toc-text">2.2 直接&#x2F;随机存取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="toc-text">2.3 文件的存储设备</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">3 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 顺序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E9%93%BE%E6%8E%A5%E7%BB%93%E6%9E%84"><span class="toc-text">3.2 链接结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">3.3 索引结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%9B%AE%E5%BD%95"><span class="toc-text">4 目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">4.1 目录结构</span></a></li></ol></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/syzdev"><i class="iconfont icon-github"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get();a.innerHTML="",r.addEventListener("input",(function(){var e='<ul class="search-result-list">',n=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach((function(t){var r=!0;t.title&&""!==t.title.trim()||(t.title="Untitled");var a=t.title.trim(),c=a.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),l=t.url,o=-1,u=-1,h=-1;if(""!==i?n.forEach((function(e,t){o=c.indexOf(e),u=i.indexOf(e),o<0&&u<0?r=!1:(u<0&&(u=0),0==t&&(h=u))})):r=!1,r){e+="<li><a href='"+l+"' class='search-result-title'>"+a+"</a>";var d=s;if(h>=0){var p=h-20,f=h+80;p<0&&(p=0),0==p&&(f=100),f>d.length&&(f=d.length);var m=d.substr(p,f);n.forEach((function(e){var t=new RegExp(e,"gi");m=m.replace(t,'<span class="search-keyword">'+e+"</span>")})),e+='<p class="search-result-abstract">'+m+"...</p>"}e+="</li>"}})),-1===(e+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=e}}))},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",(function(){$("#search-input").val(""),$("#search-result").html("")}))},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script></div></div></body></html>