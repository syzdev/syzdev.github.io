<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>TCP拥塞控制 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="TCP拥塞控制"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-07 23:49" pubdate>2020年3月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 37 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">TCP拥塞控制</h1><div class="markdown-body"><h1 id="1-拥塞概念"><a class="markdownIt-Anchor" href="#1-拥塞概念"></a> 1 拥塞概念</h1><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为<strong>拥塞 (congestion)</strong>，若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降，出现拥塞的原因是 ∑ 对资源需求 &gt; 可用资源，这里的资源包括很多方面，比如路由器的缓存、路由器的处理速度、通信线路的容量等等。拥塞的现象和堵车的现象有点相似，比如出现堵车有一个原因就是道路不够宽，我们红绿灯的交替速度不够快等等诸多方面元素。</p><p>既然拥塞是因为可用资源不足，那么增加资源是否可以解决拥塞现象？答案是不可以，这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏，如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，会进一步的加剧拥塞，解决不了网络拥塞，如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组，但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要車传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃，如提高处理机处理的速率会将瓶颈转移到其他地方，只提高某一方面是不可能提高整体效率的，即限制堵车的办法不是多修路，而是限制车到路上。</p><p>拥塞控制与流量控制的区别是拥塞控制对全局的每一个发送端进行控制，而流量控制对单一的发送端进行控制。<br><img src="https://img-blog.csdnimg.cn/20200307205309190.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="2-拥塞控制的一般原理"><a class="markdownIt-Anchor" href="#2-拥塞控制的一般原理"></a> 2 拥塞控制的一般原理</h1><p>对理想的拥塞控制在达到资源上限之前，网络的吞吐量是平稳上升的，而达到最高点之后，整个网络的吞吐量可在最高点延续，这个时候哪怕有更多的分组注入网络，也能够以最高的吞吐量进行发送和接收数据，实际的拥塞控制不可能达到理想拥塞控制的效果，随着注入网络的分组增加，吞吐量会逐渐增加，但达不到上限；</p><img src="https://img-blog.csdnimg.cn/20200307215643248.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><p>在设计拥塞算法时，由于拥塞都是动态的，每一时刻的可用资源和需求资源都是动态变化的，所以无法明确的确定一个边界，由于拥塞控制是一个全局问题，而发送方的一点无法获取到全局的网络状况，所以这使得拥塞控制的设计极为复杂。</p><p>在设计拥塞控制算法时，有两类控制方法：</p><ol><li><strong>开环控制</strong>：事先将有关发生拥塞的因素都考虑周到，力求在网络工作的时候不发生拥塞，这需要全面的考虑到各方面原因并以参数的形式将其设计到算法中来；</li><li><strong>闭环控制</strong>：监测网络系统，以便检测到拥塞在何时、何处发生，将拥塞发生的信息传送到可采取行动的地方，通常是发送方或中间路由器，调整网络系统的运行以解决出现的问题，比如可以限制发送方发送报文的速度，通常闭环控制是最常用的控制方式。</li></ol><p>两种方式的区别如下：<br><img src="https://img-blog.csdnimg.cn/20200307221326690.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="3-拥塞控制的方法"><a class="markdownIt-Anchor" href="#3-拥塞控制的方法"></a> 3 拥塞控制的方法</h1><p>TCP 采用基于<strong>窗口</strong>的方法进行拥塞控制。该方法属于闭环控制方法，TCP 发送方维持一个<strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span></strong> (Congestion Window)，发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量，发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<code>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</code>。</p><p>控制拥塞窗口的原则是只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率，但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><p>当前是否出现拥塞有两种判断方法：</p><ul><li><strong>重传定时器超时</strong>：现在通信线路的传输质量一般都很好，因传输岀差错而丟弃分组的概率是很小的（远小于1%）。只要出现了超时，就可以猜想网络可能出现了拥塞；</li><li><strong>收到三个相同（重复）的ACK</strong>：个别报文段会在网络中丢失，预示可能会出现拥塞（也可能未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</li></ul><p>TCP拥塞控制算法分为四种，分别用于数据传输的不同阶段：</p><ol><li><strong>慢开始 (slow-start)；</strong></li><li><strong>拥塞避免 (congestion avoidance)；</strong></li><li><strong>快重传 (fast retransmit)；</strong></li><li><strong>快恢复 (fast recovery)。</strong></li></ol><h2 id="31-慢开始-slow-start"><a class="markdownIt-Anchor" href="#31-慢开始-slow-start"></a> 3.1 慢开始 (Slow start)</h2><ul><li><strong>目的</strong>：用来确定网络的负载能力或拥塞程度；</li><li><strong>算法的思路</strong>：由小到大逐渐增大拥塞窗口数值；</li><li><strong>初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置</strong>：旧的规定在刚刚开始发送报文段时，先把初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 个发送方的最大报文段 SMSS（ Sender Maximum Segment Size）的数值，新的 RFC5681 把初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置为不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span> 个SMSS 的数值；</li><li><strong>慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span>（状态变量）</strong>：防止拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 增长过大引起网络拥塞，当我们发送的报文段数量达到慢开始门限后，就会从慢开始阶段转换为<strong>拥塞避免</strong>阶段。</li></ul><blockquote><p><strong>慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 的用法如下</strong>：</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &lt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.73354em;vertical-align:-.0391em"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，使用慢开始算法；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &gt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.73354em;vertical-align:-.0391em"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，停止使用慢开始算法而改用拥塞避免算法；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></blockquote><ul><li><strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 控制方法</strong>：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">S</span></span></span></span> 的数值，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 每次的增加量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= min (N, SMSS)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mclose">)</span></span></span></span>，即在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">S</span></span></span></span> 之中取一个最小值，其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数，不难看出，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>&lt;</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">N &lt; SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72243em;vertical-align:-.0391em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">S</span></span></span></span> 时，拥塞窗口每次的增加量要小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault" style="margin-right:.05764em">S</span><span class="mord mathdefault" style="margin-right:.05764em">S</span></span></span></span>。用这样的方法逐步增大发送方的拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>，可以使分组注入到网络的速率更加合理。<br><img src="https://img-blog.csdnimg.cn/20200307225634244.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li></ul><blockquote><p><strong>传输轮次</strong>：使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 就加倍，一个传输轮次所经历的时间其实就是往返时间 RTT，“传输轮次”更加强调把拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认，例如，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">cwnd = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>，这时的往返时间 RTT 就是发送方连续发送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span> 个报文段，并收到这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span> 个报文段的确认，总共经历的时间。</p></blockquote><h2 id="32-拥塞避免算法"><a class="markdownIt-Anchor" href="#32-拥塞避免算法"></a> 3.2 拥塞避免算法</h2><p>首先要提出一点，拥塞避免算法并不是完全避免拥塞，而是让拥塞来的更慢一些。其思路是让拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 缓慢地增大，即毎经过一个往返时间 RTT 就把发送方的<strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> ，而不是加倍</strong>，使拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 按<strong>线性规律缓慢增长</strong>，因此在拥塞避免阶段就有“<strong>加法增大</strong>”（ Additive Increase）的特点。这表明在拥塞避免阶段，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 按线性规律缓慢增长，比慢开始算法的拥基窗口增长速率缓馒得多。</p><p>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（<strong>重传定时器超时</strong>），则要减少慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ssthresh = max (cwnd/2,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，再初始化拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，执行慢开始算法，也就是说当进入了拥塞状态，会重新调整 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 大小并重新进入慢开始阶段，其目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。慢开始和拥塞避免算法的实现举例如下：<br><img src="https://img-blog.csdnimg.cn/20200307231451337.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><ol><li>在执行慢开始算法时，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，发送第一个报文段；</li><li>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 随着传输轮次按指数规律增长；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 增长到慢开始门限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时（图中的点❶ ，此时拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">cwnd = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> ），就改为执行拥塞避免算法，拥塞窗口按线性规律增长；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">cwnd = 24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 时，网络出现了超时（图中的点❷ ），发送方判断为网络拥塞。于是调整门限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">ssthresh = cwnd / 2 = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>，同时设置拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，进入慢开始阶段；</li><li>按照慢开始算法，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">cwnd = ssthresh = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 时（图中的点❸，这是新的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 值），改为执行拥塞避免算法，拥塞窗口按线性规律增大；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">cwnd = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 时（图中的点❹），出现了一个新的情况，就是发送方一连收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 个对同一个报文段的重复确认（图中记为 3-ACK）。发送方改为执行<strong>快重传</strong>和<strong>快恢复</strong>算法。</li></ol><p><strong>需要注意的是：</strong></p><ul><li>“拥塞避免”并非指完全能够避免了拥塞，利用以上的措施要完全避免网络拥塞还是不可能的；</li><li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h2 id="33-快重传算法"><a class="markdownIt-Anchor" href="#33-快重传算法"></a> 3.3 快重传算法</h2><p>快重传和快恢复的目的，是为了<strong>防止因为报文段丢失重新进入到慢启动的过程</strong>，通过收到 3-ACK（接收 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 次对同一报文的确认）判断，发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞，采用快重传 FR (Fast Retransmission) 算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>，快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认，快重传举例如下。</p><p>发送方发送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 时传输过程中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 丢失，但是接收方接收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">M_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 报文段，那么接收方必须对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进行重复的确认，当发送方接收到连续 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 个对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的确认后，发送方就知道了接收方没有接收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，应当立即重传 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，这也就是<strong>快重传</strong>的由来，这样也不会出现超时，发送方也不会认为这是网络拥塞。</p><img src="https://img-blog.csdnimg.cn/20200307233507221.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><h2 id="34-快恢复算法"><a class="markdownIt-Anchor" href="#34-快恢复算法"></a> 3.4 快恢复算法</h2><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行<strong>快恢复</strong>算法 FR (Fast Recovery) 算法，减小慢开始门限 $ssthresh = cwnd / 2 $，设置新拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> ，开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。<br><img src="https://img-blog.csdnimg.cn/20200307234259997.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><h2 id="35-加法增大乘法减小-aimd"><a class="markdownIt-Anchor" href="#35-加法增大乘法减小-aimd"></a> 3.5 加法增大，乘法减小 (AIMD)</h2><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“<strong>加法增大</strong>” AI (Additive Increase)，当出现超时或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span> 个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“<strong>乘法减小</strong>”MD (Multiplicative Decrease)，二者合在一起就是所谓的 AIMD 算法。</p><h2 id="36-拥塞控制流程图"><a class="markdownIt-Anchor" href="#36-拥塞控制流程图"></a> 3.6 拥塞控制流程图</h2><img src="https://img-blog.csdnimg.cn/20200307234633536.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><h2 id="37-发送窗口的上限值"><a class="markdownIt-Anchor" href="#37-发送窗口的上限值"></a> 3.7 发送窗口的上限值</h2><p>发送方的发送窗口的上限值应当取为接收方窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 和拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 这两个变量中较小的一个，即应按以下公式确定：发送窗口的上限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= Min ( rwnd, cwnd )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10903em">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>；</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd &lt; cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.73354em;vertical-align:-.0391em"></span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，是接收方的接收能力限制发送窗口的最大值；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd &lt; rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.73354em;vertical-align:-.0391em"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，则是网络的拥塞限制发送窗口的最大值；</li></ul><p>也就是说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 中数值较小的一个，控制了发送方发送数据的速率。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/08/TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">TCP运输连接管理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE/"><span class="hidden-mobile">TCP协议</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>