<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content=""><meta name="author" content="syz"><meta name="description" content=""><title>TCP拥塞控制 | syzdev</title><link rel="apple-touch-icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/color-scheme.css"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/comments.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script defer type="text/javascript" src="/plugins/jquery.min.js"></script><link href="/plugins/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">syzdev</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/about/"><a href="/about/">关于</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="/plugins/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">TCP拥塞控制</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-07 23:49:09 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><b>#</b> 计算机网络</a></span></span></div><div class="markdown-body"><h1 id="1-拥塞概念"><a class="markdownIt-Anchor" href="#1-拥塞概念"></a> 1 拥塞概念</h1><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为<strong>拥塞 (congestion)</strong>，若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降，出现拥塞的原因是 ∑ 对资源需求 &gt; 可用资源，这里的资源包括很多方面，比如路由器的缓存、路由器的处理速度、通信线路的容量等等。拥塞的现象和堵车的现象有点相似，比如出现堵车有一个原因就是道路不够宽，我们红绿灯的交替速度不够快等等诸多方面元素。</p><p>既然拥塞是因为可用资源不足，那么增加资源是否可以解决拥塞现象？答案是不可以，这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏，如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，会进一步的加剧拥塞，解决不了网络拥塞，如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组，但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要車传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃，如提高处理机处理的速率会将瓶颈转移到其他地方，只提高某一方面是不可能提高整体效率的，即限制堵车的办法不是多修路，而是限制车到路上。</p><p>拥塞控制与流量控制的区别是拥塞控制对全局的每一个发送端进行控制，而流量控制对单一的发送端进行控制。<br><img src="https://img-blog.csdnimg.cn/20200307205309190.png" alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="2-拥塞控制的一般原理"><a class="markdownIt-Anchor" href="#2-拥塞控制的一般原理"></a> 2 拥塞控制的一般原理</h1><p>对理想的拥塞控制在达到资源上限之前，网络的吞吐量是平稳上升的，而达到最高点之后，整个网络的吞吐量可在最高点延续，这个时候哪怕有更多的分组注入网络，也能够以最高的吞吐量进行发送和接收数据，实际的拥塞控制不可能达到理想拥塞控制的效果，随着注入网络的分组增加，吞吐量会逐渐增加，但达不到上限；</p><img src="https://img-blog.csdnimg.cn/20200307215643248.png" alt="在这里插入图片描述"><p>在设计拥塞算法时，由于拥塞都是动态的，每一时刻的可用资源和需求资源都是动态变化的，所以无法明确的确定一个边界，由于拥塞控制是一个全局问题，而发送方的一点无法获取到全局的网络状况，所以这使得拥塞控制的设计极为复杂。</p><p>在设计拥塞控制算法时，有两类控制方法：</p><ol><li><strong>开环控制</strong>：事先将有关发生拥塞的因素都考虑周到，力求在网络工作的时候不发生拥塞，这需要全面的考虑到各方面原因并以参数的形式将其设计到算法中来；</li><li><strong>闭环控制</strong>：监测网络系统，以便检测到拥塞在何时、何处发生，将拥塞发生的信息传送到可采取行动的地方，通常是发送方或中间路由器，调整网络系统的运行以解决出现的问题，比如可以限制发送方发送报文的速度，通常闭环控制是最常用的控制方式。</li></ol><p>两种方式的区别如下：<br><img src="https://img-blog.csdnimg.cn/20200307221326690.png" alt="在这里插入图片描述" style="zoom:50%"></p><h1 id="3-拥塞控制的方法"><a class="markdownIt-Anchor" href="#3-拥塞控制的方法"></a> 3 拥塞控制的方法</h1><p>TCP 采用基于<strong>窗口</strong>的方法进行拥塞控制。该方法属于闭环控制方法，TCP 发送方维持一个**拥塞窗口 cwnd ** (Congestion Window)，发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量，发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<code>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</code>。</p><p>控制拥塞窗口的原则是只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率，但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><p>当前是否出现拥塞有两种判断方法：</p><ul><li><strong>重传定时器超时</strong>：现在通信线路的传输质量一般都很好，因传输岀差错而丟弃分组的概率是很小的（远小于1%）。只要出现了超时，就可以猜想网络可能出现了拥塞；</li><li><strong>收到三个相同（重复）的ACK</strong>：个别报文段会在网络中丢失，预示可能会出现拥塞（也可能未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</li></ul><p>TCP拥塞控制算法分为四种，分别用于数据传输的不同阶段：</p><ol><li><strong>慢开始 (slow-start)；</strong></li><li><strong>拥塞避免 (congestion avoidance)；</strong></li><li><strong>快重传 (fast retransmit)；</strong></li><li><strong>快恢复 (fast recovery)。</strong></li></ol><h2 id="31-慢开始-slow-start"><a class="markdownIt-Anchor" href="#31-慢开始-slow-start"></a> 3.1 慢开始 (Slow start)</h2><ul><li><strong>目的</strong>：用来确定网络的负载能力或拥塞程度；</li><li><strong>算法的思路</strong>：由小到大逐渐增大拥塞窗口数值；</li><li><strong>初始拥塞窗口 cwnd 设置</strong>：旧的规定在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS（ Sender Maximum Segment Size）的数值，新的 RFC5681 把初始拥塞窗口 cwnd 设置为不超过 2 至 4 个SMSS 的数值；</li><li><strong>慢开始门限 ssthresh （状态变量）</strong>：防止拥塞窗口 cwnd 增长过大引起网络拥塞，当我们发送的报文段数量达到慢开始门限后，就会从慢开始阶段转换为<strong>拥塞避免</strong>阶段。</li></ul><blockquote><p><strong>慢开始门限 ssthresh 的用法如下</strong>：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法；</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法；</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></blockquote><ul><li><strong>拥塞窗口 cwnd 控制方法</strong>：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值，拥塞窗口 cwnd 每次的增加量 = min (N, SMSS) ，即在 N 和 SMSS 之中取一个最小值，其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数，不难看出，当 N &lt; SMSS 时，拥塞窗口每次的增加量要小于 SMSS 。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。<br><img src="https://img-blog.csdnimg.cn/20200307225634244.png" alt="在这里插入图片描述"></li></ul><blockquote><p><strong>传输轮次</strong>：使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍，一个传输轮次所经历的时间其实就是往返时间 RTT，“传输轮次”更加强调把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认，例如，拥塞窗口 cwnd = 4 ，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</p></blockquote><h2 id="32-拥塞避免算法"><a class="markdownIt-Anchor" href="#32-拥塞避免算法"></a> 3.2 拥塞避免算法</h2><p>首先要提出一点，拥塞避免算法并不是完全避免拥塞，而是让拥塞来的更慢一些。其思路是让拥塞窗口 cwnd 缓慢地增大，即毎经过一个往返时间 RTT 就把发送方的<strong>拥塞窗口 cwnd 加 1 ，而不是加倍</strong>，使拥塞窗口 cwnd 按<strong>线性规律缓慢增长</strong>，因此在拥塞避免阶段就有“<strong>加法增大</strong>”（ Additive Increase）的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥基窗口增长速率缓馒得多。</p><p>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（<strong>重传定时器超时</strong>），则要减少慢开始门限 ssthresh = max (cwnd/2,2) ，再初始化拥塞窗口 cwnd = 1 ，执行慢开始算法，也就是说当进入了拥塞状态，会重新调整 ssthresh 和 cwnd 大小并重新进入慢开始阶段，其目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。慢开始和拥塞避免算法的实现举例如下：<br><img src="https://img-blog.csdnimg.cn/20200307231451337.png" alt="在这里插入图片描述"></p><ol><li>在执行慢开始算法时，拥塞窗口 cwnd=1 ，发送第一个报文段；</li><li>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1 ，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长；</li><li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（图中的点❶ ，此时拥塞窗口 cwnd = 16 ），就改为执行拥塞避免算法，拥塞窗口按线性规律增长；</li><li>当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点❷ ），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12 ，同时设置拥塞窗口 cwnd = 1 ，进入慢开始阶段；</li><li>按照慢开始算法，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1 当拥塞窗口 cwnd = ssthresh = 12 时（图中的点❸，这是新的 ssthresh 值），改为执行拥塞避免算法，拥塞窗口按线性规律增大；</li><li>当拥塞窗口 cwnd = 16 时（图中的点❹），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为 3-ACK）。发送方改为执行<strong>快重传</strong>和<strong>快恢复</strong>算法。</li></ol><p><strong>需要注意的是：</strong></p><ul><li>“拥塞避免”并非指完全能够避免了拥塞，利用以上的措施要完全避免网络拥塞还是不可能的；</li><li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h2 id="33-快重传算法"><a class="markdownIt-Anchor" href="#33-快重传算法"></a> 3.3 快重传算法</h2><p>快重传和快恢复的目的，是为了<strong>防止因为报文段丢失重新进入到慢启动的过程</strong>，通过收到 3-ACK（接收 3 次对同一报文的确认）判断，发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞，采用快重传 FR (Fast Retransmission) 算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>，快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认，快重传举例如下。</p><p>发送方发送 M_3 时传输过程中 M_3 丢失，但是接收方接收到了 M_4 报文段，那么接收方必须对 M_2 进行重复的确认，当发送方接收到连续 3 个对 M_2 的确认后，发送方就知道了接收方没有接收到 M_3 ，应当立即重传 M_3 ，这也就是<strong>快重传</strong>的由来，这样也不会出现超时，发送方也不会认为这是网络拥塞。</p><img src="https://img-blog.csdnimg.cn/20200307233507221.png" alt="在这里插入图片描述"><h2 id="34-快恢复算法"><a class="markdownIt-Anchor" href="#34-快恢复算法"></a> 3.4 快恢复算法</h2><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行<strong>快恢复</strong>算法 FR (Fast Recovery) 算法，减小慢开始门限 ssthresh = cwnd / 2 ，设置新拥塞窗口 cwnd = ssthresh ，开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。<br><img src="https://img-blog.csdnimg.cn/20200307234259997.png" alt="在这里插入图片描述"></p><h2 id="35-加法增大乘法减小-aimd"><a class="markdownIt-Anchor" href="#35-加法增大乘法减小-aimd"></a> 3.5 加法增大，乘法减小 (AIMD)</h2><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“<strong>加法增大</strong>” AI (Additive Increase)，当出现超时或 3 个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“<strong>乘法减小</strong>”MD (Multiplicative Decrease)，二者合在一起就是所谓的 AIMD 算法。</p><h2 id="36-拥塞控制流程图"><a class="markdownIt-Anchor" href="#36-拥塞控制流程图"></a> 3.6 拥塞控制流程图</h2><img src="https://img-blog.csdnimg.cn/20200307234633536.png" alt="在这里插入图片描述"><h2 id="37-发送窗口的上限值"><a class="markdownIt-Anchor" href="#37-发送窗口的上限值"></a> 3.7 发送窗口的上限值</h2><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：发送窗口的上限值 = Min ( rwnd, cwnd ) ；</p><ul><li>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值；</li><li>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值；</li></ul><p>也就是说， rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</p></div><div class="prev-or-next"><div class="post-foot-next"><a href="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE/" target="_self"><i class="iconfont icon-chevronleft"></i> <span>上一页</span></a></div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-07 23:49:09 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><b>#</b> 计算机网络</a></span></span></div><div class="post-foot-prev"><a href="/2020/03/08/TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/" target="_self"><span>下一页</span> <i class="iconfont icon-chevronright"></i></a></div></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8B%A5%E5%A1%9E%E6%A6%82%E5%BF%B5"><span class="toc-text">1 拥塞概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="toc-text">2 拥塞控制的一般原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3 拥塞控制的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%85%A2%E5%BC%80%E5%A7%8B-slow-start"><span class="toc-text">3.1 慢开始 (Slow start)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">3.2 拥塞避免算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-text">3.3 快重传算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95"><span class="toc-text">3.4 快恢复算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%8A%A0%E6%B3%95%E5%A2%9E%E5%A4%A7%E4%B9%98%E6%B3%95%E5%87%8F%E5%B0%8F-aimd"><span class="toc-text">3.5 加法增大，乘法减小 (AIMD)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">3.6 拥塞控制流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%8A%E9%99%90%E5%80%BC"><span class="toc-text">3.7 发送窗口的上限值</span></a></li></ol></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/syzdev"><i class="iconfont icon-github"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get();a.innerHTML="",r.addEventListener("input",(function(){var e='<ul class="search-result-list">',n=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach((function(t){var r=!0;t.title&&""!==t.title.trim()||(t.title="Untitled");var a=t.title.trim(),c=a.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),l=t.url,o=-1,u=-1,h=-1;if(""!==i?n.forEach((function(e,t){o=c.indexOf(e),u=i.indexOf(e),o<0&&u<0?r=!1:(u<0&&(u=0),0==t&&(h=u))})):r=!1,r){e+="<li><a href='"+l+"' class='search-result-title'>"+a+"</a>";var d=s;if(h>=0){var p=h-20,f=h+80;p<0&&(p=0),0==p&&(f=100),f>d.length&&(f=d.length);var m=d.substr(p,f);n.forEach((function(e){var t=new RegExp(e,"gi");m=m.replace(t,'<span class="search-keyword">'+e+"</span>")})),e+='<p class="search-result-abstract">'+m+"...</p>"}e+="</li>"}})),-1===(e+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=e}}))},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",(function(){$("#search-input").val(""),$("#search-result").html("")}))},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script></div></div></body></html>