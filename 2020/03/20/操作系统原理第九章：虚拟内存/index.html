<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>操作系统原理第九章：虚拟内存 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="操作系统原理第九章：虚拟内存"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-20 23:08" pubdate>2020年3月20日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 50 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统原理第九章：虚拟内存</h1><div class="markdown-body"><h1 id="1-虚拟内存的背景"><a class="markdownIt-Anchor" href="#1-虚拟内存的背景"></a> 1 虚拟内存的背景</h1><p>无论是分页还是分段，程序运行的基本要求就是必须全部放入内存后方可运行，如果进程大于内存的容量或者内存中同时运行多个进程，那么进程就无法执行了，解决这个问题有两种方法，即覆盖和动态加载，但是这两种工作都是由程序员手动来做而且实现很复杂。</p><p>上面的问题究其本质就是内存不够用了，那么很容易想到的就是扩充内存，可以从物理上扩充内存容量，但是是受限的，如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位操作系统支持的内存最大为 <code>4GB</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 位操作系统支持的内存最大为 <code>128GB</code>，并且购买内存也较为昂贵。那么是否可以从逻辑上扩充内存容量呢？答案是可以的，本文内容就是讲解如何从逻辑上扩充内存。</p><p>常规的存储方式具有如下特征：</p><ul><li><strong>一次性</strong>：作业在运行前需要一次性的全部装入内存；</li><li><strong>驻留性</strong>：作业装入内存后，便一直驻留在内存中，直到作业结束。</li></ul><p>正是由于一次性和驻留性，使得程序中暂时不用的数据占用了大量的内存空间，从而需要运行的作业无法装入内存。那么一次性和驻留性是必需的吗？人们对程序做了很多的研究发现程序在执行过程中其实不是要运行所有部分：</p><ul><li>程序通常有处理异常错误的代码，很少执行；</li><li>数组、链表等数据结构通常分配了比实际需要更多的内存；</li><li>程序的某些选项或特点可能很少使用；</li><li>即使需要完整的程序，也并不是同时需要所有的程序。</li></ul><p>通过上述四个特点，我们可以发现程序运行时往往只运行了一部分，这个特点我们叫做<strong>局部性原理</strong>。</p><h2 id="11-局部性原理"><a class="markdownIt-Anchor" href="#11-局部性原理"></a> 1.1 局部性原理</h2><p>局部性原理的定义是在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。出现局部性原理有如下原因：</p><ul><li>程序在执行时，除了少部分的转移和过程调用指令外，大多数仍是顺序执行的；</li><li>子程序调用将会使程序的执行由一部分内存区域转至另一部分区域，也就是说程序只是从一个局部跳跃到另一个局部而已；</li><li>程序中存在许多循环结构，循环体中的指令被多次执行；</li><li>程序中还包括许多对数据结构的处理，如对连续的存储空间数组的访问，往往局限于很小的范围内。</li></ul><p>因此我们说程序是具有局部性的，局部性主要体现在两个方面：</p><ul><li><strong>时间局部性</strong>： 如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问；产生时间局限性的典型原因是在程序中存在着大量的循环操作；</li><li><strong>空间局部性</strong>： 一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是顺序执行的。</li></ul><h2 id="12-虚拟内存"><a class="markdownIt-Anchor" href="#12-虚拟内存"></a> 1.2 虚拟内存</h2><p>虚拟内存是一种允许进程<strong>部分装入内存</strong>就可以执行的技术，它基于的原理就是局部性原理，因为程序具有局部性，所以只需要把当前需要执行的程序内容装入内存即可，这个时候用户看到的逻辑地址空间就比物理地址空间大，要实现这个功能就必须允许页面能够被换入和换出。</p><p>如下图，虚拟内存 <code>virtual memory</code> 显然是比实际内存 <code>physical memory</code> 大的，只需要把当前要执行的部分装入内存即可；用 <code>memory map</code> 来映射当前哪些部分是要装入内存的，类似页表，当运行到某个位置的时候就可以查询它在内存还是在外存；当要运行新的程序时或当前内存不足时就要和外存进行页面的换入和换出：<br><img src="https://img-blog.csdnimg.cn/2020032021021692.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>虚拟内存具有如下特征：</p><ul><li><strong>离散性</strong>：在内存分配时采用离散的分配方式，是虚拟存储器的最基本的特征；</li><li><strong>多次性</strong>：一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可，是虚拟存储器最重要的特征；</li><li><strong>对换性</strong>：作业运行过程中信息在内存和外存的对换区之间换进、换出；</li><li><strong>虚拟性</strong>：从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul><h1 id="2-请求调页"><a class="markdownIt-Anchor" href="#2-请求调页"></a> 2 请求调页</h1><p>实现虚拟存储器要解决以下三个问题 ：</p><ul><li><strong>程序部分运行可以吗?</strong> 是可以的，依照程序局部性原理，取出要用的页，然后装入内存即可；</li><li><strong>发现程序不在内存时，如何将其装入后继续运行?</strong> 用请求调页技术，当发生缺页时，产生缺页中断，将外存上的页调入内存；</li><li><strong>内存无空间时怎么办?</strong> 用页面置换，将部分页面换出内存。</li></ul><h2 id="21-页面调入策略"><a class="markdownIt-Anchor" href="#21-页面调入策略"></a> 2.1 页面调入策略</h2><p>为能使进程运行，事先需将一部分要执行的程序和数据调入内存，有两种调页的策略：</p><ul><li><strong>预调页策略</strong>：主动的页面调入策略，即把那些预计很快会被访问的程序或数据所在的页面，预先调入内存；这个策略的性能取决于预测的准确率，预测的准确率不高（50%），主要用于进程的首次调入。也有的系统将预调页策略用于请求调页。</li><li><strong>请求调页策略</strong>：当进程在运行中发生缺页时，由系统将缺页调入内存；目前虚拟存储器系统大多采用此策略；但在调页时须花费较大的系统开销，如需频繁启动磁盘 I/O。</li></ul><p>请求调页只有在一个页需要的时候才把它换入内存，这是请求调页的好处，或者说是虚拟内存的好处。它需要很少的 I/O，需要很少的内存，能够快速响应，并且可以支持多用户。当需要某个页的时候判断它是否在内存中是需要进行查阅的，通常存在一个 <code>bit</code> 位表示它是不是在内存，若不在内存中就要调入内存。</p><p>在具体实现的时候需要对进程页表进行修改，也需要缺页中断的支持。请求分页的页表机制是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入内存，还有一部分仍在磁盘上，故需在页表中再增加若干项，供程序(数据) 在换进、换出时参考。在请求分页系统中的每个页表项如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320211913969.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>其中增加的各字段说明如下：</p><ul><li><strong>状态位 (存在位P)</strong> ：用于指示该页是否已调入内存，供程序访问时参考；</li><li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考；</li><li><strong>修改位M</strong>：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本；</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。</li></ul><p>完成页面调页还需要缺页中断机构的支持，在请求分页系统中，每当所要访问的页面不在内存时，便要产生一个缺页中断，请求操作系统将所缺页调入内存。与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号；</li><li>缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行；</li><li>一条指令在执行期间，可能产生多次缺页中断；</li></ul><p>下图是缺页中断的处理过程，现在要加载一个程序 <code>M</code>，❶首先要查询页表，发现该页在页表中是 <code>i</code> (invalid)，表示不在内存，❷这个时候就产生一个缺页中断，❸操作系统就会根据在页表中指向的外存的地址找到它，❹随后从外存放入内存，放入的时候要找一个空闲页，一旦放进去了以后，❺页表就要更新，此时中断就结束了，❻接着就要返回到这个程序重新执行：<br><img src="https://img-blog.csdnimg.cn/20200320213158407.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>上面整个过程主要是执行以下三个操作：</p><ul><li>处理缺页中断；</li><li>从磁盘读入所需的页；</li><li>重新开始被中断的进程。</li></ul><p>其中最大的一部分时间开销为第二步，即从磁盘读入所需的页，因此我们希望减少读入的次数，也就是降低<strong>缺页率</strong>。</p><blockquote><p><strong>缺页率</strong> = 访问内存次数 / 不成功访问次数</p></blockquote><h1 id="3-页面置换"><a class="markdownIt-Anchor" href="#3-页面置换"></a> 3 页面置换</h1><p>随着装入内存的程序越来越多，内存可能会有装满的情况，这个时候如果来了新的程序想要进入内存，就必须执行页面置换，将内存中暂不使用的程序先从内存调出到外存。</p><p>如下图的两个用户程序，其中用户程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 需要载入程序 <code>M</code>，用户程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 需要载入程序 <code>B</code>，而此时 <code>M</code> 载入到内存后，内存已经满了，程序 <code>B</code> 再要装入内存已经没有位置了，所以此时要将现在内存中的某个程序置换出去。<br><img src="https://img-blog.csdnimg.cn/20200320214456438.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>现在置换有如下几种方法：</p><ul><li><strong>终止用户进程</strong>：一旦终止用户进程，进程就会释放内存空间，那么内存就腾出位置来了，这种方法的代价是比较大的；</li><li><strong>交换进程</strong>：中级调度，释放其所有帧，降低多道程序的度，这种方法的代价也是比较大的，因为是以整个进程为单位，进行的 I/O 操作开销较大；</li><li><strong>页面置换</strong>：以页为单位做交换，这种方法的开销相比是最小的。</li></ul><p>页面置换的执行步骤如下：</p><ul><li>找到页面在磁盘中的位置，找到之后便要把它读入内存，就要找到一个空闲的帧；</li><li>若有空闲的帧遍可以直接装入，若没有空闲的帧就要选择一个页调换出去，同时修改页表，再把页面装入内存；</li></ul><p>页面置换过程如下图所示，❶牺牲当前内存中的某个页， 置换到外存上，❷修改页表标志位，❸将页面置换进内存中，❹更新页表：<br><img src="https://img-blog.csdnimg.cn/20200320215253300.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>可以发现在页面置换过程中，需要两个页面传输，一个换出，一个换入。但是有时候只需要一次置换就可以，因为有些程序在内存中并没有被修改过，所以它不需要换到外存去更新数据，只用牺牲它，将新调入的程序覆盖它即可，这里用到的方法就是前面提到的<strong>修改位</strong>。</p><p>页面置换的总的流程图如下图所示，图中的快表指的是联想寄存器：<br><img src="https://img-blog.csdnimg.cn/20200320215930991.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:63%"></p><h1 id="4-页面置换算法"><a class="markdownIt-Anchor" href="#4-页面置换算法"></a> 4 页面置换算法</h1><p>在进程运行过程中，如果发生缺页， 而内存中又无空闲块时可以将内存中的某一页换到磁盘的对换区。那么到底选择调出哪一个页，可以根据页面置换算法来确定，置换算法的好坏将直接影响系统的性能，不适当的算法可能会导致进程发生 <strong>“抖动” (Thrashing)</strong> 。</p><blockquote><p><strong>抖动 (Thrashing)</strong>：如果进程分配到的帧数量小于计算机体系结构所要求的最小数量，那么必须暂停进行执行，并将其置换出去，使其所有分配帧空闲。这么做的原因就是如果进程没有这些必需的帧，那么很快会出现缺页，此时需置换某个页，然而，其所有页都在使用，置换出去的页立刻又需要置换进来，因此，会不断的产生缺页。这种频繁的调页行为称作<strong>抖动 (Thrashing)</strong>，也叫颠簸。</p></blockquote><p>页面置换最大的问题就是到底换哪一个页，若换出的某个页很快就又要用到又要换进来，这样的效率是很低的，所以我们希望我们换出的页是今后很长一段时间内不再用到的页，这样就能降低系统的缺页率，我们来衡量一个页面置换算法的好坏主要是通过缺页率的大小，从理论上讲 ， 应将那些以后不再被访问的页面换出，或把那些在较长时间内不会再被访问的页面换出，在实际的过程中有很多的置换算法能够接近理论目标，为什么说是理论上的，因为我们人是不知道哪些页面是要换的。</p><p>我们通过运行一个内存访问的特殊序列（访问序列），计算这个序列的缺页次数来评估算法。这个序列我们假定为 <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code>，后面讨论算法时都会用到这个序列。</p><h2 id="41-最佳算法opt"><a class="markdownIt-Anchor" href="#41-最佳算法opt"></a> 4.1 最佳算法（OPT）</h2><p>最佳算法中被置换的页将是之后最长时间不被使用的页，其置换过程如下：<br><img src="https://img-blog.csdnimg.cn/20200320222211375.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>。这个算法的缺点就是在实际过程中，我们并不知道这个内存访问序列，尤其是在多道批处理系统中，更是无法预测，所以最佳算法只是理论上最优的算法，现实中是无法实现的，我们通常用它来衡量其他算法的性能。</p><h2 id="42-先进先出置换算法fifo"><a class="markdownIt-Anchor" href="#42-先进先出置换算法fifo"></a> 4.2 先进先出置换算法（FIFO）</h2><p>先进先出置换算法中是按照内存先来先得，先进来的先出去这种方式来选择置换的页，其置换过程如下：<br><img src="https://img-blog.csdnimg.cn/20200320222913283.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>。这个算法的性能几乎是比最佳算法差了一倍了，导致性能不好的原因是刚刚换出去的页，很可能又要被换进来，于是增加了缺页率，因此有了下面第三种置换算法。</p><h2 id="43-最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#43-最近最久未使用置换算法lru"></a> 4.3 最近最久未使用置换算法（LRU）</h2><p>虽然并不知道页面未来的使用情况，但是可以使用离过去最近的情况作为不远将来的近似，可以选择最近最少使用的页进行置换，其置换过程如下：<br><img src="https://img-blog.csdnimg.cn/20200320223500637.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span>。这个算法的性能显然比先进先出置换算法要好，但是实现 LRU 算法需要硬件支持，记录物理页的使用情况。</p><blockquote><p>实际上可能没有足够的硬件支持，所以就有了 LRU 的近似算法，如基于访问位的算法，二次机会算法。</p><ul><li><strong>访问位算法</strong>：每个页都与一个位相关联，初始值为 <code>0</code>，每当这个页被访问的时候就把这个页置位 <code>1</code>，所以在选择置换的页时就可以看这个访问位，看谁是未被访问过的。但是这个算法有不足的地方就在于我们并不知道这个置换顺序，因为有可能有的页时很久都没有使用过的，有的页只是最近未被使用过的，理论上来说很久未被使用的页大概率以后不会再使用了，而最近未使用的页很可能再被使用。</li><li><strong>二次机会算法 (clock算法)</strong>：同样它也需要访问位的支持，它会把所有的页组成一个环，同样未被访问时，访问位置 <code>0</code>，访问位就置 <code>1</code>，在要置换时，我们以顺时针的方向遍历这个环来寻找访问位为 <code>0</code> 的页换出去，若找到访问位为 <code>1</code> 的页，就把它置位 <code>0</code>，代表着给它一次机会，这也是二次机会算法名字的由来。如果所有页的访问位都为 <code>1</code>，则此算法退化为 FIFO 算法。二次机会算法执行过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320224943563.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></li></ul></blockquote><h1 id="5-帧页分配"><a class="markdownIt-Anchor" href="#5-帧页分配"></a> 5 帧（页）分配</h1><p>前面提到每个进程要运行则必须给它分配一定的内存空间，它才能把需要的内容放到内存去执行，那么如何给进程分配内存空间呢？首先我们要保证给它分配的空间是能够让它正常的运行的，即保证进程正常运行所需的最小物理块数，若系统为某进程所分配的物理块数少于此值时，进程将无法正常运行 (频繁发生缺页)，这个数目取决于指令的格式、功能和寻址方式。</p><p>具体分配多个页，有如下的分配方式：</p><ul><li><strong>平均分配</strong>：比如有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个页，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span> 个进程，则每个进程分给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个页；</li><li><strong>按比例分配</strong>：根据每个进程的大小比例来分配；</li><li><strong>优先分配</strong>：根据优先级而不是大小来使用比率分配策略。</li></ul><p>如果进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 产生了一个缺页，我们知道这个时候需要使用页面替换算法来替换一个页面，所替换页面的位置分为如下两种：</p><ul><li><strong>全局替换</strong>：进程在所有的页中选择一个替换页面，一个进程可以从另一个进程中获得页面；</li><li><strong>局部替换</strong>：每个进程只从属于它自己的页中选择。</li></ul><p>所以当进行全局置换的时候，进程所分配的页数是可以变化的，因为它占用了其他进程的页，因此使用全局置换可能造成其他进程的运行错误；当进行局部置换的时候，进程所分配的页数是固定不变的，因为它只在自己所属的范围内置换。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统原理第十章：文件系统</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="hidden-mobile">操作系统原理第八章：内存管理</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>