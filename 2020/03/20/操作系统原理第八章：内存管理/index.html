<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="syz"><meta name="keywords" content=""><title>操作系统原理第八章：内存管理 - syzdev</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"yoursite.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>😄 syzdev</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.u1.huluxia.com/g3/M02/4D/6C/wKgBOV6fEU2AXFGSAAJ7A1Fp7rw147.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="操作系统原理第八章：内存管理"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-20 17:39" pubdate>2020年3月20日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 55 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">操作系统原理第八章：内存管理</h1><div class="markdown-body"><h1 id="1-内存管理背景"><a class="markdownIt-Anchor" href="#1-内存管理背景"></a> 1 内存管理背景</h1><p>下图是计算机系统中存储层次结构：<br><img src="https://img-blog.csdnimg.cn/20200320135927850.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>本文主要讨论的是其中的 <strong>主存 (primary storage)</strong> 部分，主存又叫内存。计算机程序在执行过程中，所有程序必需放入内存并放入一个进程才能被执行，程序是磁盘中的一个静态的实体，通常对应着一个文件，所有的程序都是在<strong>输入队列</strong>中等待的，所谓输入队列就是磁盘上等待进入内存并执行的进程的集合。用户程序在执行之前必需经历很多步骤，这里可以以C语言为例，参考我的这篇文章 <a target="_blank" rel="noopener" href="https://syzdev.cn/2020/03/11/%E7%94%A8gcc%E6%8C%87%E4%BB%A4%E4%BD%93%E9%AA%8CC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">C语言-用gcc指令体验C语言编译过程</a>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320140318912.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>在程序装入内存中，存在着逻辑地址到物理地址的映射问题，即在逻辑地址中 <code>x</code> 的地址是 <code>200</code>，但在物理地址中<code>x</code> 的地址是 <code>1200</code>，因为实际内存中不可能都是从地址 <code>0</code> 开始的，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320141200196.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"><br>因此需要地址之间的绑定以便于指令能够找到实际的物理地址，指令和数据绑定到内存地址可以在三个不同的阶段发生：</p><ul><li><strong>编译时期</strong>：如果内存位置已知，可生成绝对代码；如果开始位置改变，需要修改并重新编译代码；</li><li><strong>加载时期</strong>：如果存储位置在编译时不知道，则必须生成可重定位代码，实际上进程在内存中是不可以移动的，若要移动进程则需要重新定位；</li><li><strong>执行时期</strong>：如果进程在执行时可以在内存中移动，则地址绑定要延迟到运行时。需要硬件对地址映射的支持，例如基址和限长寄存器。</li></ul><p>下图是三种绑定阶段的示例图。在编译时绑定，则在编译后就明确指出操作的物理地址，即 <code>move 1156 3</code> 表示把 <code>count</code> 的值放到地址为 <code>1156</code> 的位置；在加载时绑定，则在编译后就明确指出操作的逻辑地址，即 <code>move 156 3</code>，在加载到内存后进行变换，变换到 <code>1156</code> 的位置；在运行时绑定，则在编译后也是只能给出逻辑地址，在加载到内存时，依然保存的是逻辑地址，但是当执行到这条语句时，再执行该指令的地址变换 <code>1000 + 156 = 1156</code>。<br><img src="https://img-blog.csdnimg.cn/20200320142509474.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>上文所提及的<strong>逻辑地址</strong>和<strong>物理地址</strong>两个概念会贯穿于整个内存管理内容中，他们的定义如下：</p><ul><li><strong>逻辑地址</strong>：由CPU产生，也叫做虚拟空间；</li><li><strong>物理地址</strong>：内存设备所读入的地址。</li></ul><p>在上面的图中，指令 <code>move 1156 3</code> 中的 <code>1156</code> 就是逻辑地址，内存中的 <code>1156</code> 地址块就是物理地址，可以发现在编译时绑定和加载时绑定中，逻辑地址和物理地址是相同的，但在运行时绑定中，逻辑地址和物理地址是不同的。</p><p>我们把将程序装入到与其地址空间不一致的物理空间，所引起的一系列地址变换过程叫做<strong>地址重定位</strong>，地址重定位分为如下两种：</p><ul><li><strong>静态地址重定位</strong>：在装入一个作业时，把作业中的指令地址全部转换为绝对地址，在作业执行过程中就无须再进行地址转换工作，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320143857751.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></li><li><strong>动态地址重定位</strong>：动态地址重地位是在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换成物理地址。动态重定位依靠硬件地址变换机构完成，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320144021805.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>通过硬件把虚拟地址映射到物理地址，所需的硬件叫做<strong>内存管理单元 (MMU)</strong>，在 MMU 策略中，基址寄存器中的值被加入到用户进程所产生的每个地址中，在其送入内存的时候，用户程序所对应到的是逻辑地址，物理地址对它从来都不可见，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320144245219.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></li></ul><h1 id="2-固定分区分配"><a class="markdownIt-Anchor" href="#2-固定分区分配"></a> 2 固定分区分配</h1><p>上一节中讲的主要内容是如何把程序放入内存，即要实现逻辑地址到物理地址的映射，使之能够正确的运行，这一节所讲的主要内容是研究放入内存后如何给它分配内存空间，通常来说会为每一个程序分配一段连续的内存空间，分配方式主要有：</p><ul><li><strong>单一连续区管理方式</strong>：主要针对单道批处理系统，只有一个作业进入内存，内存被分为两块，一块用来存放操作系统，一块用来存放用户程序，我们只要保证用户程序不会影响到操作系统即可，使用基址寄存器策略来保护用户进程（同其他进程和改变的操作系统代码和数据分开)，基址寄存器包含最小物理地址的值，即起始地址；限长寄存器包含逻辑地址的范围，每个逻辑地址必需比限长寄存器的值小，即不能地址越界，判断地址合法流程图如下：<br><img src="https://img-blog.csdnimg.cn/20200320152100402.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"></li><li><strong>多分区管理方式</strong>：是一种可用于多道程序的较简单的存储管理方式，它又分为<strong>固定分区方式</strong>和<strong>可变分区方式。</strong></li></ul><p>对于固定分区分配方式，固定式分区是在<strong>作业装入之前</strong>，内存就被划分成若干个固定大小的连续分区，划分工作可以由系统管理员完成，也可以由操作系统实现，一旦划分完成，在系统运行期间不再重新划分，即分区的个数不可变，分区的大小不可变，所以，固定式分区又称为<strong>静态分区</strong>，划分分区的方法如下：</p><ul><li><strong>分区大小相等</strong>：比如有 <code>100MB</code> 内存，分五个分区，每个分区 <code>20MB</code>，只适用于多个相同程序的并发执行（处理多个类型相同的对象），缺乏灵活性，会造成<strong>内碎片</strong>问题；</li></ul><blockquote><p><strong>内碎片</strong>：比如一个分区大小是 <code>20MB</code>，但是进程只需要 <code>16MB</code>，多出的 <code>4MB</code> 用不上，而别的进程也无法使用，这 <code>4MB</code> 大小的空间就叫做内碎片。</p></blockquote><ul><li><strong>分区大小不等</strong>：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区，两种划分方法示意图如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320152719688.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></li></ul><p>一般将内存的用户区域划分成大小不等的分区，可适应不同大小的作业的需要。当作业到来时，系统有一张<strong>分区说明表</strong>，每个表目说明一个分区的大小、起始地址和是否已分配的使用标志，分区说明表和内存分配图如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320152941899.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>总结来说固定分区分配的优点是易于实现，开销小；缺点是分区大小固定，会造成内碎片问题，同时由于分区总数固定，会限制并发执行的进程数目。</p><h1 id="3-动态内存分配"><a class="markdownIt-Anchor" href="#3-动态内存分配"></a> 3 动态内存分配</h1><p>在动态分区分配中，分区的划分是动态的，不是预先确定的，当某个进程到来，它需要多少内存就给它分配多少内存，所以造成不同大小的分区分布在整个内存中，分配过程如下图，当进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span></span></span></span> 调出内存后，进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span> 和进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 可以使用原来进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span></span></span></span> 所占用的内存：<br><img src="https://img-blog.csdnimg.cn/20200320153807124.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:80%"><br>在这种方式下，操作系统也是需要知道内存的状态的，可以采用<strong>空闲分区表</strong>和<strong>空闲分区链</strong>两种方式，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320154154258.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>在可变分区分配时要设计<strong>分区分配算法</strong>来寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。<strong>分区的先后次序通常是从内存低端到高端</strong>。同时也要设计<strong>分区释放算法</strong>把相邻的空闲分区合并成一个空闲分区。（这时要解决的问题是：合并条件的判断）。</p><p>那么怎样从一个空的分区序列中满足一个申请需要？有如下三种方式：</p><ul><li><strong>首先适应 (First-fit)</strong>：分配最先找到的合适的分区；</li><li><strong>最佳适应 (Best-fit)</strong>：搜索整个序列，找到适合条件的最小的分区进行分配；</li><li><strong>最差适应 (Worst-fit)</strong>：搜索整个序列，寻找最大的分区进行分配。</li></ul><p>很显然，在速度和存储的利用上，理论上首先适应和最佳适应要比最差适应好。</p><h2 id="31-首先适应-first-fit"><a class="markdownIt-Anchor" href="#31-首先适应-first-fit"></a> 3.1 首先适应 (First-fit)</h2><p>首先适应的思想是从空闲分区表的第一个表目开始查找，把找到的<strong>第一个</strong>满足要求的空闲区分配给作业，目的在于<strong>减少查找时间</strong>。通常将空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序，它有如下特点：</p><ul><li>分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端；</li><li>随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大；</li><li>在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为<strong>外碎片</strong>。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。</li></ul><blockquote><p><strong>外碎片</strong>：比如一块内存中连续分配了三个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 占 <code>20MB</code>，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 运行结束了，释放掉了自己的内存，然后来了一个新进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 需要 <code>18MB</code> 的内存，正好刚刚释放掉了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的 <code>20MB</code> 内存可以存放，但是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 之间会有一个 <code>2MB</code> 的内存，由于它太小了，很难分配到它，所以这 <code>2MB</code> 内存就叫做外碎片。</p></blockquote><h2 id="32-最佳适应-best-fit"><a class="markdownIt-Anchor" href="#32-最佳适应-best-fit"></a> 3.2 最佳适应 (Best-fit)</h2><p>最佳适应的思想是从全部空闲区中找出能满足作业要求的、且最小的空闲分区，能使碎片尽量小。为了提高查找效率，空闲分区表（空闲区链）中的<strong>空闲分区要按从小到大进行排序</strong>， 自表头开始查找到第一个满足要求的自由分区分配，它有如下特点：</p><ul><li>从个别来看，外碎片较小，但从整体来看，会形成较多无法利用的碎片；</li><li>较大的空闲分区可以被保留。</li></ul><p>下面是一个具体的例子，假如要分配一个 <code>16KB</code> 分区：<br><img src="https://img-blog.csdnimg.cn/20200320155803703.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"></p><h2 id="33-外碎片问题"><a class="markdownIt-Anchor" href="#33-外碎片问题"></a> 3.3 外碎片问题</h2><p>在可变分区系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外碎片。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。解决碎片的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片，但分区的拼接技术，一方面要求能够对作业进行动态重定位，另一方面系统在拼接时要耗费较多的时间，下图是一个拼接的例子，存在着 <code>400K</code>，<code>300K</code>，<code>200K</code> 三个外碎片，可以将其朝高地址拼接，也可以移动某个进程，也可以在中间拼接，不同的拼接方式系统开销不同：<br><img src="https://img-blog.csdnimg.cn/20200320160143942.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p><h1 id="4-分页"><a class="markdownIt-Anchor" href="#4-分页"></a> 4 分页</h1><p>上面所提到的用拼接解决外碎片问题在实现的时候还是有很多障碍的，我们需要思考还有没有别的方法来解决外碎片问题，我们首先来看动态分区产生外碎片的原因是什么？是因为这种分配要求把作业必须安置在一连续存储区内的缘故，那么如果允许物理地址空间非连续，是否可以解决？<strong>分页存储管理</strong>是解决存储碎片的一种方法，要避开连续性要求，<strong>允许进程的物理地址空间不连续</strong>。</p><p>分页的基本思想是进程的物理地址空间可以是不连续的，如果有可用的物理内存，它将分给进程。我们把物理内存分成大小固定的块。把逻辑内存也分为固定大小的块，叫做页，要求<strong>页的大小和块的大小是一样的</strong>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320161853915.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>根据上图可以看出，把逻辑内存划分为块之后，可以离散的分布在物理内存中。当然在这种情况下，操作系统需要知道哪些页是空闲的，运行一个有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 页大小的程序，需要找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span> 个空的页框读入程序，还要解决的问题就是逻辑地址到物理地址的映射，我们是通过建立一个页表，把逻辑地址转换为物理地址。此外，由于内存块的划分是采用固定大小分配的，所以不可避免的会在最后一个页中产生<strong>内碎片</strong>，地址映射如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200320162525913.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>我们知道由 CPU 产生的地址是逻辑地址，CPU 产生的逻辑地址被分为：</p><ul><li><strong>页号 <code>p</code> (Page number)</strong>：它包含每个页在物理内存中的基址，用来作为页表的索引，也就是一个程序会被划分为多个块，对应在物理地址中是多个页，页号指明了具体是哪个页；</li><li><strong>偏移 <code>d</code> (Page offset)</strong>：同基址相结合，用来确定送入内存设备的物理内存地址，也就是一个页内有很多地址，偏移是确定具体是哪个地址。</li></ul><p>通过页号和偏移确定物理地址的过程如下图，通过页号 <code>p</code> 去查找页表 <code>page table</code>，找到在页表中的哪个页 <code>f</code>，然后把 <code>f</code> 取出来再加上偏移 <code>d</code>，就可以映射到所在的物理地址：<br><img src="https://img-blog.csdnimg.cn/20200320162903866.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"><br>总结来说分页解决了外碎片问题，但是会有内碎片，不过每个内碎片不会超过页的大小，这个开销相比之前的方法来说是可以接受的。一个程序不必连续存放，但也要求程序全部装入内存才能执行。</p><h1 id="5-分页硬件支持"><a class="markdownIt-Anchor" href="#5-分页硬件支持"></a> 5 分页硬件支持</h1><p>回顾分页的过程，如下图，在页数比较小的时候可以直接把页表放入寄存器，但当页数很多的时候，显然是要将页表放入内存中：<br><img src="https://img-blog.csdnimg.cn/20200320163732505.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>将页表放入内存后，要知道放在了内存的哪个地方，这里引入了两个寄存器来保存页表的位置：</p><ul><li><strong>页表基址寄存器 Page-table base register (PTBR)</strong>：页表基址寄存器指向页表的起始地址；</li><li><strong>页表限长寄存器 Page-table length register (PRLR)</strong>：页表限长寄存器表明页表的长度。</li></ul><p>在这个机制中，每一次的数据/指令存取需要<strong>两次内存存取</strong>，一次是存取页表，一次是存取数据，两次的存取显然性能不高，解决办法是通过一个<strong>联想寄存器 translation look-aside buffers (TLBs)</strong>，可以解决两次存取的问题。</p><p>联想寄存器类似于一个快速缓存，每次查找一个页的时候，都记录下页和页的起始地址，当下次查询的时候可以直接在联想寄存器中寻找，找不到的时候再去查找页表，此时地址映射的过程如下，相比在第四节中最后的那张图多了一个联想寄存器的查找步骤：<br><img src="https://img-blog.csdnimg.cn/20200320164807147.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"><br>我们知道寄存器的存取速度是比内存快的，因此用这种方法能大大提高查找效率，举个例子，我们假设联想寄存器的查找需要时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">ε</span></span></span></span>，内存一次存取要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>微秒，我们称如果在联想寄存器中找到了对应的页地址的话，叫做“命中”，那么命中率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.0037em">α</span></span></span></span> 就为在联想寄存器中找到页号的比率，比率与联想寄存器的大小有关，此时有效的存取时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>ε</mi><mo stretchy="false">)</mo><mi>α</mi><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>ε</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">–</mi><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>+</mo><mi>ε</mi><mi mathvariant="normal">–</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">T=(1 + ε) α + (2 + ε)(1 – α)=2 + ε – α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">ε</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">ε</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mord" style="margin-right:.02778em">–</span><span class="mord mathdefault" style="margin-right:.0037em">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">ε</span><span class="mord" style="margin-right:.02778em">–</span><span class="mord mathdefault" style="margin-right:.0037em">α</span></span></span></span>。</p><blockquote><p>可以带入具体数值来看一看，例如，假设检索联想存储器的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">20ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ，访问内存的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ，访问联想存储器的命中率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>85</mn></mrow><annotation encoding="application/x-tex">85</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span><span class="mord">5</span></span></span></span>% ，则 CPU 存取一个数据的平均时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>0.85</mn><mo>∗</mo><mn>120</mn><mo>+</mo><mn>0.15</mn><mo>∗</mo><mn>220</mn><mo>=</mo><mn>135</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T=0.85*120+0.15*220=135ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">5</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>，访问时间只增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>35</mn></mrow><annotation encoding="application/x-tex">35</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">5</span></span></span></span>%。如果不引入联想存储器，其访问将延长一倍（达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">200ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ）</p></blockquote><p>下图是分页地址变换机构工作原理图，首先按页的大小分离出页号和位移量，放入有效地址寄存器中，再将页号与页表长度进行比较，如果页号大于页表长度，越界中断；再以页号为索引查找页表，将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号；然后将该物理块号装入物理地址寄存器的高址部分；最后将有效地址寄存器中的位移量直接复制到物理地址寄存器的低位部分，从而形成内存地址：<br><img src="https://img-blog.csdnimg.cn/20200320170230920.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:50%"><br>下面是一个具体的例子，图中省略了越界判断，先分离出了页号和偏移，分别为 <code>2</code> 和 <code>1C4</code>，然后查找页表，得到块号地址为 <code>8</code>，然后将 <code>8</code> 放在物理地址寄存器的高位，把偏移 <code>1C4</code> 放在物理地址寄存器的低位，这个地址就是物理地址：<br><img src="https://img-blog.csdnimg.cn/20200320170933132.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p><h1 id="6-分段管理"><a class="markdownIt-Anchor" href="#6-分段管理"></a> 6 分段管理</h1><p>上面所讨论的分页方式有效的解决了外碎片问题，但是实际上并没有考虑用户的观点，也就是它在分页的时候都是硬性的按照等大小来划分，并不关心页中存放的是程序还是数据。本节中引入的分段方式就是一种支持用户观点的内存管理机制。</p><p>一个程序是一些段的集合，一个段是一个逻辑单位，如主程序、子过程、函数、局部变量、全局变量等等内容，在用户的眼里是把程序看作各个有机的部分，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320171719619.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>把程序的各个部分放入内存实际上也就是把这每个部分看成各个段，然后放入内存，如下图：<br><img src="https://img-blog.csdnimg.cn/20200320171838259.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>在分段管理方式下要解决的问题依旧是逻辑地址到物理地址的映射问题，与分页类似，分段管理方式下也有段表，和段偏移。由于分页的每一页都是固定大小的，所以只需要起始地址，但是分段的每一段大小是不等长的，所以这里定义了两个变量：</p><ul><li><strong>基址 (base)</strong>：包括内存中段物理地址的起始地址；</li><li><strong>限长 (limit)</strong>：指定段的长度。</li></ul><p>从逻辑地址到物理地址的映射过程如下图所示，段表中保存着每一段的起始地址和限长地址，这样就在内存中唯一确定了段的地址范围：<br><img src="https://img-blog.csdnimg.cn/20200320172502676.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>下图是实现地址映射的物理结构流程图，其过程和分页的过程十分类似：<br><img src="https://img-blog.csdnimg.cn/20200320172702716.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"><br>在分页方式中，页表是要保存在内存中的，所以当时定义了页表基址寄存器 (PTBR) 和页表限长寄存器 (PRLR) 来指明页表的位置，同样在分段方式中，也定义了类似的两个寄存器：</p><ul><li><strong>段表基址寄存器 Segment-table base register (STBR)</strong>：段表基址寄存器指向段表在内存中的地址；</li><li><strong>段表限长寄存器 Segment-table length register (STLR)</strong>：段表限长寄存器表明被一个程序所使用的段的数目。</li></ul><p>此时地址变化过程如下图，首先系统将逻辑地址中的段号 <code>S</code> 与段表长度 <code>TL</code> 进行比较。若 <code>S &gt;= TL</code>，访问越界，若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址；然后再检查段内地址 <code>d</code> 是否超过该段的段长 <code>SL</code> 。若超过，即 <code>d &gt;= SL</code>，同样发出越界中断信号；若未越界，则将该段的基址与段内地址 <code>d</code> 相加，得到要访问的内存物理地址。<br><img src="https://img-blog.csdnimg.cn/20200320173359432.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">操作系统原理第九章：虚拟内存</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%AD%BB%E9%94%81/"><span class="hidden-mobile">操作系统原理第七章：死锁</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script src="/js/boot.js"></script></body></html>