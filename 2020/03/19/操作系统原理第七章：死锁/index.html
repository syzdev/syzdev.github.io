<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content=""><meta name="author" content="syz"><meta name="description" content=""><title>操作系统原理第七章：死锁 | syzdev</title><link rel="apple-touch-icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link rel="icon" href="https://cdn.u1.huluxia.com/g3/M03/4D/84/wKgBOV6fGZWATbp6AAAML1Rr8NY150.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/color-scheme.css"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/comments.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script defer type="text/javascript" src="/plugins/jquery.min.js"></script><link href="/plugins/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">syzdev</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/about/"><a href="/about/">关于</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="/plugins/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">操作系统原理第七章：死锁</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-19 23:47:57 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"><b>#</b> 操作系统原理</a></span></span></div><div class="markdown-body"><h1 id="1-死锁的基本概念"><a class="markdownIt-Anchor" href="#1-死锁的基本概念"></a> 1 死锁的基本概念</h1><p><strong>死锁 (Deadlock)</strong> 指的是计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。</p><p>下面是一个现实中过桥的例子，如图所示桥比较窄，只能同时通过一辆车，此时有两辆车面对面都想要通过桥，而两辆车互不相让，导致都无法通过，这就是现实中“死锁”的例子。我们可以把桥看作是资源，对于车来说是共享的，当死锁发生时，要解决死锁其中一种解决方法是让其中某辆车后退，现假设让右边的车后退，则它后面的所有车都要后退，若每次都是右边的车让道的话，右边有些车就一直不能通行，就会造成<strong>饥饿</strong>现象。<br><img src="https://img-blog.csdnimg.cn/20200319195105827.png" alt="在这里插入图片描述" style="zoom:33%"><br>死锁现象产生的本质就是<strong>供小于求</strong>，也就是资源满足不了进程的需求，每一个进程如下的利用资源：</p><ul><li><strong>申请 (Request)</strong>： 如果申请不能立即被允许，那么进程必须等待直到能获取资源。（通过系统调用或者信号量来进行资源的申请和释放）；</li><li><strong>使用 (Use)</strong>： 进程使用资源进行相关操作；</li><li><strong>释放 (Release)</strong> ：进程释放资源。</li></ul><p>除了对资源的竞争会产生死锁外，P，V操作顺序的不当也会产生死锁，如现有进程 P_0 和 P_1 ，他们都要申请信号量 A 和信号量 B，他们的操作如下表：</p><table><thead><tr><th>时间</th><th>P_0</th><th>P_1</th></tr></thead><tbody><tr><td>t_1</td><td><code>wait(A);</code></td><td><code>wait(B);</code></td></tr><tr><td>t_2</td><td><code>wait(B);</code></td><td><code>wait(A);</code></td></tr></tbody></table><p>在 t_1 时刻， P_0 和 P_1 分别申请了信号量 A 和信号量 B，那么在 t_2 时刻由于信号量 B 已经被 P_1 申请，所以 P_0 申请不到信号量 B，同理 P_1 也申请不到信号量 A，这时就发生了死锁。</p><p>总结来说，产生死锁的原因如下：</p><ul><li><strong>竞争资源引起死锁</strong>：当系统中供多个进程所使用的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁；</li><li><strong>进程推进顺序不当引起死锁</strong>：在多道程序系统中，并发执行的进程推进序列不可预测，有些推进顺序，进程可以顺利完成，有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成死锁。</li></ul><h1 id="2-死锁的必要条件"><a class="markdownIt-Anchor" href="#2-死锁的必要条件"></a> 2 死锁的必要条件</h1><p>死锁的产生是有必要条件的，当下面四个条件<strong>同时出现</strong>，死锁将会发生：</p><ol><li><strong>互斥 (Mutual exclusion)</strong>：一次只有一个进程可以使用一个资源，因为有些资源的使用是必须独占的；</li><li><strong>占有并等待 (Hold and wait)</strong>：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源，又叫请求与保持；</li><li><strong>不可抢占 (No preemption)</strong>：一个资源只有当持有它的进程完成任务后才自由的释放，也就是非剥夺。若可以抢占的话，别的进程需要某个资源可以直接抢，就不存在死锁问题了；</li><li><strong>环路等待 (Circular wait)</strong>：等待资源的进程之间存在环，举个例子来说，进程 1 要获得进程 2 的资源才能执行结束，进程 2 要获得进程 3 的资源才能运行结束，进程 3 要获得进程 1 的资源才能运行结束，这样就形成了一个等待环，谁也无法运行结束离开这个环。</li></ol><p>死锁指的是一组进程对一组资源使用时的某种状态，那么描述这个状态有如下参数：</p><ul><li><strong>资源类型</strong>：可以用 R 来表示，如可以用 R_1 ， R_2 ， R_3 表示 CPU 周期，内存空间，I/O 设备；</li><li><strong>实例</strong>：每个资源可能有多个实例，用 W 表示；</li><li><strong>进程</strong>：用 P 来表示。</li></ul><p>此时状态就可以用<strong>资源分配图</strong>来表示，在数据结构中，图是由一组顶点的集合 <code>V</code> 和边的集合 <code>E</code> 组成，在资源分配图中有两种类型的节点：</p><ul><li><strong>P</strong>：系统中全部的进程构成的节点；</li><li><strong>R</strong>：系统中全部的资源构成的节点。</li></ul><p>进程和资源之间的边也存在着两种边：</p><ul><li><strong>请求边</strong>：即某个进程 P_i 要请求某个资源 R_j 的边，箭头是从进程指向资源；</li><li><strong>分配边</strong>：即某个资源 R_j 已经被分配给某个进程 P_i 的边，箭头是从资源指向进程。</li></ul><p>可以把进程表示为圆点，把资源表示成方形，把资源中的实例表示为更小的方形：<br><img src="https://img-blog.csdnimg.cn/20200319203500495.png" alt="在这里插入图片描述" style="zoom:67%"><br>上述两种边就可以表示为如下形式：<br><img src="https://img-blog.csdnimg.cn/20200319203639432.png" alt="在这里插入图片描述" style="zoom:67%"><br>有了上面的方法就可以方便的描述进程和资源的分配关系，如某时刻的关系如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020031920383818.png" alt="在这里插入图片描述" style="zoom:40%"><br>从资源分配图中，可以得出如下结论：</p><ul><li>如果图没有环，那么不会有死锁；</li><li>如果图有环，若每一种资源类型<strong>只有一个</strong>实例，那么<strong>一定会</strong>死锁，若每种资源类型<strong>有多个</strong>实例，<strong>可能</strong>死锁。</li></ul><h1 id="3-死锁预防"><a class="markdownIt-Anchor" href="#3-死锁预防"></a> 3 死锁预防</h1><p>处理死锁有忽略、预防、避免、检测、解除五种措施，忽略就是假装系统中从未出现过死锁，这个方法被大部分的操作系统采用，包括 UNIX 中的<strong>鸵鸟策略</strong>。预防死锁，避免死锁则是确保系统永远不会进入死锁状态。死锁检测和解除则是允许系统进入死锁状态，然后恢复系统。</p><blockquote><p><strong>鸵鸟策略</strong>：鸵鸟在遇到危险时会将头埋在沙子里，这里比喻像鸵鸟一样对死锁视而不见，因为处理死锁的代价很大，而且常常给用户带来许多不便的限制，大多数用户宁可在极偶然的情况下发生死锁，也不愿限制每个用户只能创建一个进程、只能打开一个文件等等，于是不得不在方便性和正确性之间作出折衷。</p></blockquote><h2 id="31-抑制死锁发生的必要条件"><a class="markdownIt-Anchor" href="#31-抑制死锁发生的必要条件"></a> 3.1 抑制死锁发生的必要条件</h2><p>对于<strong>互斥</strong>条件来讲，是不可以打破的，因为在某些条件下，必须互斥访问，详细内容可以参考这篇文章 <a target="_blank" rel="noopener" href="https://syzdev.cn/2020/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">操作系统原理第六章：进程同步</a>。</p><p>对于<strong>占有并等待</strong>条件，要打破这个条件的话必须保证进程申请资源的时候没有占有其他资源，要做到这一点有如下两种方式：</p><ul><li>要求进程在执行前一次申请全部的资源，这样的话后续就不会再有资源的申请了；</li><li>没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源。</li></ul><blockquote><p>实际上这两种方法都是代价不小的，比如第一种方法，进程使用资源不是一次性全部使用的，而是有次序的使用的，这样就导致某些资源明明现在用不到，却被占有着，而其他着急使用该资源的进程要等待。</p></blockquote><p>对于<strong>非抢占式</strong>，打破这个条件就是允许抢占，抢占的方式是如果一个进程的申请没有实现，它要释放所有占有的资源，抢占的资源放入进程等待资源列表中，只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始。</p><p>对于<strong>环路等待</strong>条件，打破这个条件可以将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源，也就是给每个资源编号，所有进程对资源的请求必须严格按资源序号递增的次序提出，如已经申请了 1 号资源 CPU 和 2 号资源打印机，那么后面再申请资源必须按次序 3 、 4 、 5 等等。总有一个进程占据了较高序号的资源，它继续请求的资源必然是空闲的，可以一直向前推进。在资源分配图中不可能出现环路，因而摒弃了“环路等待”条件，这种策略可以提高资源利用率，但在进程使用各类资源的顺序与系统规定的顺序不同时会造成资源浪费的情况。</p><p>总结来说上述预防死锁的方法通过限制资源请求来打破死锁的四个必要条件之一，从而预防死锁的发生，但可能带来副作用，如降低设备利用率和吞吐量，可能有进程饥饿等。</p><h1 id="4-死锁避免"><a class="markdownIt-Anchor" href="#4-死锁避免"></a> 4 死锁避免</h1><p>死锁避免不会去限制资源的使用，而是允许进程动态地申请资源，但在系统进行资源分配之前，先计算资源分配的安全性，若此次分配不会导致系统从<strong>安全状态</strong>向<strong>不安全状态</strong>转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。</p><p>安全状态是指系统的一种状态，在此状态下，系统能按某种顺序（例如 P_1 ， P_1 ，…， P_n ）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（ P_1 ， P_1 ，…， P_n ）称为<strong>安全序列</strong>。 如果存在一个安全序列，则系统处于安全状态，若某一时刻不存在一个安全序列，则称系统处于不安全状态。</p><p>死锁属于不安全状态，是不安全状态的一个子集，它们之间的关系如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200319214216489.png" alt="在这里插入图片描述" style="zoom:67%"><br>如果一个系统在安全状态，就没有死锁；如果系统死锁，则处于不安全状态；如果一个系统处于不安全状态，就有可能死锁；那么既然要避免死锁，那就要避免系统进入不安全状态。</p><p>避免死锁有两种常用方式：</p><ul><li>当资源有单个实例的时候，可以用之前提到的<strong>资源分配图</strong>来实现，若图中出现了环，这表示出现了死锁，那么可以检测资源分配图判断是否有环来避免死锁；</li><li>当资源有多个实例的时候，使用<strong>银行家算法</strong>。</li></ul><h2 id="41-资源分配图法"><a class="markdownIt-Anchor" href="#41-资源分配图法"></a> 4.1 资源分配图法</h2><p>在第二节也提到过资源分配图，在用资源分配图法避免死锁时，添加了一条新的边叫做<strong>需求边</strong>，即表示进程 P_i 可能会申请到资源 R_j ，箭头从进程指向资源，但是箭头图形为<strong>虚线</strong>。当一个进程申请资源的时候，需求边转化为请求边；当资源被进程释放的时候，分配边转化为需求边；当然系统中的资源必须被事先声明。</p><p>用资源分配图法来避免死锁的过程如下，当进程 P_i 申请资源 R_j 时，<strong>把图中的所有需求边转换为分配边，看图中是否出现环路</strong>，只有不出现环路，才实施资源分配，如下图：<br><img src="https://img-blog.csdnimg.cn/20200319215548958.png" alt="在这里插入图片描述" style="zoom:67%"></p><h2 id="42-银行家算法"><a class="markdownIt-Anchor" href="#42-银行家算法"></a> 4.2 银行家算法</h2><p>在现实世界中，银行的利益方式之一是提供贷款，当银行给某人提供贷款时，会考查他是否有能力偿还贷款，以此来判断贷出去的这笔钱是否是安全的。那么银行家算法就是借助这个思想，当某个进程需要分配资源的时候，操作系统会判断这个进程能不能把资源安全的归还，如果可以的话操作系统就分配，否则不分配。</p><p>银行家算法适用于多个实例的情况，每一个进程必须事先声明使用的最大量，当一个进程请求资源，它可能要等待，当一个进程得到所有的资源，它必须在有限的时间释放它们。</p><p>在实现银行家算法时，需要定义如下的参数：</p><ul><li><strong><code>n</code></strong> 为进程的数目，<strong><code>m</code></strong> 为资源的数目；</li><li><strong><code>Available</code></strong>：系统中有多少个可用资源，由于银行家算法用在多实例中，则如果 <code>available[ j ] = k</code>，表示资源 R_j 有 k 个实例有效；</li><li><strong><code>Max</code></strong>：每个进程最多需要请求的资源个数，如果 <code>Max[ i, j ] = k</code>，那么进程 P_i 需要最多请求资源 R_j 的 k 个实例；</li><li><strong><code>Allocation</code></strong>：每个进程已经分配了多少资源，如果 <code>Allocation[ i, j ] = k</code>，那么进程 P_i 当前分配了 R_j 的 k 个资源；</li><li><strong><code>Need</code></strong>：每个进程还需要多少资源，如果 <code>Need[ i, j ] = k</code>，那么进程 P_i 还需要 R_j 的 k 个资源。上面几个参数存在这样的关系：<code>Need [ i, j ] = Max [ i, j ] – Allocation [ i, j ]</code>；</li><li><strong><code>Request</code></strong>：进程当前要申请多少资源，如果 <code>Request[ i, j ] = k</code>，那么进程 P_i 现在想申请 R_j 的 k 个资源。</li></ul><p>银行家算法具体的实现过程如下：</p><ol><li>若 <code>Request &lt;= Need</code>，执行下一步，否则不执行，意思是进程当前想申请的资源必须是小于它实际所需要的，不能超出实际所需要的；</li><li>若 <code>Request &lt;= Available</code>，执行下一步，意思是当前申请的资源数量，系统是否可以满足，若满足不了，则需要等待，直到系统可以满足为止；</li><li>试着去给该进程分配资源，会执行如下操作 <code>Available = Available - Request</code>，<code>Allocation = Allocation + Request</code>，<code>Need = Need - Request</code>；</li><li>用<strong>安全算法</strong>检查，看系统是否处于安全状态，如果安全就分配资源，否则不分配并让之前执行的三个操作回到原来状态。</li></ol><p>在安全算法中，有两个参数：</p><ul><li><strong><code>Work</code></strong>：<code>Work = Available</code> 表示当前系统中可提供资源的数量；</li><li><strong><code>Finish</code></strong>：它为一个布尔变量，描述进程是否执行结束，如 <code>Finish[ i ] = false</code> 表示进程 P_i 还没有执行结束或还没有执行。</li></ul><p>在进程序列中，若进程 P_i 满足如下条件：</p><ul><li><code>Finish[ i ] = false</code>，这个进程还没执行完；</li><li><code>Need &lt;= Work</code>，进程 P_i 所需的资源数量是小于系统可用资源数量的，换句话说就是系统是可以满足该进程的需求的。</li></ul><p>则执行 <code>Work = Work + Allocation</code>，<code>Finish[ i ] = true</code>，这两句的意思是进程 P_i 执行完后把它的 <code>Allocation</code> 给释放掉，然后标明 <code>Finish</code> 为已经执行完。<strong>然后按照该步骤依次检查所有的进程，如果最后所有进程的 <code>Finish</code> 都为 <code>true</code> 则代表所有进程都能顺利结束，那么说明系统为安全状态，所检查的序列叫做安全序列。</strong></p><p>银行家算法举例：现假设有五个进程 P_0 ~ P_4 ，三个资源类型 A （ 10 个实例）， B （ 5 个实例）， C （ 7 个实例），下表是在 T_0 时刻系统的状态：</p><table><thead><tr><th>进程</th><th><code>Allocation</code>（已分配）</th><th><code>Max</code>（总需求）</th><th><code>Available</code>（当前可分配）</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td>P_0</td><td>0 1 0</td><td>7 5 3</td><td>3 3 2</td></tr><tr><td>P_1</td><td>2 0 0</td><td>3 2 2</td><td></td></tr><tr><td>P_2</td><td>3 0 2</td><td>9 0 2</td><td></td></tr><tr><td>P_3</td><td>2 1 1</td><td>2 2 2</td><td></td></tr><tr><td>P_4</td><td>0 0 2</td><td>4 3 3</td><td></td></tr></tbody></table><p>要判断当前是否处于安全状态，要计算 <code>Need</code>，如下表：</p><table><thead><tr><th>进程</th><th><code>Need</code>（还需的资源数）= <code>Max - Allocation</code></th></tr></thead><tbody><tr><td></td><td>A B C</td></tr><tr><td>P_0</td><td>7 4 3</td></tr><tr><td>P_1</td><td>1 2 2</td></tr><tr><td>P_2</td><td>6 0 0</td></tr><tr><td>P_3</td><td>0 1 1</td></tr><tr><td>P_4</td><td>4 3 1</td></tr></tbody></table><p>此时使用安全算法来验证是否有<strong>安全序列</strong>，初始条件下 <code>Work = available = (3，3，2)</code>，<code>Finish[ i ] = false (i = 0..4)</code>：</p><table><thead><tr><th>进程</th><th><code>Work</code></th><th><code>Need</code></th><th><code>Allocation</code></th><th><code>Finish</code></th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td><td>T/F</td></tr><tr><td>P_1</td><td>3 3 2</td><td>1 2 2</td><td>2 0 0</td><td>T</td></tr><tr><td>P_3</td><td>5 3 2</td><td>0 1 1</td><td>2 1 1</td><td>T</td></tr><tr><td>P_4</td><td>7 4 3</td><td>4 3 1</td><td>0 0 2</td><td>T</td></tr><tr><td>P_2</td><td>7 4 5</td><td>6 0 0</td><td>3 0 2</td><td>T</td></tr><tr><td>P_0</td><td>10 4 7</td><td>7 4 3</td><td>0 1 0</td><td>T</td></tr></tbody></table><p>所以存在安全序列（ P_1 ， P_3 ， P_4 ， P_2 ， P_0 ），系统处于安全状态。</p><blockquote><p>注意：安全序列有时不是唯一的，但只要找到一个，就认为系统是安全的。</p></blockquote><h1 id="5-死锁的检测"><a class="markdownIt-Anchor" href="#5-死锁的检测"></a> 5 死锁的检测</h1><p>死锁的检测分为两种情况，一种是每一种资源类型只有一个实例，另一种是一个资源类型的多个实例。</p><h2 id="51-每一种资源类型只有一个实例"><a class="markdownIt-Anchor" href="#51-每一种资源类型只有一个实例"></a> 5.1 每一种资源类型只有一个实例</h2><p>通过把资源分配图转换成<strong>维护等待图</strong>，来看维护等待图中是否出现了环来看当前系统是否出现了死锁。在维护等待图中<strong>只有一种节点就是进程</strong>，若进程 P_i 指向进程 P_j ，则表示 P_i 在等待 P_j ，如下图左边为资源分配图，右边为转换的维护等待图：<br><img src="https://img-blog.csdnimg.cn/20200319232003803.png" alt="在这里插入图片描述" style="zoom:67%"><br>可以发现维护等待图中是存在环的，所以表明当前系统出现死锁了。</p><h2 id="52-一个资源类型的多个实例"><a class="markdownIt-Anchor" href="#52-一个资源类型的多个实例"></a> 5.2 一个资源类型的多个实例</h2><p>这里用到的算法叫做<strong>死锁检测算法</strong>，<strong>类似于之前讲过的安全算法</strong>，死锁检测算法定义了如下参数：</p><ul><li><strong><code>Available</code></strong>：每种资源可用的资源数量；</li><li><strong><code>Allocation</code></strong>：每个进程已经分配的资源数量；</li><li><strong><code>Request</code></strong>：进程请求的资源数量。</li><li><strong><code>Work</code></strong>：<code>Work = Available</code>；</li><li><strong><code>Finish</code></strong>：这里的 <code>Finish</code> 和之前的安全算法有所不同，这里当 <code>Allocation != 0</code> 则 <code>Finish = false</code> 否则 <code>Finish = true</code> ，也就是若某进程的 <code>Allocation = 0</code> 时说明这个进程没有被分配到资源，也就这个进程是不参与死锁的，所以 <code>Finish = true</code> 。</li></ul><p>找到某进程满足如下条件：</p><ul><li><code>Finish = false</code>；</li><li><code>Request &lt;= Work</code>：当前请求的资源数量小于系统可分配资源的数量；</li></ul><p>该进程能执行结束，执行结束后执行 <code>Work = Work + Allocation</code>， <code>Finish = true</code>，也就是把资源给释放掉，把所有的进程按如上操作遍历结束后检查会不会有一个进程的 <code>Finish = false</code> ，也就是某个进程无法结束，那么就发生了死锁，并且可以根据 <code>Finish</code> 的下标找到是哪一个进程发生了死锁。</p><p>检测死锁算法的例子：现假设有五个进程 P_0 ~ P_4 ，三个资源类型 A （ 7 个实例）， B （ 2 个实例）， C （ 6 个实例），下表是在 T_0 时刻系统的状态：</p><table><thead><tr><th>进程</th><th><code>Allocation</code>（已分配）</th><th><code>Request</code>（当前请求）</th><th><code>Available</code>（当前可分配）</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td>P_0</td><td>0 1 0</td><td>0 0 0</td><td>0 0 0</td></tr><tr><td>P_1</td><td>2 0 0</td><td>2 0 2</td><td></td></tr><tr><td>P_2</td><td>3 0 3</td><td>0 0 0</td><td></td></tr><tr><td>P_3</td><td>2 1 1</td><td>1 0 0</td><td></td></tr><tr><td>P_4</td><td>0 0 2</td><td>0 0 2</td><td></td></tr></tbody></table><p>所以存在安全序列（ P_0 ， P_2 ， P_3 ， P_1 ， P_4 ），当前是没有死锁的。</p><p>现在假设进程 P_2 请求 C 的一个实例，如下表：</p><table><thead><tr><th>进程</th><th><code>Request</code>（当前请求）</th></tr></thead><tbody><tr><td></td><td>A B C</td></tr><tr><td>P_0</td><td>0 0 0</td></tr><tr><td>P_1</td><td>2 0 1</td></tr><tr><td>P_2</td><td>0 0 1</td></tr><tr><td>P_3</td><td>1 0 0</td></tr><tr><td>P_4</td><td>0 0 2</td></tr></tbody></table><p>此时可以归还 P_0 所有的资源，但是资源不够完成其他进程的请求，所以死锁存在，包括进程 P_1 ， P_2 ， P_3 ， P_4 。</p><h2 id="53-处理死锁"><a class="markdownIt-Anchor" href="#53-处理死锁"></a> 5.3 处理死锁</h2><p>当系统出现死锁，通常有如下三种方式：</p><ul><li>操作员人工处理；</li><li>进程终止；</li><li>资源抢占。</li></ul><p>其中进程终止和资源抢占是由操作系统来完成的，进程终止的方法如下：</p><ul><li>终止所有的死锁进程；</li><li>一次终止一个进程直到死锁环消失；</li><li>选择终止顺序，比如按照进程的优先级来终止，先终止优先级低的进程，或者按照进程计算了多少时间，还需要多长时间来选择终止。</li></ul><p>资源抢占的方法如下：</p><ul><li>选择一个牺牲品：最小化代价；</li><li>回退：返回到安全的状态，然后重新开始进程。</li></ul><p>但是会造成饥饿，因为同一个进程可能总是被选中，包括在回退时。</p></div><div class="prev-or-next"><div class="post-foot-next"><a href="/2020/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" target="_self"><i class="iconfont icon-chevronleft"></i> <span>上一页</span></a></div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime" title="更新时间"></i> 2020-03-19 23:47:57 </span><span class="post-tags"><i class="iconfont icon-tags" title="标签"></i> <span class="span--tag"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"><b>#</b> 操作系统原理</a></span></span></div><div class="post-foot-prev"><a href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_self"><span>下一页</span> <i class="iconfont icon-chevronright"></i></a></div></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1 死锁的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">2 死锁的必要条件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">3 死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%8A%91%E5%88%B6%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.1 抑制死锁发生的必要条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">4 死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E6%B3%95"><span class="toc-text">4.1 资源分配图法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">4.2 银行家算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-text">5 死锁的检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E6%AF%8F%E4%B8%80%E7%A7%8D%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.1 每一种资源类型只有一个实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.2 一个资源类型的多个实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81"><span class="toc-text">5.3 处理死锁</span></a></li></ol></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/syzdev"><i class="iconfont icon-github"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get();a.innerHTML="",r.addEventListener("input",(function(){var e='<ul class="search-result-list">',n=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach((function(t){var r=!0;t.title&&""!==t.title.trim()||(t.title="Untitled");var a=t.title.trim(),c=a.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),l=t.url,o=-1,u=-1,h=-1;if(""!==i?n.forEach((function(e,t){o=c.indexOf(e),u=i.indexOf(e),o<0&&u<0?r=!1:(u<0&&(u=0),0==t&&(h=u))})):r=!1,r){e+="<li><a href='"+l+"' class='search-result-title'>"+a+"</a>";var d=s;if(h>=0){var p=h-20,f=h+80;p<0&&(p=0),0==p&&(f=100),f>d.length&&(f=d.length);var m=d.substr(p,f);n.forEach((function(e){var t=new RegExp(e,"gi");m=m.replace(t,'<span class="search-keyword">'+e+"</span>")})),e+='<p class="search-result-abstract">'+m+"...</p>"}e+="</li>"}})),-1===(e+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=e}}))},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",(function(){$("#search-input").val(""),$("#search-result").html("")}))},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script></div></div></body></html>