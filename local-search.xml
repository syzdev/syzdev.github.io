<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Express基础</title>
    <link href="/2021/08/08/Express%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/08/Express%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性用来创建各种Web应用。</p><ul><li>提供了方便简洁的路由定义方式；</li><li>对获取HTTP请求参数进行了简化处理；</li><li>对模板引擎支持程度高，方便渲染动态HTML页面；</li><li>提供了中间件机制有效控制HTTP请求；</li><li>拥有大量第三方中间件对功能进行扩展。</li></ul><p>可以使用 <code>npm install express</code> 命令安装Express，安装后包含两个文件夹：</p><ul><li><code>node_modules</code>：包含所有依赖包；</li><li><code>package-lock.json</code>：所有依赖包的清单。</li></ul><p>再在根目录新建文件<code>server.js</code>，具体使用方法见第3节。</p><h1 id="2-原生nodejs与express框架路由实现对比"><a class="markdownIt-Anchor" href="#2-原生nodejs与express框架路由实现对比"></a> 2 原生Node.js与Express框架路由实现对比</h1><h2 id="21-原生nodejs路由"><a class="markdownIt-Anchor" href="#21-原生nodejs路由"></a> 2.1 原生Node.js路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取客户端的请求路径</span><br>  <span class="hljs-keyword">let</span> &#123;pathname&#125; = url.parse(req.url)<br>  <span class="hljs-comment">// 对请求路径进行判断，不同的路径地址响应不同的内容</span><br>  <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/&#x27;</span> || pathname == <span class="hljs-string">&#x27;index&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到首页！&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/other&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到其他页面！&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname == <span class="hljs-string">&#x27;/about&#x27;</span>) &#123;<br>    res.end(<span class="hljs-string">&#x27;欢迎来到关于页面！&#x27;</span>) <br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.end(<span class="hljs-string">&#x27;抱歉，没有找到相关页面！&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="22-express路由"><a class="markdownIt-Anchor" href="#22-express路由"></a> 2.2 Express路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 当客户端以get方式访问/时</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 对客户端做出响应</span><br>  res.send(<span class="hljs-string">&#x27;使用get方式请求了/路由&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 当客户端以post方式访问/about路由时</span><br>app.post(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;使用post方式请求了/about路由&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="3-express框架简单使用"><a class="markdownIt-Anchor" href="#3-express框架简单使用"></a> 3 Express框架简单使用</h1><p>启动一个Express网站服务器并开启一个“/”的路由监听：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.引入Express框架，并创建Express实例</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2.创建网站服务器对象</span><br><span class="hljs-keyword">const</span> app = express()<br><br><span class="hljs-comment">// 3.定义路由</span><br><span class="hljs-comment">// 第一个参数是请求的路径，&#x27;/&#x27;代表根路径localhost:3000</span><br><span class="hljs-comment">// 第二个参数是一个函数，req是request的缩写，表示客户端提交过来的数据</span><br><span class="hljs-comment">// res是respond的缩写，表示要响应回的数据</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// send()方法，响应给客户端信息</span><br>  <span class="hljs-comment">// 1. send方法内部会检测响应内容的类型</span><br>  <span class="hljs-comment">// 2. send方法会自动设置http状态码</span><br>  <span class="hljs-comment">// 3. send方法会帮我们自动设置响应的内容类型及编码</span><br>  res.send(<span class="hljs-string">&#x27;Hello Express!&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 4.监听端口，第二个参数回调函数启动成功后执行的内容</span><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;网站服务器启动成功！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>输入<code>node server.js</code>启动服务器，但因node项目在每次编辑后都要重新启动才会生效，所以使用<code>nodemon</code>工具来自动启动服务，推荐全局安装，命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">npm install -g nodemon<br></code></pre></div></td></tr></table></figure><p>安装成功后就可以使用命令<code>nodemon server.js</code>来启动服务。</p><h1 id="4-中间件"><a class="markdownIt-Anchor" href="#4-中间件"></a> 4 中间件</h1><p>中间件就是一系列方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。<br /><img src="https://img-blog.csdnimg.cn/img_convert/75024b07c5a7148392d71bb36f66c5e4.png" /><br />中间件主要由两部分构成，中间件方法以及请求处理函数。<br />中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。<br />可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  req.name = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  next()<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(req.name)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用 <code>next()</code> 方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><h2 id="41-万能中间件-appuse"><a class="markdownIt-Anchor" href="#41-万能中间件-appuse"></a> 4.1 万能中间件 <code>app.use</code></h2><p><code>app.use</code> 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.url)<br>  next()<br>&#125;)<br></code></pre></div></td></tr></table></figure><p><code>app.use</code> 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.url)<br>  next()<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="42-中间件的应用"><a class="markdownIt-Anchor" href="#42-中间件的应用"></a> 4.2 中间件的应用</h2><ol><li>路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 登录过程模拟</span><br>app.get(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 用户没有登录</span><br>  <span class="hljs-keyword">let</span> isLogin = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (isLogin) &#123;<br>    <span class="hljs-comment">// 如果用户登录，让请求继续向下执行</span><br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;您还没有登录，不能访问当前页面！&#x27;</span>)<br>  &#125;<br>&#125;)<br><br>app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;您已经登录，可以访问当前页面！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><ol start="2"><li>网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;当前网站正在维护。。。&#x27;</span>)<br>  <span class="hljs-comment">// 由于没有使用next()传递给下一个中间件，所以会停留在此处</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><ol start="3"><li>自定义404页面，把中间件定义在最后面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 为客户端响应404状态码以及提示信息</span><br>  res.status(<span class="hljs-number">404</span>).send(<span class="hljs-string">&#x27;当前访问的页面是不存在的。&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="43-处理错误中间件"><a class="markdownIt-Anchor" href="#43-处理错误中间件"></a> 4.3 处理错误中间件</h2><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 创建一个错误实例并抛出</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;程序发生了未知错误！&#x27;</span>)<br>&#125;)<br><br>app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 为客户端响应500状态码以及提示信息</span><br>  res.status(<span class="hljs-number">500</span>).send(err.message)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p><code>throw new Error('程序发生了未知错误！')</code> 实际上是一个同步代码，如果异步代码在执行过程中出现了错误，这样是无法捕捉到的。这个时候需要手动的触发错误处理中间件，当异步API出错时，需要调用 <code>next()</code> 方法，并把错误传入 <code>next()</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  fs.readFile(<span class="hljs-string">&#x27;/file-does-not-exist&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) &#123;<br>      next(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.send(result)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="44-捕获错误"><a class="markdownIt-Anchor" href="#44-捕获错误"></a> 4.4 捕获错误</h2><p>在nodejs中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢？</p><p><code>try catch</code> 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。下面代码中把读取文件改造成支持异步函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>).promisify<br><span class="hljs-keyword">const</span> readFile = promisify(fs.readFile)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/aaa.js&#x27;</span>)<br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    next(err)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="45-构建模块化路由"><a class="markdownIt-Anchor" href="#45-构建模块化路由"></a> 4.5 构建模块化路由</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建路由对象</span><br><span class="hljs-keyword">const</span> home = express.Router()<br><span class="hljs-comment">// 将路由和请求路径进行匹配</span><br>app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)<br><span class="hljs-comment">// 在home路由下继续创建二级路由</span><br>home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 访问路径/home/index</span><br>  res.send(<span class="hljs-string">&#x27;欢迎来到主页！&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/9e94cc15cc9903fee57529a3f72c1c5f.png" /><h1 id="5-get参数的获取"><a class="markdownIt-Anchor" href="#5-get参数的获取"></a> 5 GET参数的获取</h1><p>Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 接收地址栏中问号后面的参数</span><br><span class="hljs-comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.query) <br>  <span class="hljs-comment">// &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;&#125;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="6-post参数的获取"><a class="markdownIt-Anchor" href="#6-post参数的获取"></a> 6 POST参数的获取</h1><p>Express中接收post请求参数需要借助第三方包 body-parser。它其实是Express官方提供的，官方为了让包体积更加小巧，将一些工具剥离出来，供开发者按需安装。<br />安装命令： <code>npm install body-parser</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入body-parser模块</span><br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br><span class="hljs-comment">// 配置body-parser模块，拦截所有请求</span><br><span class="hljs-comment">// extended: false 方法内部使用querystring模块处理请求参数的格式</span><br><span class="hljs-comment">// extended: true 方法内部使用第三方模块qs处理请求参数的格式</span><br>app.use(bodyParser.urlencoded(&#123;<span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span>&#125;))<br><span class="hljs-comment">// 接收请求</span><br>app.post(<span class="hljs-string">&#x27;/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接收请求参数</span><br>  <span class="hljs-built_in">console</span>.log(req.body)<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>注：可以直接使用<code>app.use(express.json());</code>代替body-parser。<br />【1】<a href="https://stackoverflow.com/questions/61551926/express-json-vs-body-parser">https://stackoverflow.com/questions/61551926/express-json-vs-body-parser</a><br />【2】<a href="https://cloud.tencent.com/developer/ask/37434">https://cloud.tencent.com/developer/ask/37434</a></p></blockquote><h1 id="7-express路由参数"><a class="markdownIt-Anchor" href="#7-express路由参数"></a> 7 Express路由参数</h1><p>在定义时，可以显式定义请求接收的参数，在url后面用冒号加上参数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// localhost:3000/find/123</span><br>app.get(<span class="hljs-string">&#x27;/find/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.params) <span class="hljs-comment">// &#123;id: 123&#125;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>如果要传递多个参数，可以继续添加斜杠和冒号。</p><h1 id="8-静态资源的处理"><a class="markdownIt-Anchor" href="#8-静态资源的处理"></a> 8 静态资源的处理</h1><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br>app.use(express.static(path.join(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)))<br></code></pre></div></td></tr></table></figure><p>现在，public目录下面的文件就可以访问了。</p><ul><li><a href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/images/kitten.jpg</a></li><li><a href="http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></li><li><a href="http://localhost:3000/js/app.js">http://localhost:3000/js/app.js</a></li><li><a href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/images/bg.png</a></li><li><a href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/hello.html</a></li></ul><p>除此之外，还可以控制路径，可以在添加一个参数<code>static</code>，</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-string">&#x27;static&#x27;</span>, express.static(path.join(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)))<br></code></pre></div></td></tr></table></figure><p>再访问静态资源的时候就要在url中加入<code>static</code>，如：<a href="http://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html">http://localhost:3000/static/hello.html</a>。</p><h1 id="9-跨域处理"><a class="markdownIt-Anchor" href="#9-跨域处理"></a> 9 跨域处理</h1><p>参考资料：<a href="https://juejin.cn/post/6844904126246027278#heading-1">https://juejin.cn/post/6844904126246027278#heading-1</a><br />现在如有接口：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(&#123;<br>    name: <span class="hljs-string">&#x27;syz&#x27;</span>,<br>    age: <span class="hljs-string">&#x27;18&#x27;</span>,<br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>该接口的访问地址是：<a href="http://localhost:3000/user">http://localhost:3000/user</a>。使用静态资源处理，在public文件夹中新建<code>index.html</code>。<br /><img src="https://img-blog.csdnimg.cn/img_convert/051aeede036bcaad264484b59c8751d5.png" /><br />此时通过<a href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>可以访问，在<code>body</code>中添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;<br>  fetch(<span class="hljs-string">&#x27;http://localhost:3000/user&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>再次访问<a href="http://localhost:3000/index.html">http://localhost:3000/index.html</a>，就可以在Console中看到输出的对象：<code>&#123;name: &quot;syz&quot;, age: &quot;18&quot;&#125;</code>。<br />这是数据是可以正常访问到的，此时右键<code>index.html</code>，利用vscode插件Live server打卡，该插件会启动一个以5500为端口的服务：<br /><img src="https://img-blog.csdnimg.cn/img_convert/65641336c65f576e5cc3aabe886f2520.png" /><br />访问地址为：<a href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>，此时可以发现Console无法请求到数据了，并报了跨域错误。<br /><img src="https://img-blog.csdnimg.cn/img_convert/4c2b76613205517ac580af56ff9a6510.png" /><br />处理跨域问题需要用到第三方库：<code>npm i cors</code>，在<code>server.js</code>中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入cors，返回的是一个函数，直接()执行，执行后是一个Express中间件，app.use使用它即可</span><br>app.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)())<br></code></pre></div></td></tr></table></figure><p>再访问<a href="http://127.0.0.1:5500/public/index.html">http://127.0.0.1:5500/public/index.html</a>即可获取到数据。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS是如何工作的</title>
    <link href="/2020/05/01/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <url>/2020/05/01/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-https的出现"><a class="markdownIt-Anchor" href="#1-https的出现"></a> 1 HTTPS的出现</h1><p>说到 HTTPS 就不得不先介绍 HTTP，超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接看到传输的内容，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>既然不能传输明文，那么可否用加密算法加密后再传输数据，下面分别讨论这几种情况。</p><h2 id="11-采用对称加密"><a class="markdownIt-Anchor" href="#11-采用对称加密"></a> 1.1 采用对称加密</h2><p>所谓对称加密，又叫做常规密钥密码体制，即加密密钥与解密密钥是相同的密码体制。如现在站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 向站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发送明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 使用加密密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 将明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 通过加密算法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 加密成密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 通过互联网发送至站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 收到密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 后使用解密密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 将密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 通过解密算法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 解密成明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，上述过程就是对称加密与解密的过程，需要强调的是用于加密的密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 和用于解密的密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 是同一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，如下图：</p><p><img src="https://ae01.alicdn.com/kf/H0de5f3e709c249559c272ea3c0b7212el.jpg" alt="" /></p><p>可以想象互联网中有一个黑客截取了发送的密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>，那么黑客是不是就无法解密出明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 呢？显然不是，首先客户端和服务器的交互是多对多的，互联网中海量的设备相互通信，若是为每个设备设定不同的密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 的存储可能比实际的业务还要大，所以一般情况下只制定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，所以黑客如果充当一个普通的设备的话，也是能拿到这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 的，所以采用对称加密的方式是不行的。</p><h2 id="12-采用非对称加密"><a class="markdownIt-Anchor" href="#12-采用非对称加密"></a> 1.2 采用非对称加密</h2><p>所谓非对称加密，又叫公钥密码体制，即使用不同的加密密钥与解密密钥。如现在站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 向站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发送明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">PK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 通过加密算法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 加密成密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 并通过互联网发送至站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 收到密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 后使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">SK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 通过解密算法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 解密成明文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，上述过程就是非对称加密与解密的过程，需要强调的是用于加密的公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">PK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和用于解密的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">SK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是不同的，并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>  的公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">PK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是公开的，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">SK_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 私有的，如下图：</p><p><img src="https://ae01.alicdn.com/kf/H4e8dfadb662e4c718dc55f5193f01faeq.jpg" alt="" /></p><p>非对称加密看似非常完美，但实际上有个致命的缺点，当客户端向服务器发送数据的时候数据是可以保证安全的，但服务器向客户端发送数据的时候，这时就难以保证数据的安全，首先服务器是肯定不能用公钥对数据进行加密的，因为只有私钥才能解密，而客户端是没有私钥的；其次如果服务器使用私钥进行加密，让客户端使用公钥进行解密的话，黑客也是能破解出明文，因为公钥是公开的，既然客户端能够获取公钥，黑客也能拿到公钥，所以采用非对称加密的方式也是不行的。</p><h2 id="13-寻找平衡点"><a class="markdownIt-Anchor" href="#13-寻找平衡点"></a> 1.3 寻找平衡点</h2><p>综上所述，采用对称加密和非对称加密都有致命的缺点，后来在数学家的努力之下，找到了其中的平衡点。对于对称加密来说它的缺点来自于它的密钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 只有一个；对于非对称加密来说它的缺点来自于当服务器向客户端发送数据时是不安全的，其实两者都有各自的优点，所以可以找到一种方式将两者的优势结合起来，这个平衡点就是我们先用非对称加密的方式，在服务端和客户端之间达成一个协商，协商出一个临时制定的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ，再使用对称加密使用这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 进行数据交互，通过这种方式使每次客户端和服务器之间交互产生的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 是独一无二的。</p><p>根据这个思想，对 HTTP 协议进行了改进，即安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h1 id="2-https的工作过程"><a class="markdownIt-Anchor" href="#2-https的工作过程"></a> 2 HTTPS的工作过程</h1><p>现假设客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 和服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 进行数据交互，首先客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 向 服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 索要公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，随后客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 随机定一个字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，再使用公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 进行加密成密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 并发送给服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 收到密文 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 后用其私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">SK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行解密成字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，此时客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 就和服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 协商好了对称密钥。之后的数据传送全部使用对称加密传输，使用的对称密钥就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，如下图：</p><p><img src="https://ae01.alicdn.com/kf/H5ab4cc91f74044028df7b768f082b72bw.jpg" alt="" /></p><h1 id="3-https是否无懈可击"><a class="markdownIt-Anchor" href="#3-https是否无懈可击"></a> 3 HTTPS是否无懈可击</h1><p>假设一个这样的场景，当客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 第一步向服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 索要公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时就被黑客截获了，黑客再假装成客户端向服务器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 索要公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后黑客返回客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 一个黑客公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">PK_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，随后客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 发送使用黑客公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">PK_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 加密的字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ，黑客再假装成客户端向服务器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 发送一个黑客字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">K_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，可以想象后续的客户端与服务器端的数据交互都经过了黑客，此时数据就完全泄漏了，而且还无法察觉，如下图所示：</p><p><img src="https://ae01.alicdn.com/kf/Hba6d0af5ae134fcf876c286540ac84e0s.jpg" alt="" /></p><p>所以 HTTPS 面临的最大威胁就是中间人问题，造成该问题的原因是第一步客户端在服务器端向索要公钥时就被黑客介入了，所以造成了客户端与黑客相互信任的局面，而真正欺骗客户端的就是黑客公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">PK_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，若是客户端能分辨的出公钥是否是官方的，可辨别的，那么就可以解决中间人问题，所以就引入了一项数字证书技术。</p><h2 id="31-数字证书"><a class="markdownIt-Anchor" href="#31-数字证书"></a> 3.1 数字证书</h2><p>既然出现中间人问题的原因是公钥问题，所以我们需要对所有官方正确的公钥进行认证，这个认证就是数字证书颁发机构（CA, Certificate Authority），它是是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p><p>此时双方进行协商的过程也会发生变化，首先数字证书颁发机构 CA 也拥有自己的公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{PK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>S</mi><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{SK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，当客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 向服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 索要公钥时，服务器端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 不再直接将公钥发送给客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，而是对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行加密，使用 CA 的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>S</mi><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{SK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行加密，加密后会得到一个证书 licence，客户端 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 在请求公钥时不再请求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 而是直接请求证书 licence，此时要获取公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">PK_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 只需要对证书 licence 进行解密，需要用到 CA 的公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>P</mi><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{PK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>这时可能有人会疑惑，去 CA 拿公钥的时候不是也会被中间人所截获吗？为了解决这个问题，所以我们干脆不去获取，而是直接写死在计算机中，我们的计算机中其实保存了大量 CA 机构的公钥。后续的数据交互过程就和 HTTPS 中的一样了，如下图所示：</p><p><img src="https://ae01.alicdn.com/kf/Hab82e181fa7d40b7a9544f124fa8a84eP.jpg" alt="" /></p><p>当我们访问的服务器端没有使用 CA 证书加密公钥时，浏览器通常会提示警告，此外若颁发证书的 CA 机构未得到权威认证，此时浏览器也会发出警告。</p><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>HTTPS 实际上就是在 HTTP 上增加了安全性，可以大致概括为非对称加密、对称加密、CA证书三种方式，其中使用非对称加密来获取公钥，使用对称加密来进行数据传输，使用 CA 证书来确保公钥的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MD5算法实现原理</title>
    <link href="/2020/04/16/MD5%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/16/MD5%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-md5-简介"><a class="markdownIt-Anchor" href="#1-md5-简介"></a> 1 MD5 简介</h1><p>信息摘要算法 MD5 (Message Digest 5)，数字 5 代表这是第五代算法，之前还有 MD1、MD2、MD3 和 MD4。MD5 是一种被广泛使用的密码散列函数，可以产生出一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 位（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 字节）的散列值（hash value），用于确保信息传输完整一致。</p><p>MD5 算法的特征是不可逆性，并且在计算的时候所有的数据都参与了运算，其中任何一个数据变化了都会导致计算出来的 Hash 值完全不同，所以通常用来校验数据是否正确或用作身份验证。</p><h1 id="2-md5-实现步骤"><a class="markdownIt-Anchor" href="#2-md5-实现步骤"></a> 2 MD5 实现步骤</h1><h2 id="21-将明文变为-ascii-码"><a class="markdownIt-Anchor" href="#21-将明文变为-ascii-码"></a> 2.1 将明文变为 ASCII 码</h2><p>要加密的明文：<code>China,my great country</code>。<br />ASCII码：<code>43 68 69 6E 61 2C 6D 79 20 67 72 65 61 74 20 63 6F 75 6E 74 72 79</code></p><h2 id="22-填充和附加"><a class="markdownIt-Anchor" href="#22-填充和附加"></a> 2.2 填充和附加</h2><p>对数据进行<strong>填充</strong>的目的是使任意长度的数据能够被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 整除，填充的首位是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其余位全部为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，填充后数据变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mn>512</mn><mo>−</mo><mn>64</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N*512-64)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mclose">)</span></span></span></span> 位（下图中假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则填充后要达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>448</mn></mrow><annotation encoding="application/x-tex">448</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span></span></span></span> 位）。</p><p>减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 是因为要在数据末尾<strong>附加</strong>长度项，如果数据的长度大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 位，则只取低 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 位。通过填充和附加后，整个数据变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 的整数倍。<br /><img src="https://img-blog.csdnimg.cn/20200416164628242.jpg" alt="在这里插入图片描述" style="zoom:67%;" /><br />下面对数据进行填充和附加操作，数据为<code>4368696E612C6D7920677265617420636F756E747279</code>，这段数据长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>176</mn></mrow><annotation encoding="application/x-tex">176</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span></span></span></span> 位（注意上述数据是用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 进制表示的），由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>176</mn><mo>&lt;</mo><mn>448</mn></mrow><annotation encoding="application/x-tex">176 &lt; 448</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span></span></span></span>，所以需要进行填充，共需填充 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>448</mn><mo>−</mo><mn>176</mn><mo>=</mo><mn>272</mn></mrow><annotation encoding="application/x-tex">448-176=272</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">2</span></span></span></span> 位，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 进制表示为 <code>80000....0000</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>272</mn></mrow><annotation encoding="application/x-tex">272</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">2</span></span></span></span>位），再加上数据长度项 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>176</mn></mrow><annotation encoding="application/x-tex">176</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 进制为 <code>00B0</code>，但是要凑成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 位，所以最后附加 <code>B000000000000000</code>。</p><p>填充和附加后的数据为：<code>4368696E612C6D7920677265617420636F756E747279</code> <code>80000....0000</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>272</mn></mrow><annotation encoding="application/x-tex">272</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">2</span></span></span></span>位）<code>B000000000000000</code>。总长度刚好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 位。</p><h2 id="23-分组"><a class="markdownIt-Anchor" href="#23-分组"></a> 2.3 分组</h2><p>将数据按每组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 位进行分组，每组内再分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 组，每组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位。</p><p>上述数据按要求分组后如下表，并把每组数据保存在数组 <code>x</code> 中，表中的 <code>#</code> 代表在数组中的下标：</p><table><thead><tr><th>#</th><th>数据</th></tr></thead><tbody><tr><td>0</td><td><code>6E696843</code></td></tr><tr><td>1</td><td><code>796D2C61</code></td></tr><tr><td>2</td><td><code>65726720</code></td></tr><tr><td>3</td><td><code>63207461</code></td></tr><tr><td>4</td><td><code>746E756F</code></td></tr><tr><td>…</td><td>…</td></tr><tr><td>11</td><td><code>00000000</code></td></tr><tr><td>12</td><td><code>00000000</code></td></tr><tr><td>13</td><td><code>00000000</code></td></tr><tr><td>14</td><td><code>000000B0</code></td></tr><tr><td>15</td><td><code>00000000</code></td></tr></tbody></table><h2 id="24-预处理"><a class="markdownIt-Anchor" href="#24-预处理"></a> 2.4 预处理</h2><p>首先要确定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个链接变量 <code>A、B、C、D</code>，每个变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位。</p><table><thead><tr><th>链接变量</th><th>存储形式值</th></tr></thead><tbody><tr><td><code>A</code></td><td><code>0x67452301</code></td></tr><tr><td><code>B</code></td><td><code>0xEFCDAB89</code></td></tr><tr><td><code>C</code></td><td><code>0x98BADCFE</code></td></tr><tr><td><code>D</code></td><td><code>0x10325476</code></td></tr></tbody></table><p>这四个变量看似毫无章法，其实是有规律的，由于 Windows 是基于 <strong>Little Endian</strong> 的，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端，所以我们在定义这四个变量的值的时候要按它们在内存中的存储形式进行定义，实际上这四个变量的逻辑形式是：</p><table><thead><tr><th>链接变量</th><th>逻辑形式值</th></tr></thead><tbody><tr><td><code>A</code></td><td><code>0x01234567</code></td></tr><tr><td><code>B</code></td><td><code>0x89ABCDEF</code></td></tr><tr><td><code>C</code></td><td><code>0xFEDCBA98</code></td></tr><tr><td><code>D</code></td><td><code>0x76543210</code></td></tr></tbody></table><p>仔细观察后，规律就很明显了。</p><h2 id="25-循环加工"><a class="markdownIt-Anchor" href="#25-循环加工"></a> 2.5 循环加工</h2><p>当第一轮的第一步开始处理时，将这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个变量先分别赋值到另外 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个变量 <code>oldA、oldB、oldC、oldD</code> 中，以第一轮第一步为例，对应第一轮第一步的操作函数为 <code>md5ff(a, b, c, d, x[0], 7, 0xD76AA478)</code>（<code>7</code> 用于循环左移，<code>0xD76AA478</code> 为正弦补充值），首先将 <code>b、c、d</code> 经过非线性函数 <code>(b&amp;c) | (not(b)&amp;d)</code> 计算得到<code>98BADCFE</code>后，再将这个值加上 <code>A、x[0]</code> 和 <code>0xD76AA478</code>，即 <code>67452301 + 98BADCFE + 6E696843 + D76AA478 = 45D40CBA</code>。</p><p>再将相加结果 <code>45D40CBA</code> 循环左移七位得 <code>EA065D22</code>，再加上链接变量 <code>B</code> 的值，即 <code>EA065D22 + EFCDAB89 = D9D408AB</code>，最后把这个值赋值给链接变量 <code>A</code>。</p><p>依次类推，经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 轮操作，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 个步骤后， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个链接变量变为：</p><table><thead><tr><th>链接变量</th><th>存储形式值</th></tr></thead><tbody><tr><td><code>A</code></td><td><code>0xD32A3F0D</code></td></tr><tr><td><code>B</code></td><td><code>0x0E63C780</code></td></tr><tr><td><code>C</code></td><td><code>0x469E5215</code></td></tr><tr><td><code>D</code></td><td><code>0x65C53CCA</code></td></tr></tbody></table><p>接下来要将原 <code>A、B、C、D</code> 的值和上表中处理后的<code>A、B、C、D</code> 值相加求和，将和分别赋值给<code>A、B、C、D</code>，这个时候就用到了之前的 <code>oldA、oldB、oldC、oldD</code> ，具体操作以 <code>A</code> 为例，将 <code>A</code> 与 <code>oldA</code> 相加，即 <code>D32A3F0D + 67452301 = 3A6F620E</code>，再将和赋值给 <code>A</code>。全部求和后结果如下表：</p><table><thead><tr><th>链接变量</th><th>存储形式值</th></tr></thead><tbody><tr><td><code>A</code></td><td><code>0x3A6F620E</code></td></tr><tr><td><code>B</code></td><td><code>0xFE317309</code></td></tr><tr><td><code>C</code></td><td><code>0xDF592F13</code></td></tr><tr><td><code>D</code></td><td><code>0x75F79140</code></td></tr></tbody></table><p>最后算得的散列值为：<code>0E626F3A097331FE132F59DF4091F775</code>。</p><h1 id="3-blueimp-md5-源码"><a class="markdownIt-Anchor" href="#3-blueimp-md5-源码"></a> 3 blueimp-md5 源码</h1><p><a href="https://github.com/blueimp/JavaScript-MD5">blueimp-md5</a> 是由 blueimp 实现的 JavaScript MD5 算法。阅读源码后发现他们用了很多位运算来实现整个过程，有的地方生涩难懂。源码中一共提供了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 种 API：</p><ol><li>给定一个字符串，计算得出它的 MD5 哈希值，如：<code>var hash = md5('value')</code>；</li><li>给定一个字符串，计算得出它的 HMAC-MD5 哈希值，如：<code>var hash = md5(&quot;value&quot;, &quot;key&quot;)</code>；</li><li>给定一个字符串，计算其原始 MD5 哈希值，如：<code>var hash = md5('value', null, true)</code>；</li><li>给定一个字符串和一个键值，计算其原始 HMAC-MD5 哈希值，如：<code>var hash = md5(&quot;value&quot;, &quot;key&quot;, true)</code></li></ol><p>最常用的还是第一个，下面列出 blueimp-md5 源码实现过程，只截取了关键部分。</p><p>将字符串编码为 <code>UTF-8</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Encode a string as utf-8</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstrUTF8</span> (<span class="hljs-params">input</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">unescape</span>(<span class="hljs-built_in">encodeURIComponent</span>(input))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将原始字符串转换为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 进制。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Convert a raw string to a hex string</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2hex</span> (<span class="hljs-params">input</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> hexTab = <span class="hljs-string">&#x27;0123456789abcdef&#x27;</span><br>  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">var</span> x<br>  <span class="hljs-keyword">var</span> i<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; input.length; i += <span class="hljs-number">1</span>) &#123;<br>    x = input.charCodeAt(i)<br>    output += hexTab.charAt((x &gt;&gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>) + hexTab.charAt(x &amp; <span class="hljs-number">0x0f</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> output<br>&#125;<br></code></pre></div></td></tr></table></figure><p>四个非线性函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* These functions implement the four basic operations the algorithm uses.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5cmn</span> (<span class="hljs-params">q, a, b, x, s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5ff</span> (<span class="hljs-params">a, b, c, d, x, s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> md5cmn((b &amp; c) | (~b &amp; d), a, b, x, s, t)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5gg</span> (<span class="hljs-params">a, b, c, d, x, s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> md5cmn((b &amp; d) | (c &amp; ~d), a, b, x, s, t)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5hh</span> (<span class="hljs-params">a, b, c, d, x, s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> md5cmn(b ^ c ^ d, a, b, x, s, t)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5ii</span> (<span class="hljs-params">a, b, c, d, x, s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> md5cmn(c ^ (b | ~d), a, b, x, s, t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>循环左移。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Bitwise rotate a 32-bit number to the left.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bitRotateLeft</span> (<span class="hljs-params">num, cnt</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (<span class="hljs-number">32</span> - cnt))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>求和，生成新的链接变量。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Add integers, wrapping at 2^32. This uses 16-bit operations internally</span><br><span class="hljs-comment">* to work around bugs in some JS interpreters.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeAdd</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> lsw = (x &amp; <span class="hljs-number">0xffff</span>) + (y &amp; <span class="hljs-number">0xffff</span>)<br>  <span class="hljs-keyword">var</span> msw = (x &gt;&gt; <span class="hljs-number">16</span>) + (y &gt;&gt; <span class="hljs-number">16</span>) + (lsw &gt;&gt; <span class="hljs-number">16</span>)<br>  <span class="hljs-keyword">return</span> (msw &lt;&lt; <span class="hljs-number">16</span>) | (lsw &amp; <span class="hljs-number">0xffff</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>计算 MD5 哈希值，注意该函数中的 <code>a、b、c、d</code> 和 非线性函数中的数（正弦补充值）都是以十进制表示的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Calculate the MD5 of an array of little-endian words, and a bit length.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binlMD5</span> (<span class="hljs-params">x, len</span>) </span>&#123;<br>  <span class="hljs-comment">/* append padding */</span><br>  x[len &gt;&gt; <span class="hljs-number">5</span>] |= <span class="hljs-number">0x80</span> &lt;&lt; (len % <span class="hljs-number">32</span>)<br>  x[((len + <span class="hljs-number">64</span>) &gt;&gt;&gt; <span class="hljs-number">9</span> &lt;&lt; <span class="hljs-number">4</span>) + <span class="hljs-number">14</span>] = len<br><br>  <span class="hljs-keyword">var</span> i<br>  <span class="hljs-keyword">var</span> olda<br>  <span class="hljs-keyword">var</span> oldb<br>  <span class="hljs-keyword">var</span> oldc<br>  <span class="hljs-keyword">var</span> oldd<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1732584193</span><br>  <span class="hljs-keyword">var</span> b = -<span class="hljs-number">271733879</span><br>  <span class="hljs-keyword">var</span> c = -<span class="hljs-number">1732584194</span><br>  <span class="hljs-keyword">var</span> d = <span class="hljs-number">271733878</span><br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x.length; i += <span class="hljs-number">16</span>) &#123;<br>    olda = a<br>    oldb = b<br>    oldc = c<br>    oldd = d<br><br>    a = md5ff(a, b, c, d, x[i], <span class="hljs-number">7</span>, -<span class="hljs-number">680876936</span>)<br>    d = md5ff(d, a, b, c, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">389564586</span>)<br>    c = md5ff(c, d, a, b, x[i + <span class="hljs-number">2</span>], <span class="hljs-number">17</span>, <span class="hljs-number">606105819</span>)<br>    b = md5ff(b, c, d, a, x[i + <span class="hljs-number">3</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1044525330</span>)<br>    a = md5ff(a, b, c, d, x[i + <span class="hljs-number">4</span>], <span class="hljs-number">7</span>, -<span class="hljs-number">176418897</span>)<br>    d = md5ff(d, a, b, c, x[i + <span class="hljs-number">5</span>], <span class="hljs-number">12</span>, <span class="hljs-number">1200080426</span>)<br>    c = md5ff(c, d, a, b, x[i + <span class="hljs-number">6</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1473231341</span>)<br>    b = md5ff(b, c, d, a, x[i + <span class="hljs-number">7</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">45705983</span>)<br>    a = md5ff(a, b, c, d, x[i + <span class="hljs-number">8</span>], <span class="hljs-number">7</span>, <span class="hljs-number">1770035416</span>)<br>    d = md5ff(d, a, b, c, x[i + <span class="hljs-number">9</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">1958414417</span>)<br>    c = md5ff(c, d, a, b, x[i + <span class="hljs-number">10</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">42063</span>)<br>    b = md5ff(b, c, d, a, x[i + <span class="hljs-number">11</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1990404162</span>)<br>    a = md5ff(a, b, c, d, x[i + <span class="hljs-number">12</span>], <span class="hljs-number">7</span>, <span class="hljs-number">1804603682</span>)<br>    d = md5ff(d, a, b, c, x[i + <span class="hljs-number">13</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">40341101</span>)<br>    c = md5ff(c, d, a, b, x[i + <span class="hljs-number">14</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1502002290</span>)<br>    b = md5ff(b, c, d, a, x[i + <span class="hljs-number">15</span>], <span class="hljs-number">22</span>, <span class="hljs-number">1236535329</span>)<br><br>    a = md5gg(a, b, c, d, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">5</span>, -<span class="hljs-number">165796510</span>)<br>    d = md5gg(d, a, b, c, x[i + <span class="hljs-number">6</span>], <span class="hljs-number">9</span>, -<span class="hljs-number">1069501632</span>)<br>    c = md5gg(c, d, a, b, x[i + <span class="hljs-number">11</span>], <span class="hljs-number">14</span>, <span class="hljs-number">643717713</span>)<br>    b = md5gg(b, c, d, a, x[i], <span class="hljs-number">20</span>, -<span class="hljs-number">373897302</span>)<br>    a = md5gg(a, b, c, d, x[i + <span class="hljs-number">5</span>], <span class="hljs-number">5</span>, -<span class="hljs-number">701558691</span>)<br>    d = md5gg(d, a, b, c, x[i + <span class="hljs-number">10</span>], <span class="hljs-number">9</span>, <span class="hljs-number">38016083</span>)<br>    c = md5gg(c, d, a, b, x[i + <span class="hljs-number">15</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">660478335</span>)<br>    b = md5gg(b, c, d, a, x[i + <span class="hljs-number">4</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">405537848</span>)<br>    a = md5gg(a, b, c, d, x[i + <span class="hljs-number">9</span>], <span class="hljs-number">5</span>, <span class="hljs-number">568446438</span>)<br>    d = md5gg(d, a, b, c, x[i + <span class="hljs-number">14</span>], <span class="hljs-number">9</span>, -<span class="hljs-number">1019803690</span>)<br>    c = md5gg(c, d, a, b, x[i + <span class="hljs-number">3</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">187363961</span>)<br>    b = md5gg(b, c, d, a, x[i + <span class="hljs-number">8</span>], <span class="hljs-number">20</span>, <span class="hljs-number">1163531501</span>)<br>    a = md5gg(a, b, c, d, x[i + <span class="hljs-number">13</span>], <span class="hljs-number">5</span>, -<span class="hljs-number">1444681467</span>)<br>    d = md5gg(d, a, b, c, x[i + <span class="hljs-number">2</span>], <span class="hljs-number">9</span>, -<span class="hljs-number">51403784</span>)<br>    c = md5gg(c, d, a, b, x[i + <span class="hljs-number">7</span>], <span class="hljs-number">14</span>, <span class="hljs-number">1735328473</span>)<br>    b = md5gg(b, c, d, a, x[i + <span class="hljs-number">12</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">1926607734</span>)<br><br>    a = md5hh(a, b, c, d, x[i + <span class="hljs-number">5</span>], <span class="hljs-number">4</span>, -<span class="hljs-number">378558</span>)<br>    d = md5hh(d, a, b, c, x[i + <span class="hljs-number">8</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">2022574463</span>)<br>    c = md5hh(c, d, a, b, x[i + <span class="hljs-number">11</span>], <span class="hljs-number">16</span>, <span class="hljs-number">1839030562</span>)<br>    b = md5hh(b, c, d, a, x[i + <span class="hljs-number">14</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">35309556</span>)<br>    a = md5hh(a, b, c, d, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">4</span>, -<span class="hljs-number">1530992060</span>)<br>    d = md5hh(d, a, b, c, x[i + <span class="hljs-number">4</span>], <span class="hljs-number">11</span>, <span class="hljs-number">1272893353</span>)<br>    c = md5hh(c, d, a, b, x[i + <span class="hljs-number">7</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">155497632</span>)<br>    b = md5hh(b, c, d, a, x[i + <span class="hljs-number">10</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">1094730640</span>)<br>    a = md5hh(a, b, c, d, x[i + <span class="hljs-number">13</span>], <span class="hljs-number">4</span>, <span class="hljs-number">681279174</span>)<br>    d = md5hh(d, a, b, c, x[i], <span class="hljs-number">11</span>, -<span class="hljs-number">358537222</span>)<br>    c = md5hh(c, d, a, b, x[i + <span class="hljs-number">3</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">722521979</span>)<br>    b = md5hh(b, c, d, a, x[i + <span class="hljs-number">6</span>], <span class="hljs-number">23</span>, <span class="hljs-number">76029189</span>)<br>    a = md5hh(a, b, c, d, x[i + <span class="hljs-number">9</span>], <span class="hljs-number">4</span>, -<span class="hljs-number">640364487</span>)<br>    d = md5hh(d, a, b, c, x[i + <span class="hljs-number">12</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">421815835</span>)<br>    c = md5hh(c, d, a, b, x[i + <span class="hljs-number">15</span>], <span class="hljs-number">16</span>, <span class="hljs-number">530742520</span>)<br>    b = md5hh(b, c, d, a, x[i + <span class="hljs-number">2</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">995338651</span>)<br><br>    a = md5ii(a, b, c, d, x[i], <span class="hljs-number">6</span>, -<span class="hljs-number">198630844</span>)<br>    d = md5ii(d, a, b, c, x[i + <span class="hljs-number">7</span>], <span class="hljs-number">10</span>, <span class="hljs-number">1126891415</span>)<br>    c = md5ii(c, d, a, b, x[i + <span class="hljs-number">14</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1416354905</span>)<br>    b = md5ii(b, c, d, a, x[i + <span class="hljs-number">5</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">57434055</span>)<br>    a = md5ii(a, b, c, d, x[i + <span class="hljs-number">12</span>], <span class="hljs-number">6</span>, <span class="hljs-number">1700485571</span>)<br>    d = md5ii(d, a, b, c, x[i + <span class="hljs-number">3</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1894986606</span>)<br>    c = md5ii(c, d, a, b, x[i + <span class="hljs-number">10</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1051523</span>)<br>    b = md5ii(b, c, d, a, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">2054922799</span>)<br>    a = md5ii(a, b, c, d, x[i + <span class="hljs-number">8</span>], <span class="hljs-number">6</span>, <span class="hljs-number">1873313359</span>)<br>    d = md5ii(d, a, b, c, x[i + <span class="hljs-number">15</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">30611744</span>)<br>    c = md5ii(c, d, a, b, x[i + <span class="hljs-number">6</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1560198380</span>)<br>    b = md5ii(b, c, d, a, x[i + <span class="hljs-number">13</span>], <span class="hljs-number">21</span>, <span class="hljs-number">1309151649</span>)<br>    a = md5ii(a, b, c, d, x[i + <span class="hljs-number">4</span>], <span class="hljs-number">6</span>, -<span class="hljs-number">145523070</span>)<br>    d = md5ii(d, a, b, c, x[i + <span class="hljs-number">11</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1120210379</span>)<br>    c = md5ii(c, d, a, b, x[i + <span class="hljs-number">2</span>], <span class="hljs-number">15</span>, <span class="hljs-number">718787259</span>)<br>    b = md5ii(b, c, d, a, x[i + <span class="hljs-number">9</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">343485551</span>)<br><br>    a = safeAdd(a, olda)<br>    b = safeAdd(b, oldb)<br>    c = safeAdd(c, oldc)<br>    d = safeAdd(d, oldd)<br>  &#125;<br>  <span class="hljs-keyword">return</span> [a, b, c, d]<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="4-遗留的问题"><a class="markdownIt-Anchor" href="#4-遗留的问题"></a> 4 遗留的问题</h1><h2 id="41-四个非线性函数是如何设计的"><a class="markdownIt-Anchor" href="#41-四个非线性函数是如何设计的"></a> 4.1 四个非线性函数是如何设计的</h2><p>在循环加工中，<code>(b&amp;c) | (not(b)&amp;d) = 98BADCFE</code>，即为一次非线性函数计算。</p><table><thead><tr><th>#</th><th>非线性函数</th></tr></thead><tbody><tr><td>1</td><td><code>F(X,Y,Z) = (X &amp; Y) | ((~X) &amp; Z);</code></td></tr><tr><td>2</td><td><code>G(X,Y,Z) = (X &amp; Z) | (Y &amp; (~Z));</code></td></tr><tr><td>3</td><td><code>H(X,Y,Z) = X ^ Y ^ Z;</code></td></tr><tr><td>4</td><td><code>I(X,Y,Z) = Y ^ (X | (~Z));</code></td></tr></tbody></table><p>这四个非线性函数分别被封装到四个操作函数中，即循环加工中的 <code>md5ff</code> 函数就为操作函数之一，还有 <code>md5gg</code>、<code>md5hh</code> 和 <code>md5ii</code>。</p><h2 id="42-循环左移偏移量是如何设计的"><a class="markdownIt-Anchor" href="#42-循环左移偏移量是如何设计的"></a> 4.2 循环左移偏移量是如何设计的</h2><p>四个操作函数中，都附带了参数作为循环左移偏移量，阅读代码后，发现循环左移偏移量分为如下四组：</p><table><thead><tr><th>#</th><th>左循环偏移量</th></tr></thead><tbody><tr><td>1</td><td><code>7, 12, 17, 22</code></td></tr><tr><td>2</td><td><code>5, 9, 14, 20</code></td></tr><tr><td>3</td><td><code>4, 11, 16, 23</code></td></tr><tr><td>4</td><td><code>6, 10, 15, 21</code></td></tr></tbody></table><h2 id="43-正弦补充值是如何设计的"><a class="markdownIt-Anchor" href="#43-正弦补充值是如何设计的"></a> 4.3 正弦补充值是如何设计的</h2><p>四个操作函数中，最后一个参数为正弦补充值，下面是十进制表示：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = md5ff(a, b, c, d, x[i], <span class="hljs-number">7</span>, -<span class="hljs-number">680876936</span>)<br>d = md5ff(d, a, b, c, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">389564586</span>)<br>      ...<br></code></pre></div></td></tr></table></figure><p>转换为十六进制表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = md5ff(a, b, c, d, x[i], <span class="hljs-number">7</span>, <span class="hljs-number">0xD76AA478</span>)<br>d = md5ff(d, a, b, c, x[i + <span class="hljs-number">1</span>], <span class="hljs-number">12</span>, <span class="hljs-number">0xE8C7B756</span>)<br>      ...<br></code></pre></div></td></tr></table></figure><h1 id="5-md5在线计算"><a class="markdownIt-Anchor" href="#5-md5在线计算"></a> 5 MD5在线计算</h1> <iframe   height=360  width=100%  src="https://syzdev.gitee.io/page/p/md5.html"   frameborder=0  > </iframe><h1 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6 总结</h1><p>目前只对 MD5 算法有个初步的了解，而上面遗留的问题正是 MD5 算法的核心实现部分，不禁让人感叹算法设计者的脑洞。</p><p>从个人目前的认知来看，算法设计的数据和计算函数，目的只有一个，就是想方设法的打乱数据并直接让每一位都参与进来，这也就是为什么任何一位的变化，都会影响最后的哈希值，如明文：<code>Hello syzdev</code>的哈希值为：<code>704558b48d6370fb71533d5ae50727b4</code>，在改动其中一个字母后明文变为 <code>Hallo syzdev</code> ，其产生的哈希值为：<code>2433084e178a2331d40c2ea16fd664fa</code>，这两个哈希值看起来找不出有任何关联，即使两者的明文仅有一个字母差别。</p><p>MD5 将整个数据拆分成多个组，再由每个组内分别计算累加，有些资料将分组过程分为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 步，即先将整个数据按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 位分块，再把每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 位分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 位数据块，最后将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 位的数据块依次送到不同的散列函数进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 轮计算。每一轮又都按 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位的小数据块进行复杂的运算，一直到最后计算出 MD5 报文摘要代码，这也就是为什么 MD5 能把不定长的数据最后都变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 位的哈希值。</p><p>可以发现，MD5 的处理函数，包括非线性函数和操作函数都包含了多个参数，而且还是变动的参数，这也就保证了 MD5 是个不可逆的算法。举个简单的例子，如有函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">z=f(x)=5*x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，此时知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">z=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，那么显然得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>；如函数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">z=f(x, y)=x*y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，此时知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">z=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，这种情况下是无法推断出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的值的，这样也就保证了 MD5 算法具有不可逆性。</p><p>正是因为 MD5 算法具有不可逆性，所以目前存在的破解算法都不是恢复明文，而是只要能找到能生成此摘要的其中一个原文即可，这种破解方法叫做“碰撞”。如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">H(A) = M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">H(B) = M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 为破解结果，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 可能相等，也可能不等。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第十一章：大容量存储</title>
    <link href="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-磁盘结构"><a class="markdownIt-Anchor" href="#1-磁盘结构"></a> 1 磁盘结构</h1><p>文件是放在磁盘上的，因此磁盘的性能是对操作文件有很大的影响。下图是一个磁盘的结构示意图，很多个磁盘 <code>platter</code> 围绕着一个轴 <code>spindle</code> 旋转，磁盘旁边有磁柱 <code>arm assembly</code>，磁柱上有磁臂 <code>arm</code>，磁臂的末端有磁头 <code>read-write head</code>，每个磁头就可以访问盘面上的相关信息：<br /><img src="https://img-blog.csdnimg.cn/20200321165342323.png" alt="在这里插入图片描述" style="zoom: 40%;" /><br />对磁盘划分时，我们把磁盘划分为很多个同心的圆环叫做磁道 <code>track</code>，每个磁道上又划分了很多等大小的块叫扇区 <code>sector</code>，在各个同心圆环上同一个磁道上的磁盘叫做柱面 <code>cylinder</code>。</p><blockquote><p>磁盘储存数据的原理和盒式磁带类似，只不过盒式磁带上存储是模拟格式的音乐，而硬盘上存储的是数字格式的数据。写入时，磁头线圈上加电，在周围产生磁场，磁化其下的磁性材料；电流的方向不同，所以磁场的方向也不同，可以表示 <code>0</code> 和 <code>1</code> 的区别。读取时，磁头线圈切割磁场线产生感应电流，磁性材料的磁场方向不同，所以产生的感应电流方向也不同。</p></blockquote><p>若干磁盘绕枢轴高速旋转，目前主流磁盘转速 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7200</mn></mrow><annotation encoding="application/x-tex">7200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 转/分；我们在定位磁盘上的某个记录时，往往需要如下三个参数：</p><ul><li><strong>柱面号</strong>：各盘面所有的读写头同时移动，并定位在同样的垂直位置的磁道上，这些磁道形成了一个柱面。由外向内是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mi mathvariant="normal">，</mi><mo>…</mo><mo>…</mo><mo separator="true">,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">0,1,2，……,L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span></span></span></span>；</li><li><strong>磁头号</strong>：磁盘的全部有效盘面从上到下依次编号：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mi mathvariant="normal">，</mi><mo>…</mo><mo>…</mo><mo separator="true">,</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">0,1,2，……,H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>。磁头号与盘面号是相对应的；</li><li><strong>扇区号</strong>：将各盘面分割成若干大小相等的扇区，编号：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mi mathvariant="normal">，</mi><mo>…</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">0,1,2,3，……,N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>。</li></ul><p>磁盘设备是以一种逻辑块的一维大数组的形式编址的，这里的逻辑块是传输的最小单位。逻辑块的一维数组映射到磁盘上一些相连的扇区。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 扇区是最外边柱面的第一个磁道的第一个扇区。数据首先都映射到一个磁道，其余的数据映射到同一柱面的其他磁道，然后按照从外向里的顺序映射到其余的柱面。</p><p>磁盘 I/O 速度的高低，将直接影响文件系统的性能。提高磁盘 I/O 速度的主要途径有：</p><ul><li>选择性能好的磁盘；</li><li>设置磁盘高速缓冲区；</li><li>采用好的磁盘调度算法。</li></ul><p>前两种方法都是在硬件上下功夫，最后一种方法是可以由操作系统来控制的，因此我们主要讨论磁盘调度算法。</p><p>好的磁盘调度算法可以缩短磁盘的访问时间，磁盘的访问时间分为如下三种：</p><ul><li><strong>寻道时间 Ts</strong>：把<strong>磁头</strong>从当前位置移动到指定<strong>磁道</strong>上所经历的时间，它与磁盘转速、移动的磁道数有关；</li><li><strong>旋转延迟时间 Tr</strong>：指定<strong>扇区</strong>移动到<strong>磁头</strong>下面所经历的时间；</li><li><strong>传输时间 Tt</strong>：指把数据从磁盘读出，或向磁盘写入数据所经历的时间。</li></ul><h1 id="2-磁盘调度"><a class="markdownIt-Anchor" href="#2-磁盘调度"></a> 2 磁盘调度</h1><p>在上面提到的磁盘访问三个时间中，操作系统能够改变的时间只有<strong>寻道时间</strong>，在设计磁盘调度算法时，目的就是为了减少寻道时间（寻道距离）。</p><h2 id="21-先来先服务fcfs"><a class="markdownIt-Anchor" href="#21-先来先服务fcfs"></a> 2.1 先来先服务（FCFS）</h2><p>先来先服务调度算法的思想如字面意思一样，假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在 <code>53</code>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321174408850.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />根据磁头移动的轨迹图，可以计算出磁头总共移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>640</mn></mrow><annotation encoding="application/x-tex">640</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span></span></span></span> 个柱面的距离。</p><h2 id="22-最短寻道时间优先sstf"><a class="markdownIt-Anchor" href="#22-最短寻道时间优先sstf"></a> 2.2 最短寻道时间优先（SSTF）</h2><p>最短寻道时间优先的思想就是选择从当前磁头位置所需寻道时间最短的请求，假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在<code>53</code>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321174719647.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />根据磁头移动的轨迹图，可以计算出磁头总共移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>208</mn></mrow><annotation encoding="application/x-tex">208</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">8</span></span></span></span> 个柱面的距离。最短寻道时间优先算法思想类似于短作业优先算法，有可能引起某些请求的饥饿。</p><h2 id="23-扫描算法scan"><a class="markdownIt-Anchor" href="#23-扫描算法scan"></a> 2.3 扫描算法（SCAN）</h2><p>为了解决最短寻道时间优先算法造成的饥饿问题，这里引入了扫描算法，它不仅考虑到欲访问的磁道与磁头当前位置间的距离，更优先考虑的是磁头当前的移动方向。算法所选择的访问对象应当是与磁头当前的移动方向一致且距离最近的。具体来说就是磁头从磁盘的一端开始向另一端移动，沿途响应访问请求，直到到达了磁盘的另一端，此时磁头反向移动并继续响应服务请求。由于扫描算法类似于现实中的电梯工作过程，有时也称为<strong>电梯算法</strong> 。</p><p>假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在 <code>53</code>  且<strong>朝磁道号减小的方向移动</strong>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321175059712.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />根据磁头移动的轨迹图，可以计算出磁头总共移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>236</mn></mrow><annotation encoding="application/x-tex">236</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mord">6</span></span></span></span> 个柱面的距离。扫描算法存在着等待问题，也就是若磁头朝一个方向移动时，又来了大量另一方向的请求，那么这些请求就要等待较长时间磁头才能过来。</p><p>为了解决这个问题，引入了 <strong>C-SCAN</strong>  算法，C 的意思就是循环的意思，它提供比扫描算法更均衡的等待时间。它的办法是磁头从磁盘的一段向另一端移动，沿途响应请求。<strong>当它到了另一端，就立即回到磁盘的开始处，在返回的途中不响应任何请求。</strong></p><p>假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在 <code>53</code> 且<strong>朝磁道号增大的方向移动</strong>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321175627924.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><p>不管是 <strong>SCAN</strong> 算法还是 <strong>C-SCAN</strong>算法，都需要磁头从一端移到另外一端，如上图，其实没有必要返回到 <code>0</code> 处，再到 <code>14</code>，可以直接达到 <code>14</code> 后就转向，为了解决这个问题，引入了 <strong>LOOK</strong> 算法，它的办法是磁臂在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的一端。</p><p>假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在 <code>53</code> 且<strong>朝磁道号减小的方向移动</strong>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321180033510.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />根据磁头移动的轨迹图，可以计算出磁头总共移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>198</mn></mrow><annotation encoding="application/x-tex">198</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">8</span></span></span></span> 个柱面的距离。</p><p>此外还有 <strong>C-LOOK</strong> 算法是对 <strong>C-SCAN</strong> 算法的改进，<strong>C-LOOK</strong> 的办法是让磁臂在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的一端。</p><p>假设磁盘的请求序列为 <code>98, 183, 37, 122, 14, 124, 65, 67</code> ，且磁头当前的位置在 <code>53</code>  且<strong>朝磁道号增大的方向移动</strong>，磁头移动轨迹示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200321180326410.png" alt="在这里插入图片描述" /></p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第十章：文件系统</title>
    <link href="/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件概念及文件逻辑结构"><a class="markdownIt-Anchor" href="#1-文件概念及文件逻辑结构"></a> 1 文件概念及文件逻辑结构</h1><p>文件对用户来说是连续的逻辑地址空间，它是存储在磁盘上的，文件是记录在外存上的具有名字的相关信息的集合，文件里面通常保存数据或程序。</p><h2 id="11-文件的分类"><a class="markdownIt-Anchor" href="#11-文件的分类"></a> 1.1 文件的分类</h2><p>文件的分类可以按照如下类别来分：</p><ul><li>按用途分类可以分为：系统文件，库文件，用户文件；</li><li>按按信息保存期限分类可以分为：临时文件，永久文件，档案文件；</li><li>按文件的保护方式分类可以分为：只读文件，读写文件，只执行文件；</li><li>按文件的逻辑结构分类可以分为：流式文件，记录式文件；</li><li>按文件的物理结构分类可以分为：顺序（连续）文件，链接文件，索引文件；</li><li>按信息流向分类可以分为：输入文件，输出文件，输入/输出文件 (存储设备)；</li><li>按文件中的数据分类可以分为：源文件，目标文件，可执行文件；</li><li>按文件的性质分类可以分为：普通文件，目录文件，特殊文件。</li></ul><h2 id="12-文件的属性"><a class="markdownIt-Anchor" href="#12-文件的属性"></a> 1.2 文件的属性</h2><p>无论将文件如何来分类，文件都有一些共性的东西，我们称之为文件的属性，通常有如下属性：</p><ul><li>文件名：唯一的以人们可以理解的方式保存的信息；</li><li>类型：需要可以支持多种类型的系统；</li><li>位置：指向文件在设备上的存储位置的指针；</li><li>大小：当前文件的大小；</li><li>保护：控制对文件的读取，改写和执行的权限；</li><li>时间，日期和用户身份：保护和安全需要的数据。</li></ul><p>上述的这些文件属性信息会保存在磁盘上的目录结构中。</p><h2 id="13-文件结构"><a class="markdownIt-Anchor" href="#13-文件结构"></a> 1.3 文件结构</h2><p>用户和文件系统往往从不同的角度对待同一个文件的：</p><ul><li><strong>用户</strong>：从使用的角度，按信息的使用和处理方式组织文件；</li><li><strong>文件系统</strong>：从文件的存储和检索的角度，根据用户对文件的存取方式和存储介质的特性组织文件，决定用户文件存放在存储介质上的方式。</li></ul><p>这样就导致了文件有两种形式的结构，即文件的逻辑结构和文件的物理结构：</p><ul><li><strong>逻辑结构</strong>：用户对文件的组织结构；</li><li><strong>物理结构</strong>：文件在外存储器上的存储结构。</li></ul><p>物理结构直接影响存储空间的使用和检索文件信息的速度，逻辑文件保存到存储介质上的工作由文件系统来做，这样可减轻用户的负担。</p><p>文件从<strong>逻辑结构</strong>上分成二种形式，一种是<strong>无结构的流式文件</strong>，另一种是<strong>有结构的记录式文件</strong>：</p><ul><li><strong>流式文件</strong>：指对文件内信息不再划分单位，它是依次的一串字符流构成的文件；</li><li><strong>记录式文件</strong>：是用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位称为一个逻辑记录（简称记录）。记录的长度可分为定长和不定长记录两类。</li></ul><p>我们重点讨论的是<strong>记录式的文件</strong>，记录文件有顺序、索引、索引顺序文件几种。</p><ul><li><strong>顺序文件</strong>：顺序文件的所有记录按键值的约定次序组织，记录可以是定长的，也可以是变长的，顺序文件常用于批量记录读取。对于定长记录文件，若要查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个记录，可根据下式得到相对于第一个记录首址的地址：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi><mo>∗</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">A_i =i*d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 为记录的长度）。对于非定长记录文件，若要查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个记录，则需要有每个记录的长度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mo>∑</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i =∑d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 为记录的长度），不支持直接存取。</li><li><strong>索引文件</strong>：为解决非定长记录文件无法直接存取问题，往往建立一张索引表，记录下每个记录的长度及指向该记录的指针，从而方便了直接存取，索引表就类似于书的目录，指明了每个章节都在哪一页。索引文件对主文件中的记录按需要的数据项（一个或几个）建索引表，为每个记录设置一个表项，索引文件本身是顺序文件组织。</li><li><strong>索引顺序文件</strong>：事实上索引文件给每个数据项建立索引表这样的开销是比较大的，于是就有了索引顺序文件， 索引顺序文件先将顺序文件中的所有记录分为若干个组；再为顺序文件建立一张索引表，表中记录每个组的第一个记录，该索引项包含记录的键值和指向该记录的指针。它是顺序文件和索引文件的结合，检索时，先根据关键字去检索索引表，找到该记录所在组的第一个记录的位置，然后再利用顺序查找法去查找主文件，找到所需记录。如下图，给每个姓名首字母都分了组，然后在索引表中只用保存每个组的首地址即可，找到首地址后，再在组内进行顺序查找：<br /><img src="https://img-blog.csdnimg.cn/20200321133758895.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li></ul><h1 id="2-文件访问方式"><a class="markdownIt-Anchor" href="#2-文件访问方式"></a> 2 文件访问方式</h1><p>前面提到文件有多种存储结构，在访问文件时，所采用的方式也是和文件的组织方式密切相关，常用的存取方式有如下两种：</p><ul><li>顺序存取 (Sequential access)；</li><li>直接/随机存取 (Direct access)。</li></ul><h2 id="21-顺序存取"><a class="markdownIt-Anchor" href="#21-顺序存取"></a> 2.1 顺序存取</h2><p>顺序存取是最简单的访问方式，它就是按照文件信息的逻辑顺序依次存取：</p><ul><li>在记录文件中：按记录的排列顺序来存取；</li><li>在流式文件中：反映为当前读写指针的变化，在存取完一段信息后，读写指针自动加上这段信息的长度，以便指出下次存取时的位置。</li></ul><p>顺序存储示意图如下图所示，<strong>当前指针 (Current position)</strong> 可以向后读，也可以回到起始位置：<br /><img src="https://img-blog.csdnimg.cn/20200321134451787.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><h2 id="22-直接随机存取"><a class="markdownIt-Anchor" href="#22-直接随机存取"></a> 2.2 直接/随机存取</h2><p>直接/随机存取可以直接定位到文件中的任何一个记录，而不需要像顺序存取一样要把路径中的所有记录过一遍。</p><p>对于连续文件 (固定长度)，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个记录的地址 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">addr_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为首记录地址，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 为记录长度) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>p</mi><mi>t</mi><mi>r</mi><mo>=</mo><mi>a</mi><mi>d</mi><mi>d</mi><msub><mi>r</mi><mn>0</mn></msub><mo>+</mo><mi>i</mi><mo>∗</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">rptr=addr_0+i*L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，在非定长文件中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 的值不固定，所以<strong>非定长文件不支持随机存储</strong>。</p><p>对于索引文件，是支持随机存取的，因为我们可以先随机查找索引表，再取地址。</p><h2 id="23-文件的存储设备"><a class="markdownIt-Anchor" href="#23-文件的存储设备"></a> 2.3 文件的存储设备</h2><p>文件的访问方式不仅和文件的存储方式有关，还和文件的存储设备有关，因为文件时保存在存储设备上的，文件自身也带有物理设备的特性。</p><p>文件的存储设备主要有磁带，磁盘，光盘等，存储设备的特性可以决定文件的存取方法，对于上述的几种存储设备，它们都是以块为单位存储数据的，因此文件的存储设备常常划分为若干大小相等的物理块，以块为单位进行信息的存储、传输。</p><p>以磁带为例，磁带可以永久保存大容量数据，它是一种顺序存取设备，即前面的物理块被存取访问之后，才能存取后续物理块的内容。磁带存取速度较慢：主要用于后备存储，或存储不经常用的信息，或用于传递数据的介质，现在磁带已经基本上被淘汰了。下图是磁带存储示意图：<br /><img src="https://img-blog.csdnimg.cn/20200321135504685.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />再以磁盘为例，磁盘是一种随机存储设备，它既可以顺序存取，也可以随机存取。它可以直接定位到某个磁道上的某个扇区，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200321135647401.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h1 id="3-文件的物理结构"><a class="markdownIt-Anchor" href="#3-文件的物理结构"></a> 3 文件的物理结构</h1><p>用户按逻辑结构使用文件，文件的物理结构对用户来说是不必关心的，但对文件系统来说却是至关重要的，因为它直接影响存储空间的使用和检索文件信息的速度。文件系统按物理结构管理文件，当用户请求读写文件时，文件系统必须实现文件的逻辑结构与物理结构之间的转换。</p><p>文件的物理结构指的是文件在外存的存放组织形式，文件的物理结构与存储设备的特性有很大关系，前面提到过文件的存储设备通常划分为大小相等的物理块，物理块是分配及传输信息的基本单位，一个物理块中可以存放若干个逻辑记录，一个逻辑记录也可以存放在若干个物理块中。</p><p>所以文件的物理结构取决于外存的分配方式，当采用连续分配方式时，就是<strong>顺序结构</strong>；当采用链接分配方式时，就是<strong>链接结构</strong>；当采用索引分配方式时，就是<strong>索引结构</strong>。</p><h2 id="31-顺序结构"><a class="markdownIt-Anchor" href="#31-顺序结构"></a> 3.1 顺序结构</h2><p>这是最简单的物理文件结构，它将逻辑上连续的文件信息依次存放在外存连续的物理块中。如下图表示磁盘的存储空间，当文件要存储的时候，就为它找一段连续的存储空间存放，图中相同颜色的物理块表示一个文件，可以发现它们都是连续存放的。当我们需要找到某个文件的时候，要知道文件的首地址和长度，而这两个值都是保存在目录中的：<br /><img src="https://img-blog.csdnimg.cn/20200321141734474.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />在这种分配方式下，每一个文件占用一个连续的磁盘块的集合，它的实现也非常简单，只需要起始块号和长度。同时它也可以随机存取，因为目录中保存了起始地址和长度，可以直接定位到某个文件。若是存储在磁盘中，其所需的磁盘寻道次数和寻道时间也比较少。</p><p>这种分配方式也有不足的地方，如现在有一个文件需要占据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个物理块，若查询内存剩余容量可以发现剩余有 $15 $个内存块（以上图为例），但是依然无法分配，因为并没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个<strong>连续</strong>的物理块，这个时候就出现了<strong>外碎片</strong>问题。</p><p>另外这种分配方式下<strong>文件不能动态增长</strong>，由于分配方式时顺序的，所以存储的方向也是固定的，如果某个文件要添加内容，可能导致物理块不够用，比如文件 <code>tr</code> 想增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个物理块，就无法完成。</p><h2 id="32-链接结构"><a class="markdownIt-Anchor" href="#32-链接结构"></a> 3.2 链接结构</h2><p>顺序结构最大的问题就是外碎片问题，造成这个问题的主要原因就是顺序分配，参照内存中解决外碎片的方法，文件的物理结构也可以采用离散的分配方式，即采用链接结构。</p><p>在链接分配方式下按所需分配磁盘块，通过链接指针链接在一起，如下图只需要知道起始块和最后一块即可：<br /><img src="https://img-blog.csdnimg.cn/2020032114561627.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />可以发现一个文件的物理块分散在磁盘的各个地方，在这种分配方式下<strong>消除了外碎片问题</strong>，但是缺点是<strong>无法支持随机存取</strong>了，若想知道文件的逻辑第三个物理块，则必须从首个物理块开始找到第三个块，而不能直接定位到第三个物理块。同时由于是指针链接，<strong>指针占据了一定的空间</strong>，而且存取速度较慢，物理块离散的分布，在磁盘存储中会带来更多的寻道次数和寻道时间。另外在这种分配方式下，只要磁盘中还有空间，文件时可以动态增长的。</p><p>解决指针占据空间的问题可以将多个块组成簇，以簇为单位分配，指针占用百分比减少，但增加内碎片，比如规定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个物理块为一个簇，每次分配都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个物理块为单位分配。</p><p>为了支持随机存取，引入了<strong>文件分配表FAT (File allocation table )</strong>，每个磁盘会有一张文件分配表，里面的表项是和磁盘的物理块个数是一一对应的，每个表项存的内容就是该物理块的下一个物理块在什么地方，如下图所示，要找到某个文件只需要知道文件的起始地址就可以了，这样就间接的实现了随机存取，若要寻找文件逻辑上的第三个物理块，则只需要查询文件分配表即可，查找速度会非常快。：<br /><img src="https://img-blog.csdnimg.cn/20200321150927147.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><h2 id="33-索引结构"><a class="markdownIt-Anchor" href="#33-索引结构"></a> 3.3 索引结构</h2><p>回顾顺序结构和链接结构，顺序结构支持随机存取，但有外碎片；链接结构没有外碎片，但不能直接存取，虽然引入的 FAT 可以随机存取，但需要占用较大的内存空间。</p><p><strong>事实上，打开某个文件时，只需知道该文件所在的盘块号</strong>， 一个文件的信息存放在若干不连续物理块中，系统<strong>为每个文件建立一个索引表</strong>，并将这些块的块号存放在索引表中，一个索引表就是磁盘块地址数组，其中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个条目指向文件的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 块，如下图，所有灰色的物理块同属于一个文件 <code>jeep</code>，文件目录中会保存这个文件的索引表的编号，在索引表会找到该文件对应的所有物理块。这个索引表也是需要保存的，我们把它也保存在磁盘中，图中的物理块 <code>19</code>，叫做<strong>索引块</strong>：<br /><img src="https://img-blog.csdnimg.cn/20200321151643634.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />可以发现索引分配是支持随机存取的，由于它也是一种离散的分配方式，所以它也没有外碎片。索引分配显然也是支持文件动态增长的。但是要建立索引表放在磁盘上，所以索引表是要占据磁盘空间的，同时因为是离散分配，也无法避免的增加了较多的寻道次数和寻道时间。</p><p>由于文件的大小是不定的，所以合理的设计索引表会提高检索速度，也能减少空间开销。当文件很小的时候，一张索引表就可以解决，当文件很大的时候，一张索引表可能就放不下了，因此有如下两种方案：</p><ul><li><strong>链接模式</strong>：将一个大文件的一个索引表接着一个索引表，链接起来，相当于将多个小的索引表拼凑成一个大索引表来满足大文件的存储需求；</li><li><strong>多级索引</strong>: : 将一个大文件的所有索引表（二级索引） 的地址放在另一个索引表（主索引，一级索引）中，也就是索引表的每个表项又指向了另一张索引表，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200321152927102.png" alt="在这里插入图片描述" style="zoom: 80%;" /></li></ul><blockquote><p>在两级索引分配方式，若每个盘块大小为 <code>1KB</code>，每个盘块号占 <code>4 Byte</code>，则一个索引块中可存放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 个盘块号，则两级索引最多可包含的盘块号总数为 <code>64K</code> 个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>256</mn><mo>∗</mo><mn>256</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（256*256）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord cjk_fallback">）</span></span></span></span>。因此，所允许的文件的最大长度为<code>64 MB</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>64</mn><mi>K</mi><mo>∗</mo><mn>1</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（64K*1KB）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">）</span></span></span></span>。</p></blockquote><h1 id="4-目录"><a class="markdownIt-Anchor" href="#4-目录"></a> 4 目录</h1><p>有些系统保存了上百万的文件，为了管理这些数据，需要组织它们，所以引入了<strong>目录管理</strong>，文件目录通常分为两部分：</p><ul><li>磁盘可以分成一个或多个<strong>分区</strong>；</li><li>每个分区都包含了存储在分区中的文件的信息，这些信息保存在<strong>设备目录</strong>中，设备目录记录分区上所有文件的各种信息。</li></ul><p>目录是一个包含着所有文件信息的节点的集合，每一个目录项对应着一个文件，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200321153822181.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />目录本身也是要保存下来的，目录和文件都是保存在磁盘上的，在目录中通常会保存文件的名称、类型、地址、当前长度、最大长度、最后访问时间、数据最后更新时间、所有者 ID、保护信息等信息。</p><p>这些信息具体保存在<strong>文件控制块 FCB</strong> 中，用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的盘物理地址。文件控制块的有序集合称为文件目录，即一个文件控制块 FCB 就是一个文件目录项。文件控制块 FCB 中保存的内容大致可以分为如下三类：</p><ul><li><strong>文件基本信息</strong>：文件名，用户名，文件地址，文件长度，文件逻辑结构，文件物理结构；</li><li><strong>存取控制信息</strong>：文件存取权限；</li><li><strong>管理信息</strong>：共享计数，文件的建立日期，保存期限，最后修改日期，最后访问日期。</li></ul><h2 id="41-目录结构"><a class="markdownIt-Anchor" href="#41-目录结构"></a> 4.1 目录结构</h2><p>目录中就是所有文件控制块 FCB 的集合，对 FCB 的管理应该满足如下要求：</p><ul><li><strong>效率</strong>：快速的定位一个文件；</li><li><strong>命名</strong>：方便用户，两个用户可以有相同名字的不同文件，相同的文件可以有不同的名字。</li></ul><p>下图就是最简单的单级目录结构，每个文件对应着一个 FCB 表项，在单级目录结构中，要找到一个文件则要遍历 FCB，而且由于是单级结构，不允许出现重命名，也不允许分组。：<br /><img src="https://img-blog.csdnimg.cn/20200321155315972.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />为解决一级目录文件命名冲突，并提高对目录文件检索速度而改进，可以把目录分为两级：</p><ul><li><strong>一级称为主文件目录（MFD）</strong>：给出用户名，用户子目录所在的物理位置；</li><li><strong>二级称为用户文件目录（UFD，又称用户子目录）</strong>：给出该用户所有文件的 FCB。</li></ul><p>这样在不同主文件目录下的不同文件可以重名，而且用户要查找文件只需要在自己的主目录下查找即可，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200321155907353.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />在二级目录结构下依然是无法分组的，为了解决这个问题引入了<strong>树型目录结构</strong>，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200321160037707.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />在树形目录结构下，层次结构清晰，便于管理和保护，有利于文件分类，解决重名问题，提高文件检索速度。但查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。由于树形的叶子是不会重合的，所以不支持文件共享。</p><p>在有些系统中要求实现文件共享，这就引入了<strong>无环图结构目录</strong>，如下图所示，两个分支下的 <code>count</code> 都指向了同一个文件：<br /><img src="https://img-blog.csdnimg.cn/20200321160345448.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />在这种方式下，当某一方去修改这个文件时，如删除了这个文件，那么另一方指向这个文件的指针就是一个<strong>悬挂指针</strong>，解决方案有两种：</p><ul><li>设置一个断点来按期检查当前是否有悬挂指针，若有就删除悬挂指针；</li><li>通过表项保留计数来解决，文件的共享次数是通过一个计数器来实现的，当某一方删除这个文件的时候，我们并不删除这个文件，而是把这个计数器减一，当这个计数器为 <code>1</code> 时，这个文件就是一个独享文件，当这个计数器为 <code>0</code> 时，这个文件就真正的被删除了。</li></ul><p>在有的系统中要求文件可以指向目录，这就引入了普通图结构目录，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200321160909319.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />这种结构下就会出现环，当查找某个文件时就可能陷入某个环，保证无环的方式有如下几种：</p><ul><li>只允许链接到文件而不允许链接到子目录；</li><li>垃圾收集机制，定期检查是否有环；</li><li>每次添加一个链接时都用一个检测算法判断会不会产生环；</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第九章：虚拟内存</title>
    <link href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-虚拟内存的背景"><a class="markdownIt-Anchor" href="#1-虚拟内存的背景"></a> 1 虚拟内存的背景</h1><p>无论是分页还是分段，程序运行的基本要求就是必须全部放入内存后方可运行，如果进程大于内存的容量或者内存中同时运行多个进程，那么进程就无法执行了，解决这个问题有两种方法，即覆盖和动态加载，但是这两种工作都是由程序员手动来做而且实现很复杂。</p><p>上面的问题究其本质就是内存不够用了，那么很容易想到的就是扩充内存，可以从物理上扩充内存容量，但是是受限的，如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位操作系统支持的内存最大为 <code>4GB</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 位操作系统支持的内存最大为 <code>128GB</code>，并且购买内存也较为昂贵。那么是否可以从逻辑上扩充内存容量呢？答案是可以的，本文内容就是讲解如何从逻辑上扩充内存。</p><p>常规的存储方式具有如下特征：</p><ul><li><strong>一次性</strong>：作业在运行前需要一次性的全部装入内存；</li><li><strong>驻留性</strong>：作业装入内存后，便一直驻留在内存中，直到作业结束。</li></ul><p>正是由于一次性和驻留性，使得程序中暂时不用的数据占用了大量的内存空间，从而需要运行的作业无法装入内存。那么一次性和驻留性是必需的吗？人们对程序做了很多的研究发现程序在执行过程中其实不是要运行所有部分：</p><ul><li>程序通常有处理异常错误的代码，很少执行；</li><li>数组、链表等数据结构通常分配了比实际需要更多的内存；</li><li>程序的某些选项或特点可能很少使用；</li><li>即使需要完整的程序，也并不是同时需要所有的程序。</li></ul><p>通过上述四个特点，我们可以发现程序运行时往往只运行了一部分，这个特点我们叫做<strong>局部性原理</strong>。</p><h2 id="11-局部性原理"><a class="markdownIt-Anchor" href="#11-局部性原理"></a> 1.1 局部性原理</h2><p>局部性原理的定义是在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。出现局部性原理有如下原因：</p><ul><li>程序在执行时，除了少部分的转移和过程调用指令外，大多数仍是顺序执行的；</li><li>子程序调用将会使程序的执行由一部分内存区域转至另一部分区域，也就是说程序只是从一个局部跳跃到另一个局部而已；</li><li>程序中存在许多循环结构，循环体中的指令被多次执行；</li><li>程序中还包括许多对数据结构的处理，如对连续的存储空间数组的访问，往往局限于很小的范围内。</li></ul><p>因此我们说程序是具有局部性的，局部性主要体现在两个方面：</p><ul><li><strong>时间局部性</strong>： 如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问；产生时间局限性的典型原因是在程序中存在着大量的循环操作；</li><li><strong>空间局部性</strong>： 一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是顺序执行的。</li></ul><h2 id="12-虚拟内存"><a class="markdownIt-Anchor" href="#12-虚拟内存"></a> 1.2 虚拟内存</h2><p>虚拟内存是一种允许进程<strong>部分装入内存</strong>就可以执行的技术，它基于的原理就是局部性原理，因为程序具有局部性，所以只需要把当前需要执行的程序内容装入内存即可，这个时候用户看到的逻辑地址空间就比物理地址空间大，要实现这个功能就必须允许页面能够被换入和换出。</p><p>如下图，虚拟内存 <code>virtual memory</code> 显然是比实际内存 <code>physical memory</code> 大的，只需要把当前要执行的部分装入内存即可；用 <code>memory map</code> 来映射当前哪些部分是要装入内存的，类似页表，当运行到某个位置的时候就可以查询它在内存还是在外存；当要运行新的程序时或当前内存不足时就要和外存进行页面的换入和换出：<br /><img src="https://img-blog.csdnimg.cn/2020032021021692.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />虚拟内存具有如下特征：</p><ul><li><strong>离散性</strong>：在内存分配时采用离散的分配方式，是虚拟存储器的最基本的特征；</li><li><strong>多次性</strong>：一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可，是虚拟存储器最重要的特征；</li><li><strong>对换性</strong>：作业运行过程中信息在内存和外存的对换区之间换进、换出；</li><li><strong>虚拟性</strong>：从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul><h1 id="2-请求调页"><a class="markdownIt-Anchor" href="#2-请求调页"></a> 2 请求调页</h1><p>实现虚拟存储器要解决以下三个问题 ：</p><ul><li><strong>程序部分运行可以吗?</strong> 是可以的，依照程序局部性原理，取出要用的页，然后装入内存即可；</li><li><strong>发现程序不在内存时，如何将其装入后继续运行?</strong> 用请求调页技术，当发生缺页时，产生缺页中断，将外存上的页调入内存；</li><li><strong>内存无空间时怎么办?</strong> 用页面置换，将部分页面换出内存。</li></ul><h2 id="21-页面调入策略"><a class="markdownIt-Anchor" href="#21-页面调入策略"></a> 2.1 页面调入策略</h2><p>为能使进程运行，事先需将一部分要执行的程序和数据调入内存，有两种调页的策略：</p><ul><li><strong>预调页策略</strong>：主动的页面调入策略，即把那些预计很快会被访问的程序或数据所在的页面，预先调入内存；这个策略的性能取决于预测的准确率，预测的准确率不高（50%），主要用于进程的首次调入。也有的系统将预调页策略用于请求调页。</li><li><strong>请求调页策略</strong>：当进程在运行中发生缺页时，由系统将缺页调入内存；目前虚拟存储器系统大多采用此策略；但在调页时须花费较大的系统开销，如需频繁启动磁盘 I/O。</li></ul><p>请求调页只有在一个页需要的时候才把它换入内存，这是请求调页的好处，或者说是虚拟内存的好处。它需要很少的 I/O，需要很少的内存，能够快速响应，并且可以支持多用户。当需要某个页的时候判断它是否在内存中是需要进行查阅的，通常存在一个 <code>bit</code> 位表示它是不是在内存，若不在内存中就要调入内存。</p><p>在具体实现的时候需要对进程页表进行修改，也需要缺页中断的支持。请求分页的页表机制是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入内存，还有一部分仍在磁盘上，故需在页表中再增加若干项，供程序(数据) 在换进、换出时参考。在请求分页系统中的每个页表项如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320211913969.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />其中增加的各字段说明如下：</p><ul><li><strong>状态位 (存在位P)</strong>  ：用于指示该页是否已调入内存，供程序访问时参考；</li><li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考；</li><li><strong>修改位M</strong>：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本；</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。</li></ul><p>完成页面调页还需要缺页中断机构的支持，在请求分页系统中，每当所要访问的页面不在内存时，便要产生一个缺页中断，请求操作系统将所缺页调入内存。与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号；</li><li>缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行；</li><li>一条指令在执行期间，可能产生多次缺页中断；</li></ul><p>下图是缺页中断的处理过程，现在要加载一个程序 <code>M</code>，❶首先要查询页表，发现该页在页表中是 <code>i</code> (invalid)，表示不在内存，❷这个时候就产生一个缺页中断，❸操作系统就会根据在页表中指向的外存的地址找到它，❹随后从外存放入内存，放入的时候要找一个空闲页，一旦放进去了以后，❺页表就要更新，此时中断就结束了，❻接着就要返回到这个程序重新执行：<br /><img src="https://img-blog.csdnimg.cn/20200320213158407.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />上面整个过程主要是执行以下三个操作：</p><ul><li>处理缺页中断；</li><li>从磁盘读入所需的页；</li><li>重新开始被中断的进程。</li></ul><p>其中最大的一部分时间开销为第二步，即从磁盘读入所需的页，因此我们希望减少读入的次数，也就是降低<strong>缺页率</strong>。</p><blockquote><p><strong>缺页率</strong> = 访问内存次数 / 不成功访问次数</p></blockquote><h1 id="3-页面置换"><a class="markdownIt-Anchor" href="#3-页面置换"></a> 3 页面置换</h1><p>随着装入内存的程序越来越多，内存可能会有装满的情况，这个时候如果来了新的程序想要进入内存，就必须执行页面置换，将内存中暂不使用的程序先从内存调出到外存。</p><p>如下图的两个用户程序，其中用户程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 需要载入程序 <code>M</code>，用户程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 需要载入程序 <code>B</code>，而此时 <code>M</code> 载入到内存后，内存已经满了，程序 <code>B</code> 再要装入内存已经没有位置了，所以此时要将现在内存中的某个程序置换出去。<br /><img src="https://img-blog.csdnimg.cn/20200320214456438.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />现在置换有如下几种方法：</p><ul><li><strong>终止用户进程</strong>：一旦终止用户进程，进程就会释放内存空间，那么内存就腾出位置来了，这种方法的代价是比较大的；</li><li><strong>交换进程</strong>：中级调度，释放其所有帧，降低多道程序的度，这种方法的代价也是比较大的，因为是以整个进程为单位，进行的 I/O 操作开销较大；</li><li><strong>页面置换</strong>：以页为单位做交换，这种方法的开销相比是最小的。</li></ul><p>页面置换的执行步骤如下：</p><ul><li>找到页面在磁盘中的位置，找到之后便要把它读入内存，就要找到一个空闲的帧；</li><li>若有空闲的帧遍可以直接装入，若没有空闲的帧就要选择一个页调换出去，同时修改页表，再把页面装入内存；</li></ul><p>页面置换过程如下图所示，❶牺牲当前内存中的某个页， 置换到外存上，❷修改页表标志位，❸将页面置换进内存中，❹更新页表：<br /><img src="https://img-blog.csdnimg.cn/20200320215253300.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />可以发现在页面置换过程中，需要两个页面传输，一个换出，一个换入。但是有时候只需要一次置换就可以，因为有些程序在内存中并没有被修改过，所以它不需要换到外存去更新数据，只用牺牲它，将新调入的程序覆盖它即可，这里用到的方法就是前面提到的<strong>修改位</strong>。</p><p>页面置换的总的流程图如下图所示，图中的快表指的是联想寄存器：<br /><img src="https://img-blog.csdnimg.cn/20200320215930991.png" alt="在这里插入图片描述" style="zoom:63%;" /></p><h1 id="4-页面置换算法"><a class="markdownIt-Anchor" href="#4-页面置换算法"></a> 4 页面置换算法</h1><p>在进程运行过程中，如果发生缺页， 而内存中又无空闲块时可以将内存中的某一页换到磁盘的对换区。那么到底选择调出哪一个页，可以根据页面置换算法来确定，置换算法的好坏将直接影响系统的性能，不适当的算法可能会导致进程发生 <strong>“抖动” (Thrashing)</strong> 。</p><blockquote><p><strong>抖动 (Thrashing)</strong>：如果进程分配到的帧数量小于计算机体系结构所要求的最小数量，那么必须暂停进行执行，并将其置换出去，使其所有分配帧空闲。这么做的原因就是如果进程没有这些必需的帧，那么很快会出现缺页，此时需置换某个页，然而，其所有页都在使用，置换出去的页立刻又需要置换进来，因此，会不断的产生缺页。这种频繁的调页行为称作<strong>抖动 (Thrashing)</strong>，也叫颠簸。</p></blockquote><p>页面置换最大的问题就是到底换哪一个页，若换出的某个页很快就又要用到又要换进来，这样的效率是很低的，所以我们希望我们换出的页是今后很长一段时间内不再用到的页，这样就能降低系统的缺页率，我们来衡量一个页面置换算法的好坏主要是通过缺页率的大小，从理论上讲 ， 应将那些以后不再被访问的页面换出，或把那些在较长时间内不会再被访问的页面换出，在实际的过程中有很多的置换算法能够接近理论目标，为什么说是理论上的，因为我们人是不知道哪些页面是要换的。</p><p>我们通过运行一个内存访问的特殊序列（访问序列），计算这个序列的缺页次数来评估算法。这个序列我们假定为 <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code>，后面讨论算法时都会用到这个序列。</p><h2 id="41-最佳算法opt"><a class="markdownIt-Anchor" href="#41-最佳算法opt"></a> 4.1 最佳算法（OPT）</h2><p>最佳算法中被置换的页将是之后最长时间不被使用的页，其置换过程如下：<br /><img src="https://img-blog.csdnimg.cn/20200320222211375.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。这个算法的缺点就是在实际过程中，我们并不知道这个内存访问序列，尤其是在多道批处理系统中，更是无法预测，所以最佳算法只是理论上最优的算法，现实中是无法实现的，我们通常用它来衡量其他算法的性能。</p><h2 id="42-先进先出置换算法fifo"><a class="markdownIt-Anchor" href="#42-先进先出置换算法fifo"></a> 4.2 先进先出置换算法（FIFO）</h2><p>先进先出置换算法中是按照内存先来先得，先进来的先出去这种方式来选择置换的页，其置换过程如下：<br /><img src="https://img-blog.csdnimg.cn/20200320222913283.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>。这个算法的性能几乎是比最佳算法差了一倍了，导致性能不好的原因是刚刚换出去的页，很可能又要被换进来，于是增加了缺页率，因此有了下面第三种置换算法。</p><h2 id="43-最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#43-最近最久未使用置换算法lru"></a> 4.3 最近最久未使用置换算法（LRU）</h2><p>虽然并不知道页面未来的使用情况，但是可以使用离过去最近的情况作为不远将来的近似，可以选择最近最少使用的页进行置换，其置换过程如下：<br /><img src="https://img-blog.csdnimg.cn/20200320223500637.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />上述过程的缺页次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>，置换次数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>。这个算法的性能显然比先进先出置换算法要好，但是实现 LRU 算法需要硬件支持，记录物理页的使用情况。</p><blockquote><p>实际上可能没有足够的硬件支持，所以就有了 LRU 的近似算法，如基于访问位的算法，二次机会算法。</p><ul><li><strong>访问位算法</strong>：每个页都与一个位相关联，初始值为 <code>0</code>，每当这个页被访问的时候就把这个页置位 <code>1</code>，所以在选择置换的页时就可以看这个访问位，看谁是未被访问过的。但是这个算法有不足的地方就在于我们并不知道这个置换顺序，因为有可能有的页时很久都没有使用过的，有的页只是最近未被使用过的，理论上来说很久未被使用的页大概率以后不会再使用了，而最近未使用的页很可能再被使用。</li><li><strong>二次机会算法 (clock算法)</strong>：同样它也需要访问位的支持，它会把所有的页组成一个环，同样未被访问时，访问位置 <code>0</code>，访问位就置 <code>1</code>，在要置换时，我们以顺时针的方向遍历这个环来寻找访问位为 <code>0</code> 的页换出去，若找到访问位为 <code>1</code> 的页，就把它置位 <code>0</code>，代表着给它一次机会，这也是二次机会算法名字的由来。如果所有页的访问位都为 <code>1</code>，则此算法退化为 FIFO 算法。二次机会算法执行过程如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320224943563.png" alt="在这里插入图片描述" style="zoom: 80%;" /></li></ul></blockquote><h1 id="5-帧页分配"><a class="markdownIt-Anchor" href="#5-帧页分配"></a> 5 帧（页）分配</h1><p>前面提到每个进程要运行则必须给它分配一定的内存空间，它才能把需要的内容放到内存去执行，那么如何给进程分配内存空间呢？首先我们要保证给它分配的空间是能够让它正常的运行的，即保证进程正常运行所需的最小物理块数，若系统为某进程所分配的物理块数少于此值时，进程将无法正常运行 (频繁发生缺页)，这个数目取决于指令的格式、功能和寻址方式。</p><p>具体分配多个页，有如下的分配方式：</p><ul><li><strong>平均分配</strong>：比如有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个页，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个进程，则每个进程分给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个页；</li><li><strong>按比例分配</strong>：根据每个进程的大小比例来分配；</li><li><strong>优先分配</strong>：根据优先级而不是大小来使用比率分配策略。</li></ul><p>如果进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 产生了一个缺页，我们知道这个时候需要使用页面替换算法来替换一个页面，所替换页面的位置分为如下两种：</p><ul><li><strong>全局替换</strong>：进程在所有的页中选择一个替换页面，一个进程可以从另一个进程中获得页面；</li><li><strong>局部替换</strong>：每个进程只从属于它自己的页中选择。</li></ul><p>所以当进行全局置换的时候，进程所分配的页数是可以变化的，因为它占用了其他进程的页，因此使用全局置换可能造成其他进程的运行错误；当进行局部置换的时候，进程所分配的页数是固定不变的，因为它只在自己所属的范围内置换。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第八章：内存管理</title>
    <link href="/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-内存管理背景"><a class="markdownIt-Anchor" href="#1-内存管理背景"></a> 1 内存管理背景</h1><p>下图是计算机系统中存储层次结构：<br /><img src="https://img-blog.csdnimg.cn/20200320135927850.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />本文主要讨论的是其中的 <strong>主存 (primary storage)</strong> 部分，主存又叫内存。计算机程序在执行过程中，所有程序必需放入内存并放入一个进程才能被执行，程序是磁盘中的一个静态的实体，通常对应着一个文件，所有的程序都是在<strong>输入队列</strong>中等待的，所谓输入队列就是磁盘上等待进入内存并执行的进程的集合。用户程序在执行之前必需经历很多步骤，这里可以以C语言为例，参考我的这篇文章 <a href="https://syzdev.cn/2020/03/11/%E7%94%A8gcc%E6%8C%87%E4%BB%A4%E4%BD%93%E9%AA%8CC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">C语言-用gcc指令体验C语言编译过程</a>，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320140318912.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />在程序装入内存中，存在着逻辑地址到物理地址的映射问题，即在逻辑地址中 <code>x</code> 的地址是 <code>200</code>，但在物理地址中<code>x</code> 的地址是 <code>1200</code>，因为实际内存中不可能都是从地址 <code>0</code> 开始的，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320141200196.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />因此需要地址之间的绑定以便于指令能够找到实际的物理地址，指令和数据绑定到内存地址可以在三个不同的阶段发生：</p><ul><li><strong>编译时期</strong>：如果内存位置已知，可生成绝对代码；如果开始位置改变，需要修改并重新编译代码；</li><li><strong>加载时期</strong>：如果存储位置在编译时不知道，则必须生成可重定位代码，实际上进程在内存中是不可以移动的，若要移动进程则需要重新定位；</li><li><strong>执行时期</strong>：如果进程在执行时可以在内存中移动，则地址绑定要延迟到运行时。需要硬件对地址映射的支持，例如基址和限长寄存器。</li></ul><p>下图是三种绑定阶段的示例图。在编译时绑定，则在编译后就明确指出操作的物理地址，即 <code>move 1156 3</code> 表示把 <code>count</code> 的值放到地址为 <code>1156</code> 的位置；在加载时绑定，则在编译后就明确指出操作的逻辑地址，即 <code>move 156 3</code>，在加载到内存后进行变换，变换到 <code>1156</code> 的位置；在运行时绑定，则在编译后也是只能给出逻辑地址，在加载到内存时，依然保存的是逻辑地址，但是当执行到这条语句时，再执行该指令的地址变换 <code>1000 + 156 = 1156</code>。<br /><img src="https://img-blog.csdnimg.cn/20200320142509474.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />上文所提及的<strong>逻辑地址</strong>和<strong>物理地址</strong>两个概念会贯穿于整个内存管理内容中，他们的定义如下：</p><ul><li><strong>逻辑地址</strong>：由CPU产生，也叫做虚拟空间；</li><li><strong>物理地址</strong>：内存设备所读入的地址。</li></ul><p>在上面的图中，指令 <code>move 1156 3</code> 中的 <code>1156</code> 就是逻辑地址，内存中的 <code>1156</code> 地址块就是物理地址，可以发现在编译时绑定和加载时绑定中，逻辑地址和物理地址是相同的，但在运行时绑定中，逻辑地址和物理地址是不同的。</p><p>我们把将程序装入到与其地址空间不一致的物理空间，所引起的一系列地址变换过程叫做<strong>地址重定位</strong>，地址重定位分为如下两种：</p><ul><li><strong>静态地址重定位</strong>：在装入一个作业时，把作业中的指令地址全部转换为绝对地址，在作业执行过程中就无须再进行地址转换工作，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320143857751.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li><li><strong>动态地址重定位</strong>：动态地址重地位是在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换成物理地址。动态重定位依靠硬件地址变换机构完成，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320144021805.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />通过硬件把虚拟地址映射到物理地址，所需的硬件叫做<strong>内存管理单元 (MMU)</strong>，在 MMU 策略中，基址寄存器中的值被加入到用户进程所产生的每个地址中，在其送入内存的时候，用户程序所对应到的是逻辑地址，物理地址对它从来都不可见，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320144245219.png" alt="在这里插入图片描述" style="zoom:67%;" /></li></ul><h1 id="2-固定分区分配"><a class="markdownIt-Anchor" href="#2-固定分区分配"></a> 2 固定分区分配</h1><p>上一节中讲的主要内容是如何把程序放入内存，即要实现逻辑地址到物理地址的映射，使之能够正确的运行，这一节所讲的主要内容是研究放入内存后如何给它分配内存空间，通常来说会为每一个程序分配一段连续的内存空间，分配方式主要有：</p><ul><li><strong>单一连续区管理方式</strong>：主要针对单道批处理系统，只有一个作业进入内存，内存被分为两块，一块用来存放操作系统，一块用来存放用户程序，我们只要保证用户程序不会影响到操作系统即可，使用基址寄存器策略来保护用户进程（同其他进程和改变的操作系统代码和数据分开)，基址寄存器包含最小物理地址的值，即起始地址；限长寄存器包含逻辑地址的范围，每个逻辑地址必需比限长寄存器的值小，即不能地址越界，判断地址合法流程图如下：<br /><img src="https://img-blog.csdnimg.cn/20200320152100402.png" alt="在这里插入图片描述" style="zoom: 80%;" /></li><li><strong>多分区管理方式</strong>：是一种可用于多道程序的较简单的存储管理方式，它又分为<strong>固定分区方式</strong>和<strong>可变分区方式。</strong></li></ul><p>对于固定分区分配方式，固定式分区是在<strong>作业装入之前</strong>，内存就被划分成若干个固定大小的连续分区，划分工作可以由系统管理员完成，也可以由操作系统实现，一旦划分完成，在系统运行期间不再重新划分，即分区的个数不可变，分区的大小不可变，所以，固定式分区又称为<strong>静态分区</strong>，划分分区的方法如下：</p><ul><li><strong>分区大小相等</strong>：比如有 <code>100MB</code> 内存，分五个分区，每个分区 <code>20MB</code>，只适用于多个相同程序的并发执行（处理多个类型相同的对象），缺乏灵活性，会造成<strong>内碎片</strong>问题；</li></ul><blockquote><p><strong>内碎片</strong>：比如一个分区大小是 <code>20MB</code>，但是进程只需要 <code>16MB</code>，多出的 <code>4MB</code> 用不上，而别的进程也无法使用，这 <code>4MB</code> 大小的空间就叫做内碎片。</p></blockquote><ul><li><strong>分区大小不等</strong>：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区，两种划分方法示意图如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320152719688.png" alt="在这里插入图片描述" style="zoom:67%;" /></li></ul><p>一般将内存的用户区域划分成大小不等的分区，可适应不同大小的作业的需要。当作业到来时，系统有一张<strong>分区说明表</strong>，每个表目说明一个分区的大小、起始地址和是否已分配的使用标志，分区说明表和内存分配图如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320152941899.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />总结来说固定分区分配的优点是易于实现，开销小；缺点是分区大小固定，会造成内碎片问题，同时由于分区总数固定，会限制并发执行的进程数目。</p><h1 id="3-动态内存分配"><a class="markdownIt-Anchor" href="#3-动态内存分配"></a> 3 动态内存分配</h1><p>在动态分区分配中，分区的划分是动态的，不是预先确定的，当某个进程到来，它需要多少内存就给它分配多少内存，所以造成不同大小的分区分布在整个内存中，分配过程如下图，当进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 调出内存后，进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 和进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 可以使用原来进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 所占用的内存：<br /><img src="https://img-blog.csdnimg.cn/20200320153807124.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />在这种方式下，操作系统也是需要知道内存的状态的，可以采用<strong>空闲分区表</strong>和<strong>空闲分区链</strong>两种方式，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320154154258.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />在可变分区分配时要设计<strong>分区分配算法</strong>来寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。<strong>分区的先后次序通常是从内存低端到高端</strong>。同时也要设计<strong>分区释放算法</strong>把相邻的空闲分区合并成一个空闲分区。（这时要解决的问题是：合并条件的判断）。</p><p>那么怎样从一个空的分区序列中满足一个申请需要？有如下三种方式：</p><ul><li><strong>首先适应 (First-fit)</strong>：分配最先找到的合适的分区；</li><li><strong>最佳适应 (Best-fit)</strong>：搜索整个序列，找到适合条件的最小的分区进行分配；</li><li><strong>最差适应 (Worst-fit)</strong>：搜索整个序列，寻找最大的分区进行分配。</li></ul><p>很显然，在速度和存储的利用上，理论上首先适应和最佳适应要比最差适应好。</p><h2 id="31-首先适应-first-fit"><a class="markdownIt-Anchor" href="#31-首先适应-first-fit"></a> 3.1 首先适应 (First-fit)</h2><p>首先适应的思想是从空闲分区表的第一个表目开始查找，把找到的<strong>第一个</strong>满足要求的空闲区分配给作业，目的在于<strong>减少查找时间</strong>。通常将空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序，它有如下特点：</p><ul><li>分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端；</li><li>随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大；</li><li>在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为<strong>外碎片</strong>。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。</li></ul><blockquote><p><strong>外碎片</strong>：比如一块内存中连续分配了三个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 占 <code>20MB</code>，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 运行结束了，释放掉了自己的内存，然后来了一个新进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 需要 <code>18MB</code> 的内存，正好刚刚释放掉了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的 <code>20MB</code> 内存可以存放，但是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间会有一个 <code>2MB</code> 的内存，由于它太小了，很难分配到它，所以这 <code>2MB</code> 内存就叫做外碎片。</p></blockquote><h2 id="32-最佳适应-best-fit"><a class="markdownIt-Anchor" href="#32-最佳适应-best-fit"></a> 3.2 最佳适应 (Best-fit)</h2><p>最佳适应的思想是从全部空闲区中找出能满足作业要求的、且最小的空闲分区，能使碎片尽量小。为了提高查找效率，空闲分区表（空闲区链）中的<strong>空闲分区要按从小到大进行排序</strong>， 自表头开始查找到第一个满足要求的自由分区分配，它有如下特点：</p><ul><li>从个别来看，外碎片较小，但从整体来看，会形成较多无法利用的碎片；</li><li>较大的空闲分区可以被保留。</li></ul><p>下面是一个具体的例子，假如要分配一个 <code>16KB</code> 分区：<br /><img src="https://img-blog.csdnimg.cn/20200320155803703.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="33-外碎片问题"><a class="markdownIt-Anchor" href="#33-外碎片问题"></a> 3.3 外碎片问题</h2><p>在可变分区系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外碎片。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。解决碎片的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片，但分区的拼接技术，一方面要求能够对作业进行动态重定位，另一方面系统在拼接时要耗费较多的时间，下图是一个拼接的例子，存在着 <code>400K</code>，<code>300K</code>，<code>200K</code> 三个外碎片，可以将其朝高地址拼接，也可以移动某个进程，也可以在中间拼接，不同的拼接方式系统开销不同：<br /><img src="https://img-blog.csdnimg.cn/20200320160143942.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h1 id="4-分页"><a class="markdownIt-Anchor" href="#4-分页"></a> 4 分页</h1><p>上面所提到的用拼接解决外碎片问题在实现的时候还是有很多障碍的，我们需要思考还有没有别的方法来解决外碎片问题，我们首先来看动态分区产生外碎片的原因是什么？是因为这种分配要求把作业必须安置在一连续存储区内的缘故，那么如果允许物理地址空间非连续，是否可以解决？<strong>分页存储管理</strong>是解决存储碎片的一种方法，要避开连续性要求，<strong>允许进程的物理地址空间不连续</strong>。</p><p>分页的基本思想是进程的物理地址空间可以是不连续的，如果有可用的物理内存，它将分给进程。我们把物理内存分成大小固定的块。把逻辑内存也分为固定大小的块，叫做页，要求<strong>页的大小和块的大小是一样的</strong>，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320161853915.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />根据上图可以看出，把逻辑内存划分为块之后，可以离散的分布在物理内存中。当然在这种情况下，操作系统需要知道哪些页是空闲的，运行一个有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 页大小的程序，需要找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个空的页框读入程序，还要解决的问题就是逻辑地址到物理地址的映射，我们是通过建立一个页表，把逻辑地址转换为物理地址。此外，由于内存块的划分是采用固定大小分配的，所以不可避免的会在最后一个页中产生<strong>内碎片</strong>，地址映射如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200320162525913.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />我们知道由 CPU 产生的地址是逻辑地址，CPU 产生的逻辑地址被分为：</p><ul><li><strong>页号 <code>p</code> (Page number)</strong>：它包含每个页在物理内存中的基址，用来作为页表的索引，也就是一个程序会被划分为多个块，对应在物理地址中是多个页，页号指明了具体是哪个页；</li><li><strong>偏移 <code>d</code> (Page offset)</strong>：同基址相结合，用来确定送入内存设备的物理内存地址，也就是一个页内有很多地址，偏移是确定具体是哪个地址。</li></ul><p>通过页号和偏移确定物理地址的过程如下图，通过页号 <code>p</code> 去查找页表 <code>page table</code>，找到在页表中的哪个页 <code>f</code>，然后把 <code>f</code> 取出来再加上偏移 <code>d</code>，就可以映射到所在的物理地址：<br /><img src="https://img-blog.csdnimg.cn/20200320162903866.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />总结来说分页解决了外碎片问题，但是会有内碎片，不过每个内碎片不会超过页的大小，这个开销相比之前的方法来说是可以接受的。一个程序不必连续存放，但也要求程序全部装入内存才能执行。</p><h1 id="5-分页硬件支持"><a class="markdownIt-Anchor" href="#5-分页硬件支持"></a> 5 分页硬件支持</h1><p>回顾分页的过程，如下图，在页数比较小的时候可以直接把页表放入寄存器，但当页数很多的时候，显然是要将页表放入内存中：<br /><img src="https://img-blog.csdnimg.cn/20200320163732505.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />将页表放入内存后，要知道放在了内存的哪个地方，这里引入了两个寄存器来保存页表的位置：</p><ul><li><strong>页表基址寄存器 Page-table base register (PTBR)</strong>：页表基址寄存器指向页表的起始地址；</li><li><strong>页表限长寄存器 Page-table length register (PRLR)</strong>：页表限长寄存器表明页表的长度。</li></ul><p>在这个机制中，每一次的数据/指令存取需要<strong>两次内存存取</strong>，一次是存取页表，一次是存取数据，两次的存取显然性能不高，解决办法是通过一个<strong>联想寄存器 translation look-aside buffers (TLBs)</strong>，可以解决两次存取的问题。</p><p>联想寄存器类似于一个快速缓存，每次查找一个页的时候，都记录下页和页的起始地址，当下次查询的时候可以直接在联想寄存器中寻找，找不到的时候再去查找页表，此时地址映射的过程如下，相比在第四节中最后的那张图多了一个联想寄存器的查找步骤：<br /><img src="https://img-blog.csdnimg.cn/20200320164807147.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />我们知道寄存器的存取速度是比内存快的，因此用这种方法能大大提高查找效率，举个例子，我们假设联想寄存器的查找需要时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，内存一次存取要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>微秒，我们称如果在联想寄存器中找到了对应的页地址的话，叫做“命中”，那么命中率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 就为在联想寄存器中找到页号的比率，比率与联想寄存器的大小有关，此时有效的存取时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>ε</mi><mo stretchy="false">)</mo><mi>α</mi><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>ε</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">–</mi><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>+</mo><mi>ε</mi><mi mathvariant="normal">–</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">T=(1 + ε) α + (2 + ε)(1 – α)=2 + ε – α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>。</p><blockquote><p>可以带入具体数值来看一看，例如，假设检索联想存储器的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">20ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ，访问内存的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ，访问联想存储器的命中率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>85</mn></mrow><annotation encoding="application/x-tex">85</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">5</span></span></span></span>% ，则 CPU 存取一个数据的平均时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>0.85</mn><mo>∗</mo><mn>120</mn><mo>+</mo><mn>0.15</mn><mo>∗</mo><mn>220</mn><mo>=</mo><mn>135</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T=0.85*120+0.15*220=135ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">5</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>，访问时间只增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>35</mn></mrow><annotation encoding="application/x-tex">35</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">5</span></span></span></span>%。如果不引入联想存储器，其访问将延长一倍（达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">200ns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> ）</p></blockquote><p>下图是分页地址变换机构工作原理图，首先按页的大小分离出页号和位移量，放入有效地址寄存器中，再将页号与页表长度进行比较，如果页号大于页表长度，越界中断；再以页号为索引查找页表，将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号；然后将该物理块号装入物理地址寄存器的高址部分；最后将有效地址寄存器中的位移量直接复制到物理地址寄存器的低位部分，从而形成内存地址：<br /><img src="https://img-blog.csdnimg.cn/20200320170230920.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />下面是一个具体的例子，图中省略了越界判断，先分离出了页号和偏移，分别为 <code>2</code> 和 <code>1C4</code>，然后查找页表，得到块号地址为 <code>8</code>，然后将 <code>8</code> 放在物理地址寄存器的高位，把偏移 <code>1C4</code> 放在物理地址寄存器的低位，这个地址就是物理地址：<br /><img src="https://img-blog.csdnimg.cn/20200320170933132.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h1 id="6-分段管理"><a class="markdownIt-Anchor" href="#6-分段管理"></a> 6 分段管理</h1><p>上面所讨论的分页方式有效的解决了外碎片问题，但是实际上并没有考虑用户的观点，也就是它在分页的时候都是硬性的按照等大小来划分，并不关心页中存放的是程序还是数据。本节中引入的分段方式就是一种支持用户观点的内存管理机制。</p><p>一个程序是一些段的集合，一个段是一个逻辑单位，如主程序、子过程、函数、局部变量、全局变量等等内容，在用户的眼里是把程序看作各个有机的部分，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320171719619.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />把程序的各个部分放入内存实际上也就是把这每个部分看成各个段，然后放入内存，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200320171838259.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />在分段管理方式下要解决的问题依旧是逻辑地址到物理地址的映射问题，与分页类似，分段管理方式下也有段表，和段偏移。由于分页的每一页都是固定大小的，所以只需要起始地址，但是分段的每一段大小是不等长的，所以这里定义了两个变量：</p><ul><li><strong>基址 (base)</strong>：包括内存中段物理地址的起始地址；</li><li><strong>限长 (limit)</strong>：指定段的长度。</li></ul><p>从逻辑地址到物理地址的映射过程如下图所示，段表中保存着每一段的起始地址和限长地址，这样就在内存中唯一确定了段的地址范围：<br /><img src="https://img-blog.csdnimg.cn/20200320172502676.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />下图是实现地址映射的物理结构流程图，其过程和分页的过程十分类似：<br /><img src="https://img-blog.csdnimg.cn/20200320172702716.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />在分页方式中，页表是要保存在内存中的，所以当时定义了页表基址寄存器 (PTBR) 和页表限长寄存器 (PRLR) 来指明页表的位置，同样在分段方式中，也定义了类似的两个寄存器：</p><ul><li><strong>段表基址寄存器 Segment-table base register (STBR)</strong>：段表基址寄存器指向段表在内存中的地址；</li><li><strong>段表限长寄存器 Segment-table length register (STLR)</strong>：段表限长寄存器表明被一个程序所使用的段的数目。</li></ul><p>此时地址变化过程如下图，首先系统将逻辑地址中的段号 <code>S</code> 与段表长度 <code>TL</code> 进行比较。若 <code>S &gt;= TL</code>，访问越界，若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址；然后再检查段内地址 <code>d</code> 是否超过该段的段长 <code>SL</code> 。若超过，即 <code>d &gt;= SL</code>，同样发出越界中断信号；若未越界，则将该段的基址与段内地址 <code>d</code> 相加，得到要访问的内存物理地址。<br /><img src="https://img-blog.csdnimg.cn/20200320173359432.png" alt="在这里插入图片描述" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第七章：死锁</title>
    <link href="/2020/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%AD%BB%E9%94%81/"/>
    <url>/2020/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-死锁的基本概念"><a class="markdownIt-Anchor" href="#1-死锁的基本概念"></a> 1 死锁的基本概念</h1><p><strong>死锁 (Deadlock)</strong> 指的是计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。</p><p>下面是一个现实中过桥的例子，如图所示桥比较窄，只能同时通过一辆车，此时有两辆车面对面都想要通过桥，而两辆车互不相让，导致都无法通过，这就是现实中“死锁”的例子。我们可以把桥看作是资源，对于车来说是共享的，当死锁发生时，要解决死锁其中一种解决方法是让其中某辆车后退，现假设让右边的车后退，则它后面的所有车都要后退，若每次都是右边的车让道的话，右边有些车就一直不能通行，就会造成<strong>饥饿</strong>现象。<br /><img src="https://img-blog.csdnimg.cn/20200319195105827.png" alt="在这里插入图片描述" style="zoom: 33%;" /><br />死锁现象产生的本质就是<strong>供小于求</strong>，也就是资源满足不了进程的需求，每一个进程如下的利用资源：</p><ul><li><strong>申请 (Request)</strong>： 如果申请不能立即被允许，那么进程必须等待直到能获取资源。（通过系统调用或者信号量来进行资源的申请和释放）；</li><li><strong>使用  (Use)</strong>： 进程使用资源进行相关操作；</li><li><strong>释放 (Release)</strong> ：进程释放资源。</li></ul><p>除了对资源的竞争会产生死锁外，P，V操作顺序的不当也会产生死锁，如现有进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，他们都要申请信号量 A 和信号量 B，他们的操作如下表：</p><table><thead><tr><th>时间</th><th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>wait(A);</code></td><td><code>wait(B);</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>wait(B);</code></td><td><code>wait(A);</code></td></tr></tbody></table><p>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别申请了信号量 A 和信号量 B，那么在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻由于信号量 B 已经被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 申请，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 申请不到信号量 B，同理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 也申请不到信号量 A，这时就发生了死锁。</p><p>总结来说，产生死锁的原因如下：</p><ul><li><strong>竞争资源引起死锁</strong>：当系统中供多个进程所使用的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁；</li><li><strong>进程推进顺序不当引起死锁</strong>：在多道程序系统中，并发执行的进程推进序列不可预测，有些推进顺序，进程可以顺利完成，有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成死锁。</li></ul><h1 id="2-死锁的必要条件"><a class="markdownIt-Anchor" href="#2-死锁的必要条件"></a> 2 死锁的必要条件</h1><p>死锁的产生是有必要条件的，当下面四个条件<strong>同时出现</strong>，死锁将会发生：</p><ol><li><strong>互斥 (Mutual exclusion)</strong>：一次只有一个进程可以使用一个资源，因为有些资源的使用是必须独占的；</li><li><strong>占有并等待 (Hold and wait)</strong>：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源，又叫请求与保持；</li><li><strong>不可抢占 (No preemption)</strong>：一个资源只有当持有它的进程完成任务后才自由的释放，也就是非剥夺。若可以抢占的话，别的进程需要某个资源可以直接抢，就不存在死锁问题了；</li><li><strong>环路等待 (Circular wait)</strong>：等待资源的进程之间存在环，举个例子来说，进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 要获得进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的资源才能执行结束，进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 要获得进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的资源才能运行结束，进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 要获得进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的资源才能运行结束，这样就形成了一个等待环，谁也无法运行结束离开这个环。</li></ol><p>死锁指的是一组进程对一组资源使用时的某种状态，那么描述这个状态有如下参数：</p><ul><li><strong>资源类型</strong>：可以用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 来表示，如可以用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">R_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示 CPU 周期，内存空间，I/O 设备；</li><li><strong>实例</strong>：每个资源可能有多个实例，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> 表示；</li><li><strong>进程</strong>：用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 来表示。</li></ul><p>此时状态就可以用<strong>资源分配图</strong>来表示，在数据结构中，图是由一组顶点的集合 <code>V</code> 和边的集合 <code>E</code> 组成，在资源分配图中有两种类型的节点：</p><ul><li><strong>P</strong>：系统中全部的进程构成的节点；</li><li><strong>R</strong>：系统中全部的资源构成的节点。</li></ul><p>进程和资源之间的边也存在着两种边：</p><ul><li><strong>请求边</strong>：即某个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 要请求某个资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的边，箭头是从进程指向资源；</li><li><strong>分配边</strong>：即某个资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 已经被分配给某个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边，箭头是从资源指向进程。</li></ul><p>可以把进程表示为圆点，把资源表示成方形，把资源中的实例表示为更小的方形：<br /><img src="https://img-blog.csdnimg.cn/20200319203500495.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />上述两种边就可以表示为如下形式：<br /><img src="https://img-blog.csdnimg.cn/20200319203639432.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />有了上面的方法就可以方便的描述进程和资源的分配关系，如某时刻的关系如下图所示：<br /><img src="https://img-blog.csdnimg.cn/2020031920383818.png" alt="在这里插入图片描述" style="zoom:40%;" /><br />从资源分配图中，可以得出如下结论：</p><ul><li>如果图没有环，那么不会有死锁；</li><li>如果图有环，若每一种资源类型<strong>只有一个</strong>实例，那么<strong>一定会</strong>死锁，若每种资源类型<strong>有多个</strong>实例，<strong>可能</strong>死锁。</li></ul><h1 id="3-死锁预防"><a class="markdownIt-Anchor" href="#3-死锁预防"></a> 3 死锁预防</h1><p>处理死锁有忽略、预防、避免、检测、解除五种措施，忽略就是假装系统中从未出现过死锁，这个方法被大部分的操作系统采用，包括 UNIX 中的<strong>鸵鸟策略</strong>。预防死锁，避免死锁则是确保系统永远不会进入死锁状态。死锁检测和解除则是允许系统进入死锁状态，然后恢复系统。</p><blockquote><p><strong>鸵鸟策略</strong>：鸵鸟在遇到危险时会将头埋在沙子里，这里比喻像鸵鸟一样对死锁视而不见，因为处理死锁的代价很大，而且常常给用户带来许多不便的限制，大多数用户宁可在极偶然的情况下发生死锁，也不愿限制每个用户只能创建一个进程、只能打开一个文件等等，于是不得不在方便性和正确性之间作出折衷。</p></blockquote><h2 id="31-抑制死锁发生的必要条件"><a class="markdownIt-Anchor" href="#31-抑制死锁发生的必要条件"></a> 3.1 抑制死锁发生的必要条件</h2><p>对于<strong>互斥</strong>条件来讲，是不可以打破的，因为在某些条件下，必须互斥访问，详细内容可以参考这篇文章 <a href="https://syzdev.cn/2020/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">操作系统原理第六章：进程同步</a>。</p><p>对于<strong>占有并等待</strong>条件，要打破这个条件的话必须保证进程申请资源的时候没有占有其他资源，要做到这一点有如下两种方式：</p><ul><li>要求进程在执行前一次申请全部的资源，这样的话后续就不会再有资源的申请了；</li><li>没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源。</li></ul><blockquote><p>实际上这两种方法都是代价不小的，比如第一种方法，进程使用资源不是一次性全部使用的，而是有次序的使用的，这样就导致某些资源明明现在用不到，却被占有着，而其他着急使用该资源的进程要等待。</p></blockquote><p>对于<strong>非抢占式</strong>，打破这个条件就是允许抢占，抢占的方式是如果一个进程的申请没有实现，它要释放所有占有的资源，抢占的资源放入进程等待资源列表中，只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始。</p><p>对于<strong>环路等待</strong>条件，打破这个条件可以将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源，也就是给每个资源编号，所有进程对资源的请求必须严格按资源序号递增的次序提出，如已经申请了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号资源 CPU 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 号资源打印机，那么后面再申请资源必须按次序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 等等。总有一个进程占据了较高序号的资源，它继续请求的资源必然是空闲的，可以一直向前推进。在资源分配图中不可能出现环路，因而摒弃了“环路等待”条件，这种策略可以提高资源利用率，但在进程使用各类资源的顺序与系统规定的顺序不同时会造成资源浪费的情况。</p><p>总结来说上述预防死锁的方法通过限制资源请求来打破死锁的四个必要条件之一，从而预防死锁的发生，但可能带来副作用，如降低设备利用率和吞吐量，可能有进程饥饿等。</p><h1 id="4-死锁避免"><a class="markdownIt-Anchor" href="#4-死锁避免"></a> 4 死锁避免</h1><p>死锁避免不会去限制资源的使用，而是允许进程动态地申请资源，但在系统进行资源分配之前，先计算资源分配的安全性，若此次分配不会导致系统从<strong>安全状态</strong>向<strong>不安全状态</strong>转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。</p><p>安全状态是指系统的一种状态，在此状态下，系统能按某种顺序（例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）称为<strong>安全序列</strong>。  如果存在一个安全序列，则系统处于安全状态，若某一时刻不存在一个安全序列，则称系统处于不安全状态。</p><p>死锁属于不安全状态，是不安全状态的一个子集，它们之间的关系如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200319214216489.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />如果一个系统在安全状态，就没有死锁；如果系统死锁，则处于不安全状态；如果一个系统处于不安全状态，就有可能死锁；那么既然要避免死锁，那就要避免系统进入不安全状态。</p><p>避免死锁有两种常用方式：</p><ul><li>当资源有单个实例的时候，可以用之前提到的<strong>资源分配图</strong>来实现，若图中出现了环，这表示出现了死锁，那么可以检测资源分配图判断是否有环来避免死锁；</li><li>当资源有多个实例的时候，使用<strong>银行家算法</strong>。</li></ul><h2 id="41-资源分配图法"><a class="markdownIt-Anchor" href="#41-资源分配图法"></a> 4.1 资源分配图法</h2><p>在第二节也提到过资源分配图，在用资源分配图法避免死锁时，添加了一条新的边叫做<strong>需求边</strong>，即表示进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可能会申请到资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，箭头从进程指向资源，但是箭头图形为<strong>虚线</strong>。当一个进程申请资源的时候，需求边转化为请求边；当资源被进程释放的时候，分配边转化为需求边；当然系统中的资源必须被事先声明。</p><p>用资源分配图法来避免死锁的过程如下，当进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 申请资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 时，<strong>把图中的所有需求边转换为分配边，看图中是否出现环路</strong>，只有不出现环路，才实施资源分配，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200319215548958.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h2 id="42-银行家算法"><a class="markdownIt-Anchor" href="#42-银行家算法"></a> 4.2 银行家算法</h2><p>在现实世界中，银行的利益方式之一是提供贷款，当银行给某人提供贷款时，会考查他是否有能力偿还贷款，以此来判断贷出去的这笔钱是否是安全的。那么银行家算法就是借助这个思想，当某个进程需要分配资源的时候，操作系统会判断这个进程能不能把资源安全的归还，如果可以的话操作系统就分配，否则不分配。</p><p>银行家算法适用于多个实例的情况，每一个进程必须事先声明使用的最大量，当一个进程请求资源，它可能要等待，当一个进程得到所有的资源，它必须在有限的时间释放它们。</p><p>在实现银行家算法时，需要定义如下的参数：</p><ul><li><strong><code>n</code></strong> 为进程的数目，<strong><code>m</code></strong> 为资源的数目；</li><li><strong><code>Available</code></strong>：系统中有多少个可用资源，由于银行家算法用在多实例中，则如果 <code>available[ j ] = k</code>，表示资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个实例有效；</li><li><strong><code>Max</code></strong>：每个进程最多需要请求的资源个数，如果 <code>Max[ i, j ] = k</code>，那么进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 需要最多请求资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个实例；</li><li><strong><code>Allocation</code></strong>：每个进程已经分配了多少资源，如果 <code>Allocation[ i, j ] = k</code>，那么进程  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  当前分配了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个资源；</li><li><strong><code>Need</code></strong>：每个进程还需要多少资源，如果 <code>Need[ i, j ] = k</code>，那么进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 还需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个资源。上面几个参数存在这样的关系：<code>Need [ i, j ] = Max [ i, j ] – Allocation [ i, j ]</code>；</li><li><strong><code>Request</code></strong>：进程当前要申请多少资源，如果 <code>Request[ i, j ] = k</code>，那么进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 现在想申请 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个资源。</li></ul><p>银行家算法具体的实现过程如下：</p><ol><li>若 <code>Request &lt;= Need</code>，执行下一步，否则不执行，意思是进程当前想申请的资源必须是小于它实际所需要的，不能超出实际所需要的；</li><li>若 <code>Request &lt;= Available</code>，执行下一步，意思是当前申请的资源数量，系统是否可以满足，若满足不了，则需要等待，直到系统可以满足为止；</li><li>试着去给该进程分配资源，会执行如下操作 <code>Available = Available - Request</code>，<code>Allocation = Allocation + Request</code>，<code>Need = Need - Request</code>；</li><li>用<strong>安全算法</strong>检查，看系统是否处于安全状态，如果安全就分配资源，否则不分配并让之前执行的三个操作回到原来状态。</li></ol><p>在安全算法中，有两个参数：</p><ul><li><strong><code>Work</code></strong>：<code>Work = Available</code> 表示当前系统中可提供资源的数量；</li><li><strong><code>Finish</code></strong>：它为一个布尔变量，描述进程是否执行结束，如 <code>Finish[ i ] = false</code> 表示进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 还没有执行结束或还没有执行。</li></ul><p>在进程序列中，若进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 满足如下条件：</p><ul><li><code>Finish[ i ] = false</code>，这个进程还没执行完；</li><li><code>Need &lt;= Work</code>，进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所需的资源数量是小于系统可用资源数量的，换句话说就是系统是可以满足该进程的需求的。</li></ul><p>则执行 <code>Work = Work + Allocation</code>，<code>Finish[ i ] = true</code>，这两句的意思是进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 执行完后把它的 <code>Allocation</code> 给释放掉，然后标明 <code>Finish</code> 为已经执行完。<strong>然后按照该步骤依次检查所有的进程，如果最后所有进程的 <code>Finish</code> 都为 <code>true</code> 则代表所有进程都能顺利结束，那么说明系统为安全状态，所检查的序列叫做安全序列。</strong></p><p>银行家算法举例：现假设有五个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，三个资源类型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>个实例），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>个实例），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>个实例），下表是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻系统的状态：</p><table><thead><tr><th>进程</th><th><code>Allocation</code>（已分配）</th><th><code>Max</code>（总需求）</th><th><code>Available</code>（当前可分配）</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 1 0</td><td>7 5 3</td><td>3 3 2</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2 0 0</td><td>3 2 2</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3 0 2</td><td>9 0 2</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2 1 1</td><td>2 2 2</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 0 2</td><td>4 3 3</td><td></td></tr></tbody></table><p>要判断当前是否处于安全状态，要计算 <code>Need</code>，如下表：</p><table><thead><tr><th>进程</th><th><code>Need</code>（还需的资源数）= <code>Max - Allocation</code></th></tr></thead><tbody><tr><td></td><td>A B C</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>7 4 3</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>1 2 2</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>6 0 0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 1 1</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>4 3 1</td></tr></tbody></table><p>此时使用安全算法来验证是否有<strong>安全序列</strong>，初始条件下 <code>Work = available = (3，3，2)</code>，<code>Finish[ i ] = false (i = 0..4)</code>：</p><table><thead><tr><th>进程</th><th><code>Work</code></th><th><code>Need</code></th><th><code>Allocation</code></th><th><code>Finish</code></th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td><td>T/F</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3 3 2</td><td>1 2 2</td><td>2 0 0</td><td>T</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>5 3 2</td><td>0 1 1</td><td>2 1 1</td><td>T</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>7 4 3</td><td>4 3 1</td><td>0 0 2</td><td>T</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>7 4 5</td><td>6 0 0</td><td>3 0 2</td><td>T</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>10 4 7</td><td>7 4 3</td><td>0 1 0</td><td>T</td></tr></tbody></table><p>所以存在安全序列（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），系统处于安全状态。</p><blockquote><p>注意：安全序列有时不是唯一的，但只要找到一个，就认为系统是安全的。</p></blockquote><h1 id="5-死锁的检测"><a class="markdownIt-Anchor" href="#5-死锁的检测"></a> 5 死锁的检测</h1><p>死锁的检测分为两种情况，一种是每一种资源类型只有一个实例，另一种是一个资源类型的多个实例。</p><h2 id="51-每一种资源类型只有一个实例"><a class="markdownIt-Anchor" href="#51-每一种资源类型只有一个实例"></a> 5.1 每一种资源类型只有一个实例</h2><p>通过把资源分配图转换成<strong>维护等待图</strong>，来看维护等待图中是否出现了环来看当前系统是否出现了死锁。在维护等待图中<strong>只有一种节点就是进程</strong>，若进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 指向进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在等待 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，如下图左边为资源分配图，右边为转换的维护等待图：<br /><img src="https://img-blog.csdnimg.cn/20200319232003803.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />可以发现维护等待图中是存在环的，所以表明当前系统出现死锁了。</p><h2 id="52-一个资源类型的多个实例"><a class="markdownIt-Anchor" href="#52-一个资源类型的多个实例"></a> 5.2 一个资源类型的多个实例</h2><p>这里用到的算法叫做<strong>死锁检测算法</strong>，<strong>类似于之前讲过的安全算法</strong>，死锁检测算法定义了如下参数：</p><ul><li><strong><code>Available</code></strong>：每种资源可用的资源数量；</li><li><strong><code>Allocation</code></strong>：每个进程已经分配的资源数量；</li><li><strong><code>Request</code></strong>：进程请求的资源数量。</li><li><strong><code>Work</code></strong>：<code>Work = Available</code>；</li><li><strong><code>Finish</code></strong>：这里的 <code>Finish</code> 和之前的安全算法有所不同，这里当 <code>Allocation != 0</code> 则 <code>Finish = false</code> 否则 <code>Finish = true</code> ，也就是若某进程的 <code>Allocation = 0</code> 时说明这个进程没有被分配到资源，也就这个进程是不参与死锁的，所以 <code>Finish = true</code> 。</li></ul><p>找到某进程满足如下条件：</p><ul><li><code>Finish = false</code>；</li><li><code>Request &lt;= Work</code>：当前请求的资源数量小于系统可分配资源的数量；</li></ul><p>该进程能执行结束，执行结束后执行 <code>Work = Work + Allocation</code>， <code>Finish = true</code>，也就是把资源给释放掉，把所有的进程按如上操作遍历结束后检查会不会有一个进程的 <code>Finish = false</code> ，也就是某个进程无法结束，那么就发生了死锁，并且可以根据 <code>Finish</code> 的下标找到是哪一个进程发生了死锁。</p><p>检测死锁算法的例子：现假设有五个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，三个资源类型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>个实例），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个实例），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>个实例），下表是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻系统的状态：</p><table><thead><tr><th>进程</th><th><code>Allocation</code>（已分配）</th><th><code>Request</code>（当前请求）</th><th><code>Available</code>（当前可分配）</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 1 0</td><td>0 0 0</td><td>0 0 0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2 0 0</td><td>2 0 2</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3 0 3</td><td>0 0 0</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2 1 1</td><td>1 0 0</td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 0 2</td><td>0 0 2</td><td></td></tr></tbody></table><p>所以存在安全序列（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），当前是没有死锁的。</p><p>现在假设进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 请求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的一个实例，如下表：</p><table><thead><tr><th>进程</th><th><code>Request</code>（当前请求）</th></tr></thead><tbody><tr><td></td><td>A B C</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 0 0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2 0 1</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 0 1</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>1 0 0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0 0 2</td></tr></tbody></table><p>此时可以归还 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所有的资源，但是资源不够完成其他进程的请求，所以死锁存在，包括进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><h2 id="53-处理死锁"><a class="markdownIt-Anchor" href="#53-处理死锁"></a> 5.3 处理死锁</h2><p>当系统出现死锁，通常有如下三种方式：</p><ul><li>操作员人工处理；</li><li>进程终止；</li><li>资源抢占。</li></ul><p>其中进程终止和资源抢占是由操作系统来完成的，进程终止的方法如下：</p><ul><li>终止所有的死锁进程；</li><li>一次终止一个进程直到死锁环消失；</li><li>选择终止顺序，比如按照进程的优先级来终止，先终止优先级低的进程，或者按照进程计算了多少时间，还需要多长时间来选择终止。</li></ul><p>资源抢占的方法如下：</p><ul><li>选择一个牺牲品：最小化代价；</li><li>回退：返回到安全的状态，然后重新开始进程。</li></ul><p>但是会造成饥饿，因为同一个进程可能总是被选中，包括在回退时。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第六章：进程同步</title>
    <link href="/2020/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2020/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-进程同步背景"><a class="markdownIt-Anchor" href="#1-进程同步背景"></a> 1 进程同步背景</h1><p>对于之前所提到的生产者消费者问题，采用共享内存解决生产者消费者问题时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个缓冲区最多只能用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，那么为什么有一个是用不了的呢？这是因为在判断缓冲区空或满时，用取余计算实现的，之所以牺牲一个位置是为了让缓冲区空和缓冲区满两种状态有两种不同的表达式，若是换一种方法，设置一个计数变量 <code>count</code> ，<code>count</code> 的值表示当前缓冲区已经使用的容量，<code>count = 0</code> 表示缓冲区空，<code>count = BUFFER_SIZE</code>表示缓冲区满（<code>BUFFER_SIZE</code>为缓冲区大小），这样就解决了牺牲一个缓冲区容量的问题，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200316142855825.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />下面是实现生产者添加商品的伪代码，若不能理解该过程可以查阅数据结构中<strong>循环队列</strong>的内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 生产者调用的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enter</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>    <span class="hljs-comment">// 缓冲区已经满无法继续添加</span><br>    <span class="hljs-keyword">while</span> (count == BUFFER_SIZE); <br>    <span class="hljs-comment">// 添加一个商品到缓冲区</span><br>    buffer[in] = item;<br>    in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    count++; <span class="hljs-comment">// 计数加一</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是实现消费者消费商品的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 消费者调动的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    Object item;<br>    <span class="hljs-comment">// 当前缓冲区没有商品，无法消费</span><br>    <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>); <br>    <span class="hljs-comment">// 从缓冲区移除一个商品</span><br>    item = buffer[out];<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    count--; <span class="hljs-comment">// 商品总数减一</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述思想看起来是没有问题的，但是在实现过程中会出现问题，问题就出在 <code>count</code> 的<strong>自增</strong>和<strong>自减</strong>操作，由于<code>count++</code> 和 <code>count--</code>属于高级指令，所以在机器执行过程中是分为三个步骤的，中间还有一步转交给寄存器的操作，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200316144246835.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />所以当一条高级指令分解成三个指令时，多个程序并发时就会出现问题，现假设 <code>count = 5</code>，若生产一个商品，再消费一个商品，最后 <code>count</code> 的值还是等于 <code>5</code>，可在并发执行时就不一定会这样，见下面的例子（注：以下例子只是情况的一种，在并发执行时会有非常多的不确定性），最终 <code>count</code> 的值等于 <code>4</code>：<br /><img src="https://img-blog.csdnimg.cn/20200316144549242.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />由以上的例子可知，对共享数据的并发访问可能导致数据的不一致性，要保持数据的一致性，就需要一种保证并发进程的正确执行顺序的机制，解决有界缓冲区问题的共享内存方法是在数据 <code>count</code> 上存在<strong>竞争条件</strong>。</p><blockquote><p><strong>竞争条件</strong>：若干个并发的进程（线程）都可以访问和操纵同一个共享数据，从而执行结果就取决于并发进程对这个数据的访问次序，为了保证数据的一致性，需要有同步机制来保证多个进程对共享数据的<strong>互斥访问</strong>。</p></blockquote><p>进程的类型分为两种，一种是<strong>独立进程</strong>，它独立执行，不受其他进程的影响；另一种就是<strong>协作进程</strong>，如刚刚所讲的生产者和消费者问题，这两个进程就属于协作进程。进程间资源访问冲突也分为两种，一种是共享变量的修改冲突，如上面的 <code>count</code> 值，另一种则是操作顺序冲突，比如某个作业 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，需要作业 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 提供数据进行计算，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 提供不了数据，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 会受到影响。</p><p>进程间的制约关系分为如下两种：</p><ul><li><strong>间接制约</strong>：有些资源需要互斥使用，因此各进程进行竞争，独占分配到的部分或全部共享资源，进程的这种关系为<strong>进程的互斥</strong>；</li><li><strong>直接制约</strong>：进行协作，具体来说，一个进程运行到某一点时要求另一伙伴进程为它提供消息，在未获得消息之前，该进程处于等待状态，获得消息后被唤醒进入就绪态，进程的这种关系为<strong>进程的同步</strong>。</li></ul><p>由于多个进程相互竞争资源，若各个进程互不相让，此时就会发生<strong>死锁</strong>想象。</p><h1 id="2-临界区"><a class="markdownIt-Anchor" href="#2-临界区"></a> 2 临界区</h1><p>临界资源即共享资源，对于临界资源，多个进程必须互斥的对它进行访问，在进程中某些代码会访问到临界资源，这段代码就叫做<strong>临界区 (critical section)</strong>，即进程中访问临界资源的<strong>一段代码</strong>，实现进程对临界资源的互斥访问就是让各进程互斥的进入自己的临界区，也就是说当某个进程在临界区中执行时，其他进程都不能访问自己临界区，这样就保证了某个时间内只有一个进程在临界区内使用临界资源，这样就实现了临界资源的互斥访问。</p><p>临界区的执行在时间上是互斥的，进程必须请求允许进入临界区，也就是说当某个进程想进入临界区时，比如进行某种操作来判断当前临界区是否有进程在执行，在具体实现时也是利用代码来判断的，整个进程的访问过程分为以下三个区：</p><ul><li><strong>进入区 (entry section)</strong>：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应“正在访问临界区”标志；</li><li><strong>退出区 (exit section)</strong>：用于将&quot;正在访问临界区&quot;标志清除；</li><li><strong>剩余区 (remainder section)</strong>：代码中的其余部分。</li></ul><p>临界区互斥问题的解决方案要满足如下三个要求：</p><ul><li><strong>互斥</strong>：假定进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在其临界区内执行，其他任何进程将被排斥在自己的临界区之外；</li><li><strong>有空让进</strong>：临界区虽没有进程执行，但有些进程需要进入临界区，不能无限期地延长下一个要进入临界区进程的等待时间；</li><li><strong>有限等待</strong>：在一个进程提出进入临界区的请求和该请求得到答复的时间内，其他进程进入临界区的次数必须是有限的。</li></ul><h2 id="21-进程的互斥"><a class="markdownIt-Anchor" href="#21-进程的互斥"></a> 2.1 进程的互斥</h2><p>如何实现进程间的互斥？这里举一个现实中游乐园的滑滑梯例子，滑滑梯一次只能进一个小朋友，当有很多小朋友想要玩的时候，那么一个解决办法是让他们<strong>轮流</strong>来玩，另一个解决办法是提出想玩滑滑梯<strong>申请</strong>。在解决进程间的互斥问题时，也是借助了这两个思想，这里介绍几种算法。</p><hr /><p><strong>算法1</strong>：设立一个两进程公用的整型变量 <code>turn</code> ，用来描述允许进入临界区的进程标识有两个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> ， 如果 <code>turn = i</code>，那么进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 允许在其临界区执行，即采用轮流的方式，用 <code>turn</code> 表示当前运行哪个进程进入临界区。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (turn != i); <span class="hljs-comment">// 判断是否轮到 Pi </span><br>    critical section; <span class="hljs-comment">// 执行临界区</span><br>turn = j; <span class="hljs-comment">// 执行完临界区就轮到下一个 Pj</span><br>    remainder section; <span class="hljs-comment">// 执行剩余区</span><br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (turn != j); <span class="hljs-comment">// 判断是否轮到 Pj</span><br>    critical section; <span class="hljs-comment">// 执行临界区</span><br>turn = i; <span class="hljs-comment">// 执行完临界区就轮到下一个 Pi</span><br>    remainder section; <span class="hljs-comment">// 执行剩余区</span><br></code></pre></div></td></tr></table></figure><p>对于之前提到的临界区互斥问题的三个要求，该算法显然是满足第一个互斥要求的，实际上该算法是强制轮流进入临界区，没有考虑进程的实际需要，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 执行完临界区，<code>turn</code> 也转交给了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，但此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 不需要使用临界区，这时临界区处于空闲状态，但 <code>turn</code> 这时不属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 依然无法执行临界区，容易造成资源利用不充分，所以不满足第二个要求有空让进，也不满足第三个要求有限等待。</p><hr /><p><strong>算法2</strong>：由于算法1 只保存了哪个进程能进入临界区，没有保存进程的状态，所以算法2 设立一个标志数组 <code>flag[]</code>，用来描述进程是否准备进入临界区，初值均为 <code>FALSE</code>，先<strong>申请</strong>后检查 ，可防止两个进程同时进入临界区。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[i] = TURE; <span class="hljs-comment">// Pi 申请执行临界区</span><br><span class="hljs-keyword">while</span> (flag[j]); <span class="hljs-comment">// 判断 Pj 是不是在执行临界区或它也想执行临界区</span><br>    critical section;<br>flag[i] = FALSE; <span class="hljs-comment">// Pi 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[j] = TURE; <span class="hljs-comment">// Pj 申请执行临界区</span><br><span class="hljs-keyword">while</span> (flag[i]); <span class="hljs-comment">// 判断 Pi 是不是在执行临界区或它也想执行临界区</span><br>    critical section;<br>flag[j] = FALSE; <span class="hljs-comment">// Pj 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p>该算法显然满足互斥要求，因为每次执行临界区前都会判断对方是否在执行临界区或是否也想进入临界区，设想某个时刻 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 都申请执行临界区，这样会导致双方谁也不能执行临界区，所以不满足有空让进的要求，算法2 对比算法1 的优点是不用交替进入，可连续使用，不用等待对方，缺点就是两进程可能都进入不了临界区。</p><hr /><p><strong>算法3</strong>：在算法2 的基础上进一步改进，同样是要先申请执行临界区，但要把 <code>turn</code> 改为对方，然后再进行检查若当前对方在执行临界区或对方想要执行临界区且 <code>turn</code> 也是对方，那么就要等待对方执行完。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[i] = TURE; <span class="hljs-comment">// Pi 申请执行临界区</span><br>turn = j; <span class="hljs-comment">// 让 Pj 下次执行</span><br><span class="hljs-keyword">while</span> (flag[j] &amp;&amp; turn == j); <span class="hljs-comment">// 判断 Pj 是不是在执行临界区或它也想执行临界区且当且turn为它</span><br>    critical section;<br>flag[i] = FALSE; <span class="hljs-comment">// Pi 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 进入临界区的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">flag[j] = TURE; <span class="hljs-comment">// Pj 申请执行临界区</span><br>turn = i; <span class="hljs-comment">// 让 Pi 下次执行</span><br><span class="hljs-keyword">while</span> (flag[i] &amp;&amp; turn == i); <span class="hljs-comment">// 判断 Pi 是不是在执行临界区或它也想执行临界区且当且turn为它</span><br>    critical section;<br>flag[j] = FALSE; <span class="hljs-comment">// Pj 执行完临界区，撤销之前的申请</span><br>    remainder section;<br></code></pre></div></td></tr></table></figure><p>算法3 解决了算法1 和算法2 的缺点，同时算法3 具有先到先入，后到等待的特点。</p><h1 id="3-信号量"><a class="markdownIt-Anchor" href="#3-信号量"></a> 3 信号量</h1><p>可以用临界区解决互斥问题，它们是平等进程间的一种协商机制，之前所提到的轮流和申请都是基于两个进程的临界区模型所提出来的，当进程数目过多的时候，显然要引入新的机制来解决互斥问题，操作系统可从进程管理者的角度来处理互斥的问题，<strong>信号量 (Semaphore)</strong> 就是操作系统提供的管理公有资源的有效手段。</p><p>信号量是在1965年，由荷兰学者 Dijkstra 提出（所以 P、V 分别是荷兰语的 test (proberen)、increment (verhogen)），信号量是一种卓有成效的进程同步机制，用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。</p><p>信号量是一个整型变量，<strong>信号量代表可用资源实体的数量</strong>。除了初始化之外，仅能通过两个不可分割的<strong>原子操作</strong>访问，即 <code>P(S)</code> 和 <code>V(S)</code>，简称为 P，V 操作。</p><blockquote><p><strong>原子操作</strong>：指的是操作系统内最小的操作单位，它执行时不可中断的。</p></blockquote><p>由于 <code>S</code> 代表当前可用资源的数量，当 <code>S &lt;= 0</code>时，会一直等待资源，所以存在<strong>忙等现象</strong>，又称自旋锁，此时 CPU 的利用率是不高的，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(S); <span class="hljs-comment">// 申请资源</span><br>    <span class="hljs-keyword">while</span> (S &lt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// 当前没有可用资源就要一直等待</span><br>S--; <span class="hljs-comment">// 若有资源，就要总资源数减一</span><br>V(S); <span class="hljs-comment">// 使用完资源要释放资源</span><br>S++; <span class="hljs-comment">// 释放资源</span><br></code></pre></div></td></tr></table></figure><p>为了解决忙等现象，引入了一种不需要忙等的方案，它将 <code>S--</code> 操作提前了，先减再判断 <code>S</code> 的值，若判断的 <code>S &lt; 0</code>，就让进程进入阻塞状态（通常是设置一个阻塞进程队列），在释放资源时，若 <code>S &gt;= 0</code>，则要唤醒阻塞的进程，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(S); <span class="hljs-comment">// 申请资源</span><br>    S--; <span class="hljs-comment">// 总资源数减一</span><br>    <span class="hljs-keyword">if</span> (S &lt; <span class="hljs-number">0</span>) &#123;<br>        block; <span class="hljs-comment">// 若当前无可用资源，则将该进程阻塞</span><br>    &#125;<br>V(S); <span class="hljs-comment">// 使用完资源要释放资源</span><br>    S++; <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (S &gt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup; <span class="hljs-comment">// 若当前有可用资源，则将之前阻塞的进程唤醒</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>S是与临界区内所使用的公用资源有关的信号量：</p><ul><li><code>P(S)</code>：表示申请一个资源；</li><li><code>V(S)</code>：表示释放一个资源。</li></ul><p>一般来说初始化指定一个非负整数值，表示空闲资源总数，在信号量经典定义下，信号量 <code>S</code> 的值不能为负，后面的定义下可能为负，因为后面的定义是先做 <code>S--</code>：</p><ul><li><code>S &gt;= 0</code> ：<code>S</code> 表示可供并发进程使用的资源数；</li><li><code>S &lt; 0</code> ：<code>S</code> 绝对值就是正在等待进入临界区的进程数。</li></ul><p>在用信号量解决问题的时候，首先要分清楚这个问题是个同步问题，还是一个互斥问题，若是一个互斥问题，那么就要找到互斥的临界资源是什么，并把临界资源抽象成信号量，然后给信号量赋初值并给出正确的 P，V 操作。</p><h1 id="4-哲学家进餐问题"><a class="markdownIt-Anchor" href="#4-哲学家进餐问题"></a> 4 哲学家进餐问题</h1><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着<strong>5支筷子</strong>（注意是5支而不是5双），每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐，问题模型如下图：<br /><img src="https://img-blog.csdnimg.cn/20200316172542134.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />先考虑该问题是一个同步问题还是一个互斥问题，显然它是一个互斥问题，因为他们要共同竞争筷子使用权，那么临界资源就是筷子，把临界资源抽象成信号量为 <code>Semaphore chopStick[] = new Semaphore[5];</code>，即一个容量为 5 的数组。</p><p>哲学家思考和进餐的过程如下面的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Repeat<br>    思考;<br>    取chopStick[i]; <span class="hljs-comment">// 一根筷子</span><br>    取chopStick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]； <span class="hljs-comment">// 取旁边一根筷子</span><br>    进餐;<br>    放chopStick[i]; <span class="hljs-comment">// 放回筷子</span><br>    放chopStick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]； <span class="hljs-comment">// 放回筷子</span><br>Until <span class="hljs-literal">false</span>;<br></code></pre></div></td></tr></table></figure><p>用信号量表示的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 取左边的筷子</span><br>    chopStick[i].P();<br>    <span class="hljs-comment">// 取右边的筷子</span><br>    chopStick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].P();<br>    <span class="hljs-comment">// 进餐</span><br>    <span class="hljs-comment">// 放回左边的筷子</span><br>    chopStick[i].V();<br>    <span class="hljs-comment">// 放回右边的筷子</span><br>    chopStick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].V();<br>    <span class="hljs-comment">// 思考</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>用信号量实现保证了互斥，但是这种实现下可能会出现死锁，当五个哲学家每人拿起了他左边的筷子，则桌子上筷子全部被拿完了，而没有一个哲学家凑齐了两支筷子，造成了都无法进餐的窘境，解决这个死锁的方法有如下几种：</p><ul><li>最多允许四个哲学家同时就坐，此时至少有一个哲学家能够同时拿起两支筷子；</li><li>同时拿起两支筷子，若某个哲学家要进餐时，要求他同时拿起一双，若不能同时拿起两支，就不能进餐；</li><li>非对称解决，处于奇数位置的哲学家限制他只能拿左边的筷子， 处于偶数位置的哲学家限制他只能拿右边的筷子，这样无论如何都会有一个哲学家能同时拿起两支筷子。</li></ul><h1 id="5-生产者消费者问题"><a class="markdownIt-Anchor" href="#5-生产者消费者问题"></a> 5 生产者消费者问题</h1><p>问题描述：若干进程通过有限的共享缓冲区交换数据。其中，&quot;生产者&quot;进程不断写入，而&quot;消费者&quot;进程不断读出；共享缓冲区共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个，任何时刻只能有一个进程可对共享缓冲区进行操作，问题模型如下图：<br /><img src="https://img-blog.csdnimg.cn/20200316173814260.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />由于进程之间是共享了临界资源，所以他们之间肯定是互斥关系，所以要设置临界区保证进程间互斥访问，由于生产者生产商品给消费者使用，他们之间也存在着同步关系。</p><p>缓冲区的大小是固定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，当缓冲区满的时候，生产者是不能再生产商品的，当缓冲区为空的时候消费者是不能消费商品的，我们可以抽象以下变量：</p><ul><li><code>full</code>：表示缓冲区满的数量，也就是可用商品的个数，它的初值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ；</li><li><code>empty</code>：表示缓冲区空的数量，也就是还可以生产多少商品的个数，它的初值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ；</li><li><code>mutex</code>：表示访问缓冲区的互斥，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</li></ul><p>每生产一个商品就要进行 <code>full++</code> 操作，每消费一个商品就要进行 <code>empty++</code> 操作，<code>full</code> 和 <code>empty</code> 满足关系式 <code>full + empty = N</code>。对于生产者来说它一开始要生产商品放到缓冲区里面，而缓冲区是互斥的，生产的时候还要看缓冲区里面是否还有空位，有空位才能够生产，所以对应的有两对 P，V 操作，一对是关于互斥信号量 <code>mutex</code> 的操作，一对是关于资源信号量 <code>empty</code> 的操作。在实现的时候要注意每个进程中各个 P 操作的次序是非常重要的，应先检查资源数目，再检查是否互斥，否则可能出现死锁。</p><p>对于生产者操作的伪代码如下；</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(empty); <span class="hljs-comment">// 申请空位 empty--</span><br>P(mutex); <span class="hljs-comment">// 申请占用缓冲区</span><br><span class="hljs-comment">// 生产一个商品放入缓冲区</span><br>V(mutex); <span class="hljs-comment">// 释放占用的缓冲区</span><br>V(full); <span class="hljs-comment">// 添加商品 full++</span><br></code></pre></div></td></tr></table></figure><p>对于消费者操作的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(full); <span class="hljs-comment">// 申请消费一个商品 full--</span><br>P(mutex); <span class="hljs-comment">// 申请占用缓冲区</span><br><span class="hljs-comment">// 消费缓冲区中的一个商品</span><br>V(mutex); <span class="hljs-comment">// 释放占用的缓冲区</span><br>V(empty); <span class="hljs-comment">// 增加一个空位 empty++</span><br></code></pre></div></td></tr></table></figure><p>用信号量表示生产者的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enter</span><span class="hljs-params">(Object item)</span> </span>&#123;<br>    empty.P(); <span class="hljs-comment">// 申请缓冲区中的一个空位</span><br>    mutex.P(); <span class="hljs-comment">// 申请占用缓冲区</span><br>    <span class="hljs-comment">// 添加一个商品到缓冲区</span><br>    buffer[in] = item;<br>    in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    mutex.V(); <span class="hljs-comment">// 释放占用缓冲区</span><br>    full.V(); <span class="hljs-comment">// 增加一个商品</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>用信号量表示消费者的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    full.P(); <span class="hljs-comment">// 申请消费一个商品</span><br>    mutex.P(); <span class="hljs-comment">// 申请占用缓冲区</span><br>    <span class="hljs-comment">// 从缓冲区消费一个商品</span><br>    Object item = buffer[out];<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>    mutex.V(); <span class="hljs-comment">// 释放占用的缓冲区</span><br>    empty.V(); <span class="hljs-comment">// 增加一个空位</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-读写问题"><a class="markdownIt-Anchor" href="#6-读写问题"></a> 6 读写问题</h1><p>问题描述：对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个。</p><p>读写问题存在以下三种关系：</p><ul><li><strong>读者和写者</strong>：互斥关系，写者在写的时候读者不可以读，读者在读的时候写者不可以写；</li><li><strong>写者和写者</strong>：互斥关系，同一时刻只能有一个写者进行写操作；</li><li><strong>读者和读者</strong>：没有限制，多个读者可以同时读。</li></ul><p>那么可以从两个方面来考虑这个问题，即有读者来会怎么样和有写者来会怎么样。</p><p>当有读者来的时候：</p><ul><li>如果当前系统中没有读者也没有写者，那么新来的读者可以直接读，一旦这个读者开始读的时候，后面来的读者都可以读，但是后来的写者是不可以写的；</li><li>当一个读者到来的时候，发现有一个写者正在等待，因为之前已经到来了读者并且现在在读，那么这个时候来的读者便可以直接读；</li><li>当一个读者到来的时候，发现有一个写者正在写，那么该读者就不能读，并且后面来的读者都要等待，除非这个写者写完。</li></ul><p>当写者到来时：</p><ul><li>若当前没有读者，写者可以直接写；</li><li>若当前有读者，写者便要等待读者读完；</li><li>若当前正有写者在写，那么该写者要等待。</li></ul><p>总结来说就是写者是跟任何人互斥的，读者与读者是允许的，并且可以发现<strong>只有第一个和最后一个读者是会影响写者的</strong>，那么如何知道哪个读者是第一个来的，哪个读者是最后一个走的呢？我们的解决方法是设置一个变量来统计读者的个数，初值可以设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，来一个读者就加一，走一个读者就减一，这里引入一个共享变量必然会成为临界资源，对于这个临界资源是肯定要对它进行保护的，采用的信号量机制如下：</p><ul><li>信号量 <code>Wmutex</code> 表示&quot;允许写&quot;，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li><li>公共变量 <code>Rcount</code> 表示“正在读”的进程数，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li><li>信号量 <code>Rmutex</code> 为了保护临界资源 <code>Rcount</code>，它表示对  <code>Rcount</code> 的互斥操作，它的初值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ul><p>写者的操作伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(Wmutex); <span class="hljs-comment">// 申请写信号量</span><br>    write; <span class="hljs-comment">// 写</span><br>V(Wmutex);  <span class="hljs-comment">// 释放写信号量</span><br></code></pre></div></td></tr></table></figure><p>读者的操作相对复杂，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">P(Rmutex); <span class="hljs-comment">// 申请对 Rcount 的使用</span><br>    <span class="hljs-keyword">if</span> (Rcount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前读者是第一个读者</span><br>        <span class="hljs-comment">// 若允许他读，则要不允许后来的写者写</span><br>        <span class="hljs-comment">// 要将写操作的信号量做 P 操作</span><br>        P(Wmutex);<br>    &#125;<br>    ++Rcount; <span class="hljs-comment">// 读者数加一，上下对 Rmutex 的P，V操作实际上是为了保护 Rcount</span><br>V(Rmutex);<br>    …<br>    read; <span class="hljs-comment">// 读</span><br>    …<br>P(Rmutex);<br>    --Rcount; <span class="hljs-comment">// 读完之后读者数减一，上下对 Rmutex 的P，V操作实际上是为了保护 Rcount</span><br>    <span class="hljs-keyword">if</span> (Rcount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前读者是最后一个离开的读者</span><br>        <span class="hljs-comment">// 此时应该释放写操作，对写操作做 V 操作</span><br>        V(Wmutex);<br>    &#125;<br>V(Rmutex);<br></code></pre></div></td></tr></table></figure><h1 id="7-pv操作总结"><a class="markdownIt-Anchor" href="#7-pv操作总结"></a> 7 P，V操作总结</h1><p>信号量 <code>S</code> 为一个整型的变量，它描述的是当前可用资源的数目，当 <code>S &gt; 0</code> 时表示有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 个资源可用，当 <code>S = 0</code> 时表示无资源可用，当 <code>S &lt; 0</code> 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">| S |</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span>表示 <code>S</code> 等待队列中的进程个数，<code>P(S)</code> 表示申请一个资源，<code>V(S)</code> 表示释放一个资源，信号量的初值应该大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。</p><p>P，V 操作必须<strong>成对出现</strong>，有一个 P 操作就一定有一个 V 操作，且有以下规律：</p><ul><li><strong>当为互斥操作时</strong>：它们处于同一进程；</li><li><strong>当为同步操作时</strong>：它们不在同一进程中出现。</li></ul><p>对于前后相连的两个<code>P(S1)</code> 和 <code>P(S2)</code>，顺序是至关重要的，同步 P 操作应该放在互斥 P 操作前（如生产者消费者问题）。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第五章：CPU调度</title>
    <link href="/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/"/>
    <url>/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-cpu调度基本概念"><a class="markdownIt-Anchor" href="#1-cpu调度基本概念"></a> 1 CPU调度基本概念</h1><h2 id="11-基本概念"><a class="markdownIt-Anchor" href="#11-基本概念"></a> 1.1 基本概念</h2><p>CPU调度就是就从就绪队列中选择一个进程来分配 CPU 的过程，进行 CPU 调度的原因是为了实现多道，使得 CPU 有更高的利用率，之所以进程能够进行 CPU 调度是因为进程的特点，进程执行过程中分为两个脉冲一个是<strong>CPU脉冲 (CPU Burst)</strong>，一个是 <strong>I/O 脉冲 (I/O Burst)</strong>，即在 CPU 上执行和等待 I/O ，进程的执行以 CPU 脉冲开始，其后跟着 I/O 脉冲，进程的执行就是在这两个状态之间进行转换，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200315182708433.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />观察 CPU 脉冲的统计后发现，CPU 脉冲的分布，在系统中存在许多短 CPU 脉冲，只有少量的长 CPU 脉冲，比如 I/O 型作业具有许多短 CPU 脉冲，而 CPU 型作业则会有几个长 CPU 脉冲，这个分布规律对 CPU 调度算法的选择是非常重要的，下图是对 CPU 脉冲的统计直方图，横轴是时间，竖轴是频率，可以发现频率在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">8ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的高频脉冲是比较多的：<br /><img src="https://img-blog.csdnimg.cn/20200315183010123.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="12-cpu调度的时机"><a class="markdownIt-Anchor" href="#12-cpu调度的时机"></a> 1.2 CPU调度的时机</h2><p>当 CPU 空闲时，操作系统就选择内存中的某个就绪进程，并给其分配 CPU，以下是进程状态转换图，当某个进程从 <code>running</code> 状态离开时，就代表当前 CPU 就空闲了，图中红色和蓝色的箭头都代表着会发生 CPU 调度：<br /><img src="https://img-blog.csdnimg.cn/20200315193044255.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />CPU 的调度可能发生在以下情况：</p><ul><li><strong>从运行转到等待 (Switches from running to waiting state)</strong>：非抢占式调度；</li><li><strong>从运行转到就绪 (Switches from running to ready state)</strong>：抢占式调度，时间片到；</li><li><strong>从等待转到就绪 (Switches from waiting to ready)</strong>：抢占式调度，若某个在就绪队列的进程优先级较高，则会抢占 CPU，所以是抢占式调度；</li><li><strong>终止运行 (Terminates)</strong>：非抢占式调度。</li></ul><h2 id="13-cpu调度方案"><a class="markdownIt-Anchor" href="#13-cpu调度方案"></a> 1.3 CPU调度方案</h2><p>CPU调度方案分为以下两种：</p><ul><li><strong>非抢占方式 (nonpreemptive)</strong>：把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机，其优点是实现简单、系统开销小，适用于大多数批处理系统环境，缺点是难以满足紧急任务的要求，不适用于实时、分时系统要求；</li><li><strong>抢占方式 (Preemptive mode)</strong>：允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程。</li></ul><p>对于抢占方式，抢占有如下的原则：</p><ul><li><strong>时间片原则</strong>：各进程按时间片运行，当一个时间片用完后，便停止该进程的执行而重新进行调度，这个原则适用于分时系统；</li><li><strong>优先权原则</strong>：通常对一些重要的和紧急的进程赋予较高的优先权。当这种进程进入就绪队列时，如果其优先权比正在执行的进程优先权高，便停止正在执行的进程，将处理机分配给优先权高的进程，使之执行；</li><li><strong>短作业优先原则</strong>：当新到达的作业比正在执行的作业明显短时，将暂停当前长作业的执行，将处理机分配给新到的短作业，使之执行。</li></ul><h1 id="2-cpu调度算法"><a class="markdownIt-Anchor" href="#2-cpu调度算法"></a> 2 CPU调度算法</h1><p>设计 CPU 调度算法的性能指标有如下几点：</p><ul><li><strong>CPU利用率</strong>：使 CPU 尽可能的忙碌；</li><li><strong>吞吐量</strong>：单位时间内运行完的进程数；</li><li><strong>周转时间</strong>：进程从提交到运行结束的全部时间 ；</li><li><strong>等待时间</strong>：进程在就绪队列中等待调度的时间片总和；</li><li><strong>响应时间</strong> ：从进程提出请求到首次被响应的时间段，在分时系统环境下不是输出完结果的时间。</li></ul><blockquote><p>注：调度算法影响的是等待时间 ， 而不能影响进程真正使用 CPU 的时间和 I/O 时间。</p></blockquote><h2 id="21-先来先服务fcfs"><a class="markdownIt-Anchor" href="#21-先来先服务fcfs"></a> 2.1 先来先服务(FCFS)</h2><p>先来先服务 (First-Come-First-Served)，其算法思想和字面意思一样，就是<strong>先到来的进程，先被调度</strong>，这是最简单的调度算法，FCFS 属于非抢占方式，一旦一个进程占有处理机，它就一直运行下去，直到该进程完成或者因等待某事件而不能继续运行时才释放处理机。FCFS 算法易于实现，表面上很公平 ，实际上有利于长作业，不利于短作业；有利于 CPU 繁忙型，不利于 I/O 繁忙型，可以看下面的例子。</p><p>假设有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 三个进程，所需的 CPU 脉冲时间分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，如下表：</p><table><thead><tr><th>进程</th><th>CPU脉冲时间</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>24</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3</td></tr></tbody></table><p>现假设三个进程到来的顺序是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么该调度的 Gantt 图如下：<br /><img src="https://img-blog.csdnimg.cn/20200315205128644.png" alt="在这里插入图片描述" style="zoom:60%;" /><br />各进程的等待时间如下表：</p><table><thead><tr><th>进程</th><th>等待时间</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>24</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>27</td></tr></tbody></table><p>平均等待时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>24</mn><mo>+</mo><mn>27</mn></mrow><mn>3</mn></mfrac><mo>=</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">t=\frac{0 + 24 + 27}{3}=17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span>。</p><p>现假设三个进程到来的顺序是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么该调度的 Gantt 图如下：<br /><img src="https://img-blog.csdnimg.cn/20200315205538192.png" alt="在这里插入图片描述" style="zoom:60%;" /><br />各进程的等待时间如下表：</p><table><thead><tr><th>进程</th><th>等待时间</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>6</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>3</td></tr></tbody></table><p>平均等待时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mn>6</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>3</mn></mrow><mn>3</mn></mfrac><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">t=\frac{6 + 0 + 3}{3}=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p><p>由上面两个例子可以看出，在先来先服务算法中，进程到来的次序对平均等待时间的影响是很大的，这里有个专业名词叫做 <strong>护航效应 (Convoy effect)</strong>。</p><blockquote><p><strong>护航效应 (Convoy effect)</strong>：假设有一个 CPU 进程和许多 I/O 型进程，当 CPU 进程占用 CPU 运行时， I/O 型进程可能完成了其 I/O 操作，回到就绪队列等待 CPU， I/O 设备空闲，CPU 进程释放 CPU 后， I/O 型进程陆续使用 CPU，并很快转为 I/O 操作，CPU 空闲。</p></blockquote><p>在这种情况下，CPU 和 I/O 设备并没有得到有效的利用。</p><h2 id="22-短作业优先sjf"><a class="markdownIt-Anchor" href="#22-短作业优先sjf"></a> 2.2 短作业优先(SJF)</h2><p>短作业优先 (Shortest-Job-First)，其算法思想是关联到每个进程下次运行的 CPU 脉冲长度，调度最短的进程，由于进程是不断调入到就绪队列中的，其整个就绪队列中的最短作业，也是动态变化的，此时就要面临一个问题了，若现在到来了一个所需 CPU 脉冲时间最短的一个进程，那么是让当前执行的进程让位，还是等当前进程执行完再执行，所以有如下两种策略：</p><ul><li><strong>非抢占式调度</strong>：一旦进程拥有 CPU ， 它的使用权限只能在该 CPU 脉冲结束后让出；</li><li><strong>抢占式调度</strong> ：发生在有比当前进程剩余时间片更短的进程到达时，也称为最短剩余时间优先调度。</li></ul><p>短作业优先算法是最优的，因为对一组指定的进程而言，它给出了最短的平均等待时间，如下面的例子：</p><p>现有四个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，他们的到达时间和所需 CPU 脉冲时间如下表：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>CPU脉冲时间</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>0</td><td>7</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2</td><td>4</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>4</td><td>1</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>5</td><td>4</td></tr></tbody></table><p>若采用抢占式的调度，其调度 Gantt 图如下：<br /><img src="https://img-blog.csdnimg.cn/20200315211403893.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />平均等待时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mn>9</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>2</mn></mrow><mn>4</mn></mfrac><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">t=\frac{9 + 1 + 0 + 2}{4}=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p><p>若采用非抢占式的调度，其调度 Gantt 图如下：<br /><img src="https://img-blog.csdnimg.cn/20200315211626608.png" alt="在这里插入图片描述" style="zoom: 57%;" /><br />平均等待时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mn>0</mn><mo>+</mo><mn>6</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>7</mn></mrow><mn>4</mn></mfrac><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">t=\frac{0 + 6 + 3 + 7}{4}=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>。</p><p>虽说短作业优先调度算法是最优的算法，但是实际上在实现起来确实很难的，因为要不断的统计各个进程所需的 CPU 脉冲时间，这显然实现难度高，就算能实现，其开销也会非常大，所以实际应用中是估计进程所需时间，可以通过先前的 CPU 脉冲长度及计算指数均值进行估计。</p><p>综上所述，采用短作业优先有利于系统减少平均周转时间，提高系统吞吐量，一般情况下短作业优先调度算法比先来先服务算法调度算法的效率要高一些，但实现相对要困难些。如果作业的到来顺序及运行时间不合适，会出现<strong>饥饿现象</strong>，例如，系统中有一个运行时间很长的进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，和几个运行时间小的进程，然后，不断地有运行时间小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的进程的到来，这样，进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就因得不到调度而饿死。另外，进程运行的估计时间也有问题。</p><h2 id="23-优先级"><a class="markdownIt-Anchor" href="#23-优先级"></a> 2.3 优先级</h2><p>上面所讲的短作业优先算法实际上是优先级算法的一个特例，短作业优先算法将作业所需时间定为衡量优先级的量，表示优先级的量一般为一个整数，这里假定越小的数优先级越高，下面 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">P_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 五个进程的调度状况如下：</p><table><thead><tr><th>进程</th><th>CPU脉冲时间</th><th>优先级</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>10</td><td>3</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>1</td><td>1</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>2</td><td>4</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>1</td><td>5</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">P_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>5</td><td>2</td></tr></tbody></table><p>根据优先级，其调度顺序为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">P_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，平均等待时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8.2</mn></mrow><annotation encoding="application/x-tex">8.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">2</span></span></span></span> 。</p><p>那么进程的优先级如何确定呢？通常在进程创建时确定，且在整个生命期中保持不变，这种叫<strong>静态优先级</strong>，静态优先级就会出现饥饿问题，即某个进程若优先级非常低，它几乎永远得不到 CPU 调度。</p><blockquote><p>一个很有意思的例子：当 MIT 的 IBM7094 机器于1973 年关掉时，人们发现一个于1967年提交的一个低优先权的进程还没有得到运行。</p></blockquote><p>解决方法是<strong>老化</strong>，根据进程等待时间的延长提高其优先数，也就是<strong>动态优先级</strong>，优先级会根据等待时间不断调整。考虑改变优先级的因素通常有进程的等待时间，已使用 CPU 的时间，资源使用情况等。</p><h2 id="24-时间片轮转rr"><a class="markdownIt-Anchor" href="#24-时间片轮转rr"></a> 2.4 时间片轮转(RR)</h2><p>时间片轮转 RR (Round Robin) 算法主要用在分时系统里，这个算法的思想是每个进程将得到小单位的 CPU 时间 (时间片)，通常为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 毫秒。时间片用完后，该进程将被抢占并插入就绪队列末尾。</p><p>例如有四个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 如下表，设时间片大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>：</p><table><thead><tr><th>进程</th><th>CPU脉冲时间</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>53</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>17</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>68</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td>24</td></tr></tbody></table><p>其调度 Gantt 图如下：<br /><img src="https://img-blog.csdnimg.cn/20200315214436798.png" alt="在这里插入图片描述" style="zoom: 60%;" /><br />一般来说，时间片轮转调度算法的平均周转时间比短作业优先调度算法长，但响应时间要短一些。</p><p>对于时间片轮转算法，确定时间片大小是非常重要的，若时间片过大，则每个进程都能在单个时间片能完成，则时间片轮转等价于先来先服务算法，若时间片过小，则各个进程要频繁的切换，造成大量的资源开销。</p><h2 id="25-多级队列和多级反馈队列"><a class="markdownIt-Anchor" href="#25-多级队列和多级反馈队列"></a> 2.5 多级队列和多级反馈队列</h2><p>多级队列的意思是把进程根据其某种属性进行分类，每一类的进程都会组成一个就绪队列，也就是说在操作系统中会有多个就绪队列，每个进程固定的处在自己所属的队列中，对于不同的队列，也可以有自己专属的调度算法，那么此时就要进行队列的调度，可以给每个队列设置不同的优先级，若是固定优先级，则会产生饥饿问题。那么另一种解决方案就是基于时间片的算法，给定时间片调度，即个队列得到一定的 CPU 时间，进程在给定时间内执行：<br /><img src="https://img-blog.csdnimg.cn/20200315224321674.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />若某个进程在一个优先级较低的队列中，那么它就会一直处于饥饿状态，解决方案是多级反馈队列调度，存在多个就绪队列，具有不同的优先级，各自按时间片轮转法调度，它与多级队列的不同是它<strong>允许进程在队列之间移动</strong>，当一个进程执行完一个完整的时间片后被抢占处理器，<strong>被抢占的进程优先级降低一级而进入下级就绪队列，如此继续，直至降到进程的基本优先级</strong>。而一个进程从阻塞态变为就绪态时要提高优先级，最后会将 I/O 型和交互式进程留在较高优先级队列：<br /><img src="https://img-blog.csdnimg.cn/20200315224630398.png" alt="在这里插入图片描述" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第四章：线程</title>
    <link href="/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线程的引入"><a class="markdownIt-Anchor" href="#1-线程的引入"></a> 1 线程的引入</h1><h2 id="11-线程的由来"><a class="markdownIt-Anchor" href="#11-线程的由来"></a> 1.1 线程的由来</h2><p>前面章节提到，引入进程是为了解决程序并发所出现的一些问题，进程具有两个基本的属性：</p><ul><li>进程是一个拥有资源的独立单位，它可独立分配虚地址空间、主存和其它相关信息；</li><li>进程是一个可独立调度和分派的基本单位。</li></ul><p>正是因为进程具有这两个基本属性，所以进程成为并发执行的基本单位， 在一些早期的操作系统中，比如大多数UNIX系统、Linux等，进程同时具有这两个属性，由于进程是一个资源的拥有者 ，因而在进程创建、撤销、调度切换时，系统需要付出较大的时空开销，所以进程的数目不宜过多，进程切换频率不宜过高，否则会限制并发程度，操作系统的设计目标是提高并发度，减小系统开销，显然进程还不能做到完全的高效，所以引入了<strong>线程</strong>的概念。</p><p>那么有没有一种方法能够既提高系统并发，还能减少系统开销呢？我们采用的方法是<strong>将进程的两个基本属性分开</strong>，对于拥有资源的基本单位，不对其进行频繁切换，对于调度的基本单位，不作为拥有资源的单位，“轻装上阵”，引入线程以小的开销来提高进程内的并发程度。</p><p>在没有引入线程之前，进程作为资源分配单位（存储器、文件）和 CPU 调度单位。当引入线程后把线程作为CPU 调度单位，而进程只作为其他资源分配单位。相比进程，线程只拥有必不可少的资源，如：线程状态、程序计数器、寄存器上下文和栈，线程同样具有就绪、阻塞和执行三种基本状态，一个进程可以创建多个线程，线程与同属一个进程的其它线程共享进程拥有的全部资源，并且这些线程可以并发执行。</p><h2 id="12-线程的特点"><a class="markdownIt-Anchor" href="#12-线程的特点"></a> 1.2 线程的特点</h2><p>减小并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度，因为线程有如下特点：</p><ul><li>线程的创建时间比进程短；</li><li>线程的终止时间比进程短；</li><li>同进程内的线程切换时间比进程短；</li><li>由于同进程内线程间共享内存和文件资源，可直接进行不通过内核的通信；</li><li>一个多线程的应用在执行中，即使其中的某个线程阻塞，其他的线程还可继续执行，从而提高响应速度；</li><li>同一进程的多个线程共享该进程的内存等资源；</li><li>创建和切换线程的开销要低于进程。比如，Solaris 中进程创建时间是线程创建的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 倍，进程切换时间是线程切换的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 倍；</li><li>多线程更适用于多处理机结构。</li></ul><h2 id="13-线程的定义"><a class="markdownIt-Anchor" href="#13-线程的定义"></a> 1.3 线程的定义</h2><p>线程（轻型进程）是 CPU 运用的一个基本单元，包括：</p><ul><li>程序计数器 (program counter)；</li><li>寄存器集 (register set)；</li><li>栈空间 (stack space)。</li></ul><p>一个线程与它的对等线程共享如下内容：</p><ul><li>代码段 (code section)；</li><li>数据段 (data section)；</li><li>操作系统资源 (operating-system resources)。</li></ul><p>传统的或重型进程等价于只有一个线程的任务，下图是单线程和多线程的对比，可以从图中看到多个线程共享<code>code，data，files</code>，并且每个线程有自己的 <code>registers，stack</code>：<br /><img src="https://img-blog.csdnimg.cn/20200315141603124.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="14-进程和线程的比较"><a class="markdownIt-Anchor" href="#14-进程和线程的比较"></a> 1.4 进程和线程的比较</h2><ul><li><strong>并发性</strong>：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量；</li><li><strong>拥有资源</strong>：进程是拥有资源的独立单位，而线程只拥有一些必不可少的资源；</li><li><strong>系统开销</strong>：在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等。因此，操作系统所付出的开销将明显地大于在创建或撤消线程时的开销；</li><li><strong>地址空间和其他资源（如打开文件）</strong>：进程间相互独立，同一进程的各线程间共享，某进程内的线程在其他进程不可见；</li><li><strong>通信</strong>：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信，需要进程同步和互斥手段的辅助，以保证数据的一致性；</li><li><strong>调度</strong>：线程上下文切换比进程上下文切换要快得多，下图是线程切换和进程切换的示意图，当单线程进程需要切换的时候，整块内容都需要切换，当多线程进行切换的时候，只需要切换单个线程内容，即虚线框内的内容。<br /><img src="https://img-blog.csdnimg.cn/20200315142206932.png" alt="在这里插入图片描述" style="zoom:67%;" /></li></ul><h1 id="2-内核线程和用户线程"><a class="markdownIt-Anchor" href="#2-内核线程和用户线程"></a> 2 内核线程和用户线程</h1><p>线程是一个轻型的进程，引入线程是为了进一步提高系统并发，从而提高系统效率，线程在实现的时候分为两种：</p><ul><li>内核支持的线程 (Kernel-supported threads)；</li><li>用户级线程 (User-level threads)：在内核之上，通过用户级的库调用。</li></ul><h2 id="21-内核线程"><a class="markdownIt-Anchor" href="#21-内核线程"></a> 2.1 内核线程</h2><p>内核线程由内核支持，在内核空间执行线程创建、调度和管理，<strong>当线程是内核线程时，才真正的是 CPU 调度的基本单位</strong>，这么说是因为后面要讲到的用户线程并不是 CPU 调度的基本单位。内核线程是依赖于操作系统的，这个时候内核维护进程和线程的上下文信息，线程切换由内核完成，一个线程发起系统调用而阻塞，不会影响其他线程的运行，时间片分配给线程，所以多线程的进程获得更多 CPU 时间（线程作为CPU调度的基本单位，每个线程都会分得时间片，所以线程越多的进程，分到的CPU时间越多）。</p><h2 id="22-用户线程"><a class="markdownIt-Anchor" href="#22-用户线程"></a> 2.2 用户线程</h2><p>用户线程是由用户级线程库进行管理的线程，这个时候线程库提供对线程创建、调度和管理的支持，无需内核支持，因此<strong>用户线程不是 CPU 调度的基本单位</strong>，此时进程是 CPU 调度的基本单位。</p><p>由于用户线程不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。调度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态核心态切换，所以速度特别快。</p><p>用户线程的维护由应用进程完成，内核不了解用户线程的存在，用户线程切换不需要内核特权，用户线程的缺点是如果内核是单线程的，那么一个用户线程发起系统调用而阻塞，则整个进程阻塞，此时时间片分配给进程，多线程则每个线程就慢。</p><h2 id="23-两者比较"><a class="markdownIt-Anchor" href="#23-两者比较"></a> 2.3 两者比较</h2><ul><li><strong>调度方式</strong>：内核线程的调度和切换与进程的调度和切换十分相似，用户线程的调度不需操作系统的支持；</li><li><strong>调度单位</strong>：用户线程的调度以进程为单位进行，在采用时间片轮转调度算法时，每个进程分配相同的时间片。对内核级线程，每个线程分配时间片。</li></ul><h1 id="3-线程模型"><a class="markdownIt-Anchor" href="#3-线程模型"></a> 3 线程模型</h1><p>用户线程是在用户空间去实现的，有关于用户线程的所有操作都是在用户空间里实现的，那么这样的用户线程如果要用到操作系统提供的功能的时候，它通常是要映射到内核空间去，就要在用户线程和内核线程之间做映射，在映射过程中有以下三种模式：</p><ul><li><strong>多对一  (Many-to-One)</strong>：多个用户线程映射到内核线程上，任一时刻只能有一个线程可以访问内核 (并发性低)，一个用户线程发起系统调用而阻塞，则整个进程阻塞：<br /><img src="https://img-blog.csdnimg.cn/20200315173202325.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><strong>一对一 (One-to-One)</strong>：每个用户线程对应一个内核线程，提供了更好的并发性，一个用户线程发起系统调用而阻塞时允许另一个线程运行，每创建一个用户级线程需创建一个相应的内核线程，带来了额外开销，所以许多系统限制应用中的线程数目：<br /><img src="https://img-blog.csdnimg.cn/20200315173409936.png" alt="在这里插入图片描述" style="zoom:80%;" /></li><li><strong>多对多 (Many-to-Many)</strong>：为了克服上述两种方式的缺点，引入了多对多模型，不限制应用的线程数、多个线程可以并发：<br /><img src="https://img-blog.csdnimg.cn/20200315173636852.png" alt="在这里插入图片描述" style="zoom:80%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第三章：进程</title>
    <link href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-进程概念"><a class="markdownIt-Anchor" href="#1-进程概念"></a> 1 进程概念</h1><p>操作系统的基本特性是并发与共享，即在系统中同时存在几个相互独立的程序，他们交叉地运行并共享资源，在这样的过程中就会出现诸多问题，比如多个程序就要进行资源的竞争，程序之间的合作和协同，程序之间的通信，要解决这些问题，用程序的概念已经不能描述程序在内存中运行的状态 ，必须引入新的概念，即<strong>进程</strong>。</p><h2 id="11-顺序执行环境"><a class="markdownIt-Anchor" href="#11-顺序执行环境"></a> 1.1 顺序执行环境</h2><p><strong>顺序环境</strong>计算机系统只有一个程序在运行，该程序独占系统中所有资源，其执行不受外界影响，下图是顺序执行的两个作业的执行过程图：<br /><img src="https://img-blog.csdnimg.cn/2020031415422352.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />顺序执行的特征：</p><ul><li><strong>顺序性</strong>：按照程序结构所指定的次序（可能有分支或循环）；</li><li><strong>封闭性</strong>：独占系统的资源；</li><li><strong>可再现性</strong>：初始条件相同则结果相同。</li></ul><h2 id="12-并发执行环境"><a class="markdownIt-Anchor" href="#12-并发执行环境"></a> 1.2 并发执行环境</h2><p><strong>并发环境</strong>一定时间内，物理机器上有两个或两个以上的程序同处于开始运行但尚未结束的状态，并且次序不是事先确定的，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/202003141545256.png" alt="在这里插入图片描述"  /><br />并发执行的特征：</p><ul><li><strong>间断(异步)性</strong>：“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li><li><strong>失去封闭性</strong>：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征；</li><li><strong>失去可再现性</strong>：失去封闭性导致失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征。</li></ul><blockquote><p>例如：观察者/报告者，有两个循环程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，它们共享一个变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>。程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 每执行一次时都要做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">＝</mi><mi>N</mi><mi mathvariant="normal">＋</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">N＝N＋1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">＝</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">＋</span><span class="mord">1</span></span></span></span> 操作；程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 每执行一次时，都要做 <code>print(N)</code> 操作，然后再将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 置成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 以不同的速度运行。可能出现多报或漏报。（假定某时刻变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> ）：</p><ul><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 之前，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=6，N=6，N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 之后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>5</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=5，N=0，N=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li><li><strong>程序执行为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 在 <code>print(N)</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 之间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>5</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>6</mn><mi mathvariant="normal">，</mi><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=5，N=6，N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li></ul></blockquote><p>因此多道程序设计对操作系统提出了新的要求：</p><ul><li>如何描述并发程序的执行：引入进程及其状态；</li><li>如何实现并发程序运行：进程控制与调度；</li><li>如何处理资源的竞争与程序间的合作：并发控制与通信；</li><li>如何解决死锁：死锁策略。</li></ul><h2 id="13-进程的定义"><a class="markdownIt-Anchor" href="#13-进程的定义"></a> 1.3 进程的定义</h2><p>为了描述程序在并发执行时对系统资源的共享，我们需要一个<strong>描述程序执行时动态特征</strong>的概念，这就是<strong>进程</strong>，一个具有一定独立功能的<strong>程序</strong>在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程，相比程序，程序是一个静态的实体，而进程是一个动态的实体，引入多进程，提高了对硬件资源的利用率，但又带来额外的空间和时间开销，增加了操作系统的复杂性。一个进程包括如下内容：</p><ul><li>程序代码 (Program code)；</li><li>当前活动 (Current activity)；</li><li>相关数据 (Related data)：栈、堆、数据段，栈通常是一些临时数据，如函数参数，返回地址，局部变量等，堆通常是程序运行时申请的动态内存，数据段通常是全局变量。</li></ul><p>进程和程序的区别：</p><ul><li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件、静态和可以复制；</li><li><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存；</li><li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）；</li><li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><p>进程的特征：</p><ul><li><strong>结构特征</strong>：进程实体=程序段+相关的数据段+PCB；</li><li><strong>动态性</strong>：进程的实质是进程实体的一次执行过程，因此动态性是进程的最基本的特征；</li><li><strong>并发性</strong>：多个进程实体同存在于内存中，且能在一段时间内同时运行。是最重要的特征；</li><li><strong>独立性</strong>：指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位；</li><li><strong>异步性</strong>：进程按各自独立的、不可预知的速度向前推进。</li></ul><p>进程描述信息：</p><ul><li>处于某种状态（运行、就绪、等待）；</li><li>进程控制块 PCB（数据结构）；</li><li>进程的执行程序（一个可执行文件）；</li><li>进程位于某个队列（就绪、等待某事件队列）；</li><li>占用某些系统资（内存，打开某些文件、处理机、外设）。</li></ul><h1 id="2-进程状态"><a class="markdownIt-Anchor" href="#2-进程状态"></a> 2 进程状态</h1><p>进程在执行时，会不断地改变其状态，进程有以下的状态：</p><ul><li><strong>新建 (new)</strong>：创建进程，构造了进程标识符，创建了管理进程所需的表格；</li><li><strong>就绪 (ready)</strong>：进程等待分配处理器，存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行（有多个进程处于此状态），如进程所分配的时间片用完后，会用运行状态转换为就绪状态，等待下一次分配时间片；</li><li><strong>运行 (running)</strong>：指令在执行，当进程由调度/分派程序分派后，得到 CPU 控制权，它的程序正在运行（在系统中，总只有一个进程处于此状态）；</li><li><strong>等待 (waiting)</strong>：进程等待某些事件发生，进程正在等待某个事件的发生（如等待 I/O 的完成），而暂停执行，即使给它 CPU 时间，它也无法执行；</li><li><strong>终止 (terminated)</strong>：进程执行完毕，终止后进程移入该状态，它不再有执行资格，表格和其它信息暂时由辅助程序保留，如为处理用户帐单而累计资源使用情况的帐务程序，当数据不再需要后，进程 (和它的表格) 被删除。</li></ul><p>各个状态之间的转换关系：<br /><img src="https://img-blog.csdnimg.cn/20200314162920463.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h1 id="3-进程控制块pcb"><a class="markdownIt-Anchor" href="#3-进程控制块pcb"></a> 3 进程控制块PCB</h1><p>上面说到进程有多种状态，但操作系统该如何知晓当前进程的状态呢？所以我们要把进程的状态保存下来，这里就引入了一种描述进程信息的数据结构，<strong>进程控制块PCB</strong> (Process Control Block)：</p><ul><li>PCB (Process Control Block) 是一个专门的数据结构，系统用它来记录进程的外部特征，描述进程的运动变化过程；</li><li>PCB 是进程管理和控制的最重要的数据结构，在创建进程时，建立 PCB，并伴随进程运行的全过程，直到进程撤消而撤消，<strong>跟随进程的生命周期</strong>；</li><li>PCB 是系统感知进程存在的<strong>唯一</strong>标志，进程与 PCB 是一一对应的，有一个进程就会有一个 PCB，有一个 PCB就会有一个进程；</li><li>PCB 经常被系统访问，如：调度程序、资源分配程序、中断处理程序等，所以 PCB 应<strong>常驻内存。</strong></li></ul><h2 id="31-进程控制块pcb中的内容"><a class="markdownIt-Anchor" href="#31-进程控制块pcb中的内容"></a> 3.1 进程控制块PCB中的内容</h2><p>进程控制块 PCB 保存了同进程有关的信息，一般有下面这些必要内容：</p><ul><li><strong>进程状态 (Process state)</strong>：说明进程当前所处的状态；</li><li><strong>程序计数器 (Program counter)</strong>：指向执行程序的下个指令的地址；</li><li><strong>CPU寄存器 (CPU registers)</strong>：当进程因某种原因不能继续占用 CPU 时（如等待打印机），释放 CPU，这时就要将 CPU 的各种状态信息保护起来，为将来再次得到处理机恢复 CPU 的各种状态，继续运行；</li><li><strong>CPU调度信息 (CPU scheduling information)</strong>：包括CPU优先级，调度队列指针等；</li><li><strong>内存管理信息 (Memory-management information)</strong>：包括基址寄存器，界限寄存器以及页表或段表等；</li><li><strong>计账信息 (Accounting information)</strong>：包括 CPU 时间，实际使用时间，作业或进程数量等；</li><li><strong>I/O状态信息 (I/O status information)</strong>：包括分配给进程的 I/O 设备列表，打开文件列表等；<br /><img src="https://img-blog.csdnimg.cn/2020031416482165.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li></ul><h2 id="32-pcb的组织方式"><a class="markdownIt-Anchor" href="#32-pcb的组织方式"></a> 3.2 PCB的组织方式</h2><p>系统把 PCB 组织在一起，并放在内存的固定区域，就构成了 <strong>PCB 表</strong>，PCB 表的个数决定了系统中最多可同时存在的进程个数，称为系统的<strong>并发度</strong>，PCB表的组织方式有两种：</p><ul><li><strong>链接方式</strong>：一般通过链表的方式；</li><li><strong>索引方式</strong>：建立索引表。</li></ul><h1 id="4-操作系统调度"><a class="markdownIt-Anchor" href="#4-操作系统调度"></a> 4 操作系统调度</h1><p>在操作系统中多个程序并发的执行，但在单 CPU 机器中只有一个CPU，那么到底由哪一个程序来使用 CPU 呢？这就是一个调度问题，进程一般会在下面这些队列被调度：</p><ul><li><strong>作业队列</strong>：在系统中的所有进程的集合；</li><li><strong>就绪队列</strong>：在主内存中的，就绪并等待执行的所有进程的集合；</li><li><strong>设备队列</strong>：等待某一 I/O 设备的进程队列。</li></ul><p>其实上面所讲的进程状态的变化，实际上是在这些队列上不停的迁移，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200314170547449.png" alt="在这里插入图片描述" /><br />进程调度的描述图：<br /><img src="https://img-blog.csdnimg.cn/20200314174218497.png" alt="在这里插入图片描述" style="zoom: 55%;" /><br />在操作系统的调度分为不同级别的调度：</p><ul><li><strong>长程调度（或作业调度）</strong>：选择可以进入就绪队列的进程，也可以说是从外存中选择进入内存的调度过程；</li><li><strong>短程调度（或 CPU 调度）</strong>：选择可被下一个执行并分配 CPU；</li><li><strong>中程调度</strong>：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上（ 挂起 ），降低多道程序的度。当这些进程重新具备运行条件时，再从外存上调入内存：<br /><img src="https://img-blog.csdnimg.cn/2020031417525324.png" alt="在这里插入图片描述" style="zoom:90%;" /></li></ul><p>在操作系统中进程可以分为两类：</p><ul><li><strong>I/O 型进程</strong>：花费 I/O 时间多于计算，许多短 CPU 处理；</li><li><strong>CPU 型进程</strong>：花费更多时间于计算，许多长 CPU 处理。</li></ul><p>可以试想若是调度选择的大多数都是 I/O 型进程，少数 CPU 型进程，那么各个进程会在 CPU 上执行短暂的时间后转到 I/O 设备上，此时 I/O 设备就非常的忙碌，而 CPU 就相对空闲，反之 CPU 型的进程过多，也会造成 CPU 的忙碌，而 I/O 设备的空闲，这显然不是高效的调度方式。</p><p>当进程在运行中发生了中断，如 I/O 操作，那么会执行 CPU 的切换。如下图所示，在切换时要保存当前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">PCB_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的信息，然后加入切换的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">PCB_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 信息，然后运行完成后再恢复 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>C</mi><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">PCB_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的信息：<br /><img src="https://img-blog.csdnimg.cn/20200314175440965.png" alt="在这里插入图片描述" style="zoom: 60%;" /><br />上述切换的过程，我们称为<strong>上下文切换</strong>，当 CPU 切换至另一个进程时，系统必须保存旧进程状态并为新进程调入所保留的状态，而上下文切换的时间开销较重，在切换时，系统没有做有用的工作，时间取决于硬件的支持。</p><h1 id="5-进程操作"><a class="markdownIt-Anchor" href="#5-进程操作"></a> 5 进程操作</h1><p>进程是有生命周期的：产生、运行、暂停、终止。对进程的这些操作叫进程控制，对进程的操作如下图。进程控制的职责是对系统中进程实施有效的管理，它是CPU管理的一部分（还有进程同步、通信和调度）；当系统允许多进程并发执行时，为了实现共享、协调并发进程的关系，处理机管理必须对进程实行有效的管理。<br /><img src="https://img-blog.csdnimg.cn/20200314175950745.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h1 id="6-创建进程"><a class="markdownIt-Anchor" href="#6-创建进程"></a> 6 创建进程</h1><p>进程创建的时机有以下几种：</p><ul><li><strong>作业调度</strong>：批处理系统中，作业调度程序调度到某个作业以后，就把这个作业装入内存，并分配必要的资源，创建进程，插入就绪队列；</li><li><strong>用户登录</strong>：在分时系统中，用户在终端键入登录命令后，若是合法用户，系统建立一个进程，并插入就绪队列；</li><li><strong>提供服务</strong>：用户向系统提出请求后，系统专门建立一个进程为用户服务。如打印请求；</li><li><strong>应用请求</strong>：应用进程的需要，由它自己创建一个新进程，使新进程以并发运行方式完成特定任务（输入数据并将处理结果输出到表格上）。</li></ul><blockquote><p>一个进程创建之后还可以创建进程，也就是父进程创建子进程，如此轮流创建进程下去，构成一个进程树，典型 UNIX 系统中的进程树如下图所示：<br /><img src="https://img-blog.csdnimg.cn/2020031418084236.png" alt="在这里插入图片描述" /><br />关于资源共享问题，有如下三种情况：</p><ul><li>父进程子进程共享所有的资源；</li><li>子进程共享父进程资源的子集；</li><li>父进程和子进程无资源共享。</li></ul><p>关于进程执行问题，有如下两种情况：</p><ul><li>父进程和子进程并发执行；</li><li>父进程等待，直到子进程终止。</li></ul><p>关于进程地址空间问题，有如下两种情况：</p><ul><li>子女复制双亲；</li><li>子女有一个程序被调入。</li></ul></blockquote><h1 id="7-进程通信共享存储"><a class="markdownIt-Anchor" href="#7-进程通信共享存储"></a> 7 进程通信：共享存储</h1><p>由生产者-消费者问题讨探进程之间是如何共享存储，生产者-消费者问题是一类问题的抽象，它描述的是一类事物提供另一类事物所需的资源，比如某一个进程提供计算数据，另一个进程负责计算输出结果，不提供数据就无法进行计算输出，此时提供计算数据的进程就是生产者，负责计算输出的进程就是消费者，如下图所示，这个问题抽象出来的数据模型就是<strong>共享队列</strong>：<br /><img src="https://img-blog.csdnimg.cn/202003141817488.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><h1 id="8-进程通信消息传递"><a class="markdownIt-Anchor" href="#8-进程通信消息传递"></a> 8 进程通信：消息传递</h1><p>消息传递是操作系统中的一个机制，能够使进程之间进行消息传递，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 要通信，需要建立通信连接，通过 <code>send/receive</code> 交换消息，通信链路的实现分为两种，一种是物理上的通过电子线路的实现，另一种是逻辑上的实现，我们主要考虑的是逻辑上的实现，连接的建立分为两种：</p><ul><li><p><strong>直接通信</strong>：进程必须显式的命名，如 <code>send (P, message)</code> 向进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 发消息，<code>receive(Q, message)</code> 从进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 收消息，这种情况下连接自动建立，连接精确的与一对在通信的进程相关，在每一对之间就存在一个连接，连接可以无向，但通常是双向的，这种通信方式的缺点就是受模块化限制，比如某个时候进程 P 名字被修改，那么所有代码都需要修改。直接通信也有一个特殊的通信方式就是<strong>非对称通信方式 (asymmetric communication)</strong>，也就是说发送消息的时候是显示命名的，但接收消息的时候不指明接收方。</p></li><li><p><strong>间接通信</strong>：进程双方不是直接建立连接的，而是通过一个媒介，可以想象成一个<strong>信箱</strong>或<strong>端口</strong>，每个信箱都有一个唯一的 ID，不管是发送消息还是接收消息，都是通过这个信箱来完成的，如 <code>send(A, message)</code> 为向信箱 A 发送消息，<code>receive(A, message)</code> 为从信箱 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 接收消息，此时仅当进程共有一个信箱时连接才能建立，连接可同多个进程相关，每一对进程可共享多个通信连接，连接可是无向或双向的，但是为了确定发送者和接受者的唯一性，间接通信允许一个连接最多同 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个进程相关，并且只允许一个时刻有一个进程执行接受操作，通过允许系统任意选择接收者，发送者被通知谁是接收者，这样发送方和接收方就被唯一的确定。相应的对信箱也有对应的操作，如创建新的信箱，通过信箱发送和接收消息，通信结束后销毁信箱等。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第二章：操作系统结构</title>
    <link href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <url>/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机硬件"><a class="markdownIt-Anchor" href="#1-计算机硬件"></a> 1 计算机硬件</h1><h2 id="11-计算机体系结构"><a class="markdownIt-Anchor" href="#11-计算机体系结构"></a> 1.1 计算机体系结构</h2><p>计算机的多种设备都是通过<strong>系统总线 (system bus)</strong>  连接在一起，这样就构成了一个基本的计算机系统，如下图，可以发现图中有很多的<strong>控制器 (controller)</strong>，事实上每个设备都对应着一个<strong>控制器 (controller)</strong>。<br /><img src="https://img-blog.csdnimg.cn/20200314115650167.png" alt="在这里插入图片描述" style="zoom: 55%;" /></p><p>在这样的体系结构下，有如下特征：</p><ul><li>I/O 设备与 CPU 可并行运行；</li><li>每一设备控制器负责一个设备类型；</li><li>每一设备控制器有一<strong>局部缓存 (local buffer)</strong>；</li><li>CPU 通过局部缓存与主存交换数据；</li><li>I/O 从设备到设备控制器有局部缓存；</li><li>设备控制器通过引起<strong>中断 (interrupt)</strong> 通知 CPU 操作已完成。</li></ul><h2 id="12-中断机制"><a class="markdownIt-Anchor" href="#12-中断机制"></a> 1.2 中断机制</h2><p>中断指的是 CPU 在执行程序的时候出现了某些异常突发情况，需要紧急处理，CPU 必须暂停当前的任务去处理紧急突发事件，处理完之后又返回原程序被打断的地方去继续执行，中断通常分为以下两种：</p><ul><li><strong>硬件中断 (hardware interrupt)</strong>：设备控制器通知 CPU 它所做的操作已经完成，会触发一个中断；</li><li><strong>软件中断 (software interrupt)</strong>：一种是异常，指的是系统在执行过程中出现的错误，如除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 操作或无效的内存访问，另一种是<strong>系统调用 (system call)。</strong></li></ul><p>为什么需要中断呢？为什么有了中断后就能实现多道呢？如下图，用户程序一开始是在 CPU 上执行的，当执行到某个时间点的时候（图中横轴 <code>transfer done</code>）会触发一个中断，CPU 在延迟一点时间后会收到这个中断，收到中断后会去处理这个中断，也就是会从高电平的 <code>user process executing</code> 跳到低电平 <code>I/O interrupt processing</code>，中断处理完成后又会回到原来的用户程序继续执行，有了这样的中断机制带来的好处是在 CPU 执行的过程中，I/O 设备也在执行，能够使系统更高效，响应性更好<br /><img src="https://img-blog.csdnimg.cn/20200314121222299.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><blockquote><p>为什么说有了通道技术和中断机制后才真正地实现了多道？</p><ul><li><strong>通道</strong>是一种控制外部设备的硬件结构，它独立于 CPU 运行，因此 I/O 操作能和 CPU 并行运行，但以前CPU 依然要发送指令询问通道是否完成工作，若未完成，CPU 则要一直询问直到通道工作完成，虽然引入通道技术提高了效率，但是并未实现真正的多道并行；</li><li><strong>中断</strong>和通道结合起来就实现了多道，CPU 启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，通过中断机构向 CPU 发出中断请求，CPU 则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作，这样，就真正做到了 CPU 与 I/O 设备并行工作。</li></ul></blockquote><p>现代操作系统是中断驱动的，中断将控制权转移到中断服务程序，所谓中断服务程序就是中断出现后要去执行处理的那一段程序代码，实现控制权转移的方法如下：</p><ul><li>在中断服务程序中有单独的一段代码，来确定当前中断属于哪种类型的中断；</li><li>会有一个<strong>通用的历程</strong>去检查中断信息，当中断发生时，就会调用中断服务程序；</li><li>当检查到中断时，要求能快速处理，这里的实现方法是利用<strong>中断向量 (interrupt vector)</strong>，中断向量就存储了服务历程的地址。</li></ul><p>下表列出了常见的中断向量，中断号及其功能：</p><table><thead><tr><th>中断向量</th><th>中断号</th><th>中断功能</th></tr></thead><tbody><tr><td>00~03</td><td>0</td><td>除法溢出中断</td></tr><tr><td>04~07</td><td>1</td><td>单步 (用于DEBUG)</td></tr><tr><td>08~0B</td><td>2</td><td>非屏蔽中断 (NMI)</td></tr><tr><td>0C~0F</td><td>3</td><td>断点中断 (用于DEBUG)</td></tr><tr><td>10~13</td><td>4</td><td>溢出中断</td></tr><tr><td>14~17</td><td>5</td><td>打印屏幕</td></tr><tr><td>18~1F</td><td>6，7</td><td>保留</td></tr></tbody></table><h2 id="13-io操作"><a class="markdownIt-Anchor" href="#13-io操作"></a> 1.3 I/O操作</h2><p>使用 I/O 操作需要具备以下条件：</p><ul><li>设备与设备控制器相连；</li><li>本地缓冲器，一组寄存器；</li><li>设备驱动程序。</li></ul><p>有两种常见的 I/O 操作：</p><ul><li><strong>同步 (Synchronous)</strong>：当启动 I/O 操作时，直到 I/O 操作结束后，控制权才会返回到用户程序，也就是说你运行了一个程序，但突然触发了 I/O，那么你的程序要等待这次 I/O 操作结束后，才会运行；</li><li><strong>异步 (Asynchronous)</strong>：当启动 I/O 操作时，控制权会立马转到用户程序，那么此时 I/O 操作是否运行结束是通过中断机制来实现的。</li></ul><p>下图是同步和异步的比较：<br /><img src="https://img-blog.csdnimg.cn/20200314130412353.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><h1 id="2-硬件保护"><a class="markdownIt-Anchor" href="#2-硬件保护"></a> 2 硬件保护</h1><p>当计算机执行过程中，计算机硬件需要提供一些支持能够保证计算机能够正确的运行，在早期的操作系统中为单用户系统，程序员可完全控制系统，在后来的批处理操作系统中，通过读取卡片来录入程序和数据，此时有可能会把其他程序当作当前程序的数据输入进去了，在这个时候就需要提供一些保护，而后的多道批处理系统就更为复杂，它运行多个程序并发执行，多个程序竞争某些资源，当一个程序在执行过程中，它有可能会修改到其他程序的代码或数据，甚至可能会修改操作系统，这时为了能够让计算机正确执行，必须提供一些保护。</p><p>那么解决的方法就是当程序在执行非法指令或访问不属于自己的地址空间内存时把控制权交给操作系统，甚至情况严重时可以直接终止程序。</p><h2 id="21-实现保护两状态操作"><a class="markdownIt-Anchor" href="#21-实现保护两状态操作"></a> 2.1 实现保护两状态操作</h2><p>共享系统资源要求操作系统确保当前程序不会引起其他程序的运行错误，我们的方法是<strong>两状态操作</strong>，即至少在两个运行状态之间提供硬件支持：</p><ul><li><strong>用户态 (User mode)</strong>：代表用户执行；</li><li><strong>管态，特权模式或系统模式 (Monitor mode)</strong>：代表操作系统执行。</li></ul><p>那么计算机是如何区分这两种状态呢？在计算机中实现的方法很简单，只需要一个位的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就可以区分，这个位叫做模式位 (mode bit) ，表示当前模式 <code>monitor (0) or user (1)</code>，这个模式位可以放在 <code>PSW</code> 中（PSW 是 Program Status Word 的缩写，即程序状态字），当系统引导启动时，硬件处于管态，在用户模式下执行用户进程，如下图：<br /><img src="https://img-blog.csdnimg.cn/2020031413212956.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />若在用户程序中出现了问题，就会触发中断，出现中断或陷阱，硬件切换到管态，一旦切换到管态，控制权就转交给了操作系统，由操作系统来处理这些中断错误信息，那么操作系统如何知道用户程序执行了非法操作呢？在操作系统中把只能由管态执行的指令称为<strong>特权指令 (Privileged instructions)</strong>，若用户程序执行到了特权指令，那么就可判断当前操作为非法操作，可能会引发错误，但是有时候用户程序要执行特权指令怎么办？操作系统中提供了<strong>系统调用 (system call)</strong> 方式，可以让用户程序合法的使用特权指令，<strong>系统调用实际上会触发软中断</strong>，那么就会<strong>从用户态切换到了管态</strong>，控制权也转交给了操作系统。在处于管态下，特权指令是可以直接执行的。</p><p>使用这种方法，也可以对所有的 I/O 操作进行保护，我们把所有的 I/O 操作定义为特权指令，用户不能直接用 I/O 指令，必须通过系统调用，确保用户程序不能在管态下控制计算机，下图是系统调用执行 I/O 操作的过程：<br /><img src="https://img-blog.csdnimg.cn/20200314132931819.png" alt="在这里插入图片描述"  /><br />既然系统调用是通过软中断来实现的，那么也要保护中断机制不能被破坏，所以必须保护中断向量和中断服务程序，而程序都是在内存中，所以问题也转换为了对某些内存的保护，因此要划分进程能够运行的合法空间，划分合法空间用到了两个寄存器，通俗来讲这两个寄存器就是来划分合法空间地址的起点和空间的大小，有了这两个值，那么就唯一确定了这一块内存空间：</p><ul><li><strong>基址寄存器 (base register)</strong>：指出起始地址；</li><li><strong>界限寄存器 (limit register)</strong>：指出空间大小。</li></ul><p>如下图的 <code>job2</code> 就被两个寄存器唯一确定了：<br /><img src="https://img-blog.csdnimg.cn/20200314133801309.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />在具体实现时，CPU每得到一个地址，都需要去检测该地址的合法性，流程图如下：<br /><img src="https://img-blog.csdnimg.cn/20200314133941214.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><h2 id="22-cpu保护"><a class="markdownIt-Anchor" href="#22-cpu保护"></a> 2.2 CPU保护</h2><p>需防止用户程序陷入死循环或者不调用系统服务且不将控制权返回到操作系统，解决的方法就是使用<strong>定时器 (timer)</strong>，也就是说当从管态切换到用户态时，设置了一个定时器，当定时器时间到的时候就会触发一个中断，那么控制权就会转交给操作系统，操作系统又重新获得了控制权。</p><h1 id="3-操作系统服务"><a class="markdownIt-Anchor" href="#3-操作系统服务"></a> 3 操作系统服务</h1><p>操作系统是覆盖在计算机硬件系统上的第一层软件，对于这个复杂的软件系统，必须清楚其设计的目标是什么，应该提供哪些服务，通常会考虑以下三个方面：</p><ul><li>提供的服务 (services it provides)；</li><li>为用户和程序提供的接口 (interface to users and programmers)；</li><li>各组成部分及其相互连接 (components and their interconnections)。</li></ul><h2 id="31-提供的服务"><a class="markdownIt-Anchor" href="#31-提供的服务"></a> 3.1 提供的服务</h2><p>针对用户要提供的服务：</p><ul><li><strong>用户接口 (User interface)</strong>：通过这些接口，用户能够访问到操作系统提供的功能，几乎所有的操作系统都有用户接口，常见的表现形式分为<strong>命令行 Command-Line (CLI)</strong> 和 <strong>图形用户界面 Graphics User Interface (GUI)</strong>；</li><li><strong>执行程序 (Program execution)</strong>：能够把程序调入内存，并转交给 CPU 处理的能力；</li><li><strong>I/O操作 (I/O operations)</strong>：由于用户程序不能直接执行 I/O 操作，操作系统必须提供手段完成 I/O 操作；</li><li><strong>文件系统操作 (File-system manipulation)</strong>：读、写、创建和删除文件的能力；</li><li><strong>通信 (Communications)</strong>：运行的进程在同一计算机或由网络连接的不同系统中交换信息。通过共享存储器或消息传递实现；</li><li><strong>错误检测 (Error detection)</strong>：探测在 CPU 与内存硬件中，在 I/O 设备中，或在用户程序中的错误，确保正确运算。</li></ul><p>针对提高系统效率要提供的服务：</p><ul><li><strong>资源分配 (Resource allocation)</strong>：把资源分配给多个用户或多个同时运行的作业；</li><li><strong>帐务 (Accounting)</strong>：跟踪和记录用户对资源的使用，用于帐单和统计哪些资源已经分配出去了，哪些资源是可用的等等；</li><li><strong>保护 (Protection)</strong>：确保对资源的所有访问均在控制中。</li></ul><p>下图是整个操作系统提供的服务结构图：<br /><img src="https://img-blog.csdnimg.cn/20200314135642462.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h1 id="4-系统调用"><a class="markdownIt-Anchor" href="#4-系统调用"></a> 4 系统调用</h1><p>根据上面的服务结构图可以找到 <code>system calls</code>，他处在的位置是操作系统众多服务之上，用户接口之下，它的功能就是给用户提供方法来使用系统服务，系统调用提供在运行程序和操作系统之间的接口，系统调用由于接近底层，不方便使用 ，并且不同的操作系统的系统调用使用都有差别，所以实际上大多数程序员在开发时都是直接使用 <strong>API ( level Application Program Interface)</strong>，API 实际上就是系统调用的封装，里面可能封装了一个或多个系统调用，常见的系统 API 有 Win32 API for Windows，Java API for the Java virtual machine (JVM) 等等。</p><h2 id="41-系统调用的处理过程"><a class="markdownIt-Anchor" href="#41-系统调用的处理过程"></a> 4.1 系统调用的处理过程</h2><p>系统调用的处理过程如下：</p><ol><li>当用户使用系统调用时，产生一条相应的指令；</li><li>CPU 在执行到该指令时发生<strong>中断</strong>，发出有关的信号给陷入处理机构；</li><li>处理机构在收到了 CPU 发来的信号后，启动相关的处理程序去完成该系统调用所要求的功能；</li><li>在处理系统调用之前，陷入处理机构还需保存处理机现场（PSW、PC、系统调用号、用户栈指针、通用寄存器、用户定义的参数等）。</li></ol><p>不同的系统调用对应着不同的子程序代码段，我们通过入口地址表，使每个入口地址与相应的系统程序对应，陷入处理程序用系统调用功能号查找入口地址表，得到该系统程序的入口地址，并执行之，系统调用处理结束后，要恢复处理机现场，从而用户程序可以继续执行，过程如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200314140710410.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="42-系统调用传递参数的方式"><a class="markdownIt-Anchor" href="#42-系统调用传递参数的方式"></a> 4.2 系统调用传递参数的方式</h2><p>在系统调用时，难免需要传递一些参数来实现特定的功能，有三种常用方式用于在运行程序和操作系统之间的参数传递：</p><ul><li><strong>寄存器</strong>中的参数传递，寄存器容量较小，故只适用于少量且小的参数传递；</li><li>参数存在内存的一张<strong>表</strong>中，表地址作为寄存器的参数传递，如下图所示，若传递的参数比较大的时候，先把参数放到内存里，这些参数在内存中的地址就放在寄存器 (register) 中，当使用系统调用时就会查找寄存器然后取出地址再转到内存中去寻找参数：<br /><img src="https://img-blog.csdnimg.cn/20200314141018597.png" alt="在这里插入图片描述" style="zoom: 80%;" /></li><li>程序把参数压入<strong>栈</strong>，由操作系统弹出。</li></ul><h2 id="43-系统调用的分类"><a class="markdownIt-Anchor" href="#43-系统调用的分类"></a> 4.3 系统调用的分类</h2><p>系统调用的分类如下：</p><ul><li>进程控制 (process control)；</li><li>文件管理 (file management)；</li><li>设备管理 (device management)；</li><li>信息维护 (information maintenance  )；</li><li>通信 (communications)。</li></ul><h1 id="5-操作系统结构"><a class="markdownIt-Anchor" href="#5-操作系统结构"></a> 5 操作系统结构</h1><p>这一节主要讨论的问题是操作系统中各个组件之间的关系，操作系统的早期非常简单，如 MS-DOS 以最小的空间提供最多的功能，它并不划分模块。</p><p>在 MS-DOS 中，应用程序可直接访问 BIOS 例程，来直接操纵设备，当然这受限于当时的硬件，Intel8088 没提供双模式和硬件保护，这使得 DOS 别无选择只能任由应用程序访问 BIOS，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200314141552827.png" alt="在这里插入图片描述" style="zoom: 80%;" /><br />而在 UNIX 中，受硬件功能限制，早期 UNIX 只是有限的结构化。UNIX 包括 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个分离的部分：</p><ul><li>系统程序 (Systems programs )；</li><li>内核 (The kernel)：包括了在物理硬件之上，系统调用之下的一切。提供文件系统，CPU调度，存储管理，和其他操作系统功能 ，每一层有大量的功能，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/2020031414183889.png" alt="在这里插入图片描述" style="zoom: 80%;" /></li></ul><h2 id="51-层次化系统结构"><a class="markdownIt-Anchor" href="#51-层次化系统结构"></a> 5.1 层次化系统结构</h2><p>操作系统划分为若干层，在低层上构建高层。底层（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 层）为硬件，最高层（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 层）为用户层，在设计时考虑模块化，层的选择是每层只使用低层次的功能和服务，由此分层的基本原则是每一层都使用其底层所提供的功能和服务，以便于系统调试和验证，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200314142119323.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><p>最早使用层次化操作系统的是 THE 操作系统，它有如下六层：<br /><img src="https://img-blog.csdnimg.cn/2020031414224570.png" alt="在这里插入图片描述" style="zoom:80%;" /><br />分层有如下优点：</p><ul><li>低层和高层可分别实现（便于扩充）；</li><li>高层错误不会影响到低层，便于调试、利于功能的增删改；</li><li>调用关系清晰（高层对低层单向依赖），避免递归调用，有利于保证设计和实现的正确性。</li></ul><p>分层有如下缺点：</p><ul><li>系统中所有进程的控制转移、通讯等任务全部交给系统的核心去管理，要花费一定的代价。</li></ul><h2 id="52-微内核"><a class="markdownIt-Anchor" href="#52-微内核"></a> 5.2 微内核</h2><p>微内核 (Microkernels) 对层次进行进一步的划分，通过划分系统程序和用户程序，把所有不必要的部件移出内核，形成一个小内核，微内核提供最少量的进程管理、存储管理，以及通信功能。</p><p>微内核操作系统由两大部分组成：</p><ul><li>运行在核心态的内核，即保留下来的核心功能；</li><li>运行在用户态并以 C/S 方式运行的进程层，即移出去的不必要功能。</li></ul><p>移出去的功能通过一种 Server 运行，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200314142853765.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>微内核与传统操作系统相比，有如下特点：</p><ul><li><strong>内核精巧</strong>：通常内核只由任务管理、虚存管理和进程间通信 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个部分组成。传统操作系统内核中的许多部分都被移出内核，采取服务器方式实现；</li><li><strong>面向多处理机和分布式系统</strong>：基于微内核的操作系统，在内核中引入了多处理机调度和管理机制，并引入了细粒度并发机制，即线程，使得多个处理机可以在同一个任务中并行地执行；</li><li><strong>基于客户／服务器体系结构</strong>：在微内核结构的操作系统中，任务间通信机制，消息机制是系统的基础，操作系统的各种功能都以服务器方式实现，向用户提供服务。用户对服务器的请求是以消息传递的方式传给服务器的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理第一章：操作系统概述</title>
    <link href="/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统概念"><a class="markdownIt-Anchor" href="#1-操作系统概念"></a> 1 操作系统概念</h1><h2 id="11-为什么要有操作系统"><a class="markdownIt-Anchor" href="#11-为什么要有操作系统"></a> 1.1 为什么要有操作系统</h2><p>因为计算机硬件（ 裸机 ）<strong>难于使用</strong>，用户几乎不可能使用裸机，计算机硬件只能识别 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 二进制机器码，机器码直观性差，容易出错，难于交流。因此，<strong>通常在计算机硬件之上会覆盖一层软件，以方便用户使用计算机硬件</strong>。</p><h2 id="12-什么是操作系统"><a class="markdownIt-Anchor" href="#12-什么是操作系统"></a> 1.2 什么是操作系统</h2><p>在计算机硬件中，<strong>CPU</strong>是计算机硬件的核心，是计算机系统的心脏，<strong>操作系统</strong>则是计算机软件的核心，是计算机系统的大脑。操作系统是整个计算机系统的控制中心，是计算机系统中首要的、最重要的、最复杂的系统软件，追其本质，操作系统是管理计算机硬件的<strong>程序</strong>，在计算机用户和计算机硬件之间起<strong>媒介作用</strong>的一种程序。</p><p>操作系统在整个计算机系统中所在的位置位于计算机硬件之上，应用程序之下，硬件之上的第一层软件，是对硬件的首次扩充，又是其他软件运行的基础，见下图中的 operating system 的位置：<br /><img src="https://img-blog.csdnimg.cn/20200313224303621.png" alt="在这里插入图片描述" style="zoom: 60%;" /></p><h2 id="13-计算机系统部件"><a class="markdownIt-Anchor" href="#13-计算机系统部件"></a> 1.3 计算机系统部件</h2><ul><li><strong>硬件 (Hardware )</strong>：提供基本的运算资源，如CPU，内存，I/O设备等；</li><li><strong>操作系统 (Operating system )</strong>：在各种应用程序和用户之间控制与协调对硬件的使用；</li><li><strong>应用程序 (Applications programs  )</strong>： 定义解决用户问题的资源使用方式（编译、数据库、视频游戏、事务程序等）；</li><li><strong>用户 (Users)</strong>：如人、其他计算机等。</li></ul><h2 id="14-操作系统设计的目标"><a class="markdownIt-Anchor" href="#14-操作系统设计的目标"></a> 1.4 操作系统设计的目标</h2><ul><li>执行用户程序并使用户问题更易解决；</li><li>使计算机系统更易使用；</li><li>以一种有效率的方式使用硬件。</li></ul><h2 id="15-操作系统的其他定义"><a class="markdownIt-Anchor" href="#15-操作系统的其他定义"></a> 1.5 操作系统的其他定义</h2><p>不同的地方对操作系统的定义有所差别，但都是从一些核心的角度去描绘操作系统，以下是常见的几个定义：</p><ul><li><strong>资源分配者 (Resource allocator )</strong>：管理和分配资源；</li><li><strong>控制程序 (Control program )</strong>：控制用户程序的运行和 I/O 设备的操作；</li><li><strong>内核 (Kernel)</strong>：在全时运行的一个程序（其他的是应用），因为当计算机开机后，第一个运行的程序就是操作系统，当关闭计算机时，最后一个结束的也是操作系统。</li></ul><h1 id="2-操作系统的发展"><a class="markdownIt-Anchor" href="#2-操作系统的发展"></a> 2 操作系统的发展</h1><p>并不是有了计算机就有了操作系统，操作系统从无到有、从简单到复杂、一步一步走向完善，操作系统随着计算机硬件技术的发展而发展，为满足不同的需求，出现了多种类型的操作系统，发展的核心动力便是需求：</p><ul><li><strong>资源利用角度</strong>：为了提高计算机资源利用率和系统性能，从单道到多道、集中到分布、从专用到泛在等；</li><li><strong>用户角度</strong>：方便用户，人机交互；</li><li><strong>技术角度</strong>：物理器件发展、CPU的位宽度（指令和数据）、快速外存、光器件等，以及计算机体系结构的不断发展：单处理机、多处理机、多核、计算机网络。</li></ul><h2 id="21-操作系统的历史"><a class="markdownIt-Anchor" href="#21-操作系统的历史"></a> 2.1 操作系统的历史</h2><ul><li><strong>第一代（1946 年-1955 年）</strong>： 真空管时代，无操作系统；</li><li><strong>第二代（1955 年-1965 年）</strong>： 晶体管时代，批处理系统；</li><li><strong>第三代（1965 年-1980 年）</strong>： 集成电路时代，多道程序设计；</li><li><strong>第四代（1980 年-至今）</strong>： 大规模和超大规模集成电路时代，分时系统，现代计算机正向着巨型、微型、并行、分布、网络化和智能化几个方向发展。</li></ul><h2 id="22-操作系统的类型"><a class="markdownIt-Anchor" href="#22-操作系统的类型"></a> 2.2 操作系统的类型</h2><ul><li>无操作系统（No operating system）；</li><li>简单批处理系统（Simple Batch Systems）；</li><li>多道程序批处理系统（Multiprogramming Batched Systems）；</li><li>分时系统（Time-Sharing Systems）；</li><li>实时系统（Real -Time Systems）；</li><li>嵌入式系统（Embedded Systems）；</li><li>并行系统（Parallel Systems）；</li><li>分布式系统（Distributed Systems）。</li></ul><h2 id="23-单道批处理系统"><a class="markdownIt-Anchor" href="#23-单道批处理系统"></a> 2.3 单道批处理系统</h2><p>世界上第一台计算机叫做<strong>ENIAC计算机</strong>，它的运算速度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次/每秒，数万个真空管，占地 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 平方米，在它诞生的时候没有程序设计语言（甚至没有汇编），更谈不上操作系统，程序员提前预约一段时间，然后到机房将他的插件板插到计算机里期盼着在接下来的时间中几万个真空管不会烧断，从而可以计算自己的题目。</p><p>这种工作方式称为人工操作方式，用户是计算机专业人员，这种方式的缺点是用户独占全机，独占系统的全部硬件资源，设备利用率很低，CPU等待用户手工装入/卸取纸带或卡片使CPU的利用率也非常低。</p><p>50 年代早期，出现了穿孔卡片，如下图，程序写在卡片上然后读入计算机，但计算过程则依然如旧，效率并没有得到本质的提升。<br /><img src="https://img-blog.csdnimg.cn/20200313232027754.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><p>此时出现的主要矛盾是人工操作方式与机器利用率的矛盾和CPU与 I/O 之速度不匹配的矛盾，解决的方法有两种，即<strong>批处理</strong>和<strong>脱机I/O</strong>：</p><ul><li><p><strong>脱机I/O方式</strong>：I/O 工作在外围机的控制下完成，或者说是在<strong>脱离主机</strong>的情况下进行。使用磁带作为输入/输出的中介，这种具体的输入/输出不需要在主计算机上进行的方式称“脱机输入/输出”，如下图；<br /><img src="https://img-blog.csdnimg.cn/20200313232316468.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p></li><li><p><strong>单道批处理系统</strong>：50年代末 ~ 60年代中（晶体管时代），把一批作业以脱机输入方式输入到磁带/磁鼓，利用磁带或磁盘把任务分类编成作业顺序执行，每批作业由专门监督程序（Monitor）<strong>自动依次处理</strong>，批处理系统解决了高速计算机的运算、处理能力与人工干预之间的速度矛盾，实现了作业<strong>自动过渡</strong>，也就是自动执行程序，执行完这个程序后自动执行下一个程序，单道的含义就是一次只处理一个程序，如下图所示，IBM1401 为外围设备，负责读入卡片和输出打印，IBM7094 为主机，负责主要的计算处理工作；<br /><img src="https://img-blog.csdnimg.cn/20200313232840845.png" alt="在这里插入图片描述" style="zoom:40%;" /></p><p><strong>单道批处理系统</strong>具有<strong>顺序性</strong>，即磁带上的各道作业是顺序地进入内存，各作业的完成顺序与他们进入内存的顺序相同；具有<strong>单道性</strong>，即内存中仅有一道程序运行；具有<strong>自动性</strong>，即一个程序运行结束后会自动运行下一个程序。单道批处理系统的<strong>优点</strong>是减少了CPU的空闲时间，提高了主机CPU和 I/O 设备的使用效率，提高了吞吐量。它的<strong>缺点</strong>是CPU和 I/O 设备使用忙闲不均，因为在读入数据和输出打印时，CPU是等待状态，而外围机是忙碌状态，当CPU进行计算处理时处于忙碌状态，而外围机又处于等待状态，也正是因为忙闲不均问题导致了后面的多道批处理系统的出现。</p></li></ul><h2 id="24-多道批处理系统"><a class="markdownIt-Anchor" href="#24-多道批处理系统"></a> 2.4 多道批处理系统</h2><p>多道程序设计60年代中 ~ 70年代中（集成电路时代），它的思想是在内存中同时存放几个作业，使之都处于执行的开始点和结束点之间，多个作业共享CPU、内存、外设等资源，目的是为了提高资源的利用率。</p><p>多道批处理系统的出现得益于60年代<strong>通道</strong>和<strong>中断技术</strong>的出现：</p><ul><li><strong>通道</strong>：是一种专用部件，负责外部设备与内存之间信息的传输；</li><li><strong>中断</strong>：指主机接到外界的信号（来自CPU外部或内部）时，立即中止原来的工作，转去处理这一外来事件，处理完后，主机又回到原来工作点继续工作。</li></ul><p>下图是单道程序和多道程序的运行情况，竖轴为设备，横轴为时间，可以发现在单道程序中，某个时间点只有一个设备在工作，而在多道程序中，某个时间点可能有多个设备在同时工作，这就大大提高了效率，有效改善了单道程序中各设备忙闲不均的问题。<br /><img src="https://img-blog.csdnimg.cn/2020031323391726.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>多道程序批处理系统中在内存中同时有多个作业，CPU在其中切换，只要系统中总是存在可执行的作业，CPU就永远不会因无事可干而闲着，多道程序最大的优点就是通过组织作业使得CPU总在执行其中一个作业，从而<strong>提高了CPU的利用率</strong>。</p><p>多道程序批处理系统具有<strong>多道性</strong>，即内存中同时驻留多道程序并发执行，从而有效地提高了资源利用率和系统吞吐量；具有<strong>无序性</strong>，即作业的完成顺序与它进入内存的顺序之间无严格的对应关系，有可能某个程序是第一个进来的，但却是最后一个被执行的；具有<strong>调度性</strong>，即作业调度、进程调度，当系统中有多个程序要执行的时候，将通过调度策略来决定哪个程序先执行。</p><p>多道程序批处理系统的<strong>优点</strong>是提高了系统资源利用率，提高了系统吞吐量，它的<strong>缺点</strong>是无交互能力，用户响应时间长，且作业平均周转时间长。</p><h2 id="25-多道程序对操作系统特点的要求"><a class="markdownIt-Anchor" href="#25-多道程序对操作系统特点的要求"></a> 2.5 多道程序对操作系统特点的要求</h2><p>多道程序从概念上来说只是增加了并发，提高了资源设备利用率，但是实际上它是对单道程序的质的飞跃，在设计过程中，也对操作系统提出了更高的要求：</p><ul><li><strong>存储管理 (Memory management)</strong>；</li><li><strong>CPU调度 (CPU scheduling)</strong>；</li><li><strong>资源竞争和共享 (Resource competition and sharing )；</strong></li><li><strong>设备分配 (Allocation of devices)；</strong></li><li><strong>系统提供 I/O 程序 (  I/O routine supplied by the system)</strong>；</li><li><strong>文件管理 (File management )。</strong></li></ul><h2 id="26-分时系统"><a class="markdownIt-Anchor" href="#26-分时系统"></a> 2.6 分时系统</h2><p>根据上面所述的多道批处理操作系统的缺点，即缺少用户交互，于是在多道的基础上有了用户的新需求，一是多任务处理（多用户），二是能支持人和机器的交互服务，这些需求也就是后来发明分时系统所实现的。</p><p><strong>分时系统</strong>，70年代中期至今，分时是指多个用户分享使用同一台计算机，分时共享硬件和软件资源，分时系统的实现方式有两种，多个用户分时、前台和后台程序 (foreground &amp; background) 分时：</p><ul><li><strong>多个用户分时</strong>：单个用户使用计算机的效率低，因而允许多个应用程序同时在内存中，分别服务于不同的用户。有用户输入时由CPU执行，处理完一次用户输入后程序暂停，等待下一次用户输入，表现的形式就是<strong>时走时停</strong>；</li><li><strong>前台和后台程序 (foreground &amp; background) 分时</strong>：前台程序一般指的是和人有交互的程序，后台程序通常是不与人交互的程序，后台程序不占用终端输入输出，不与用户交互，表现的形式是现在的图形用户界面(GUI)，除当前交互的程序 (输入焦点) 之外，其他程序均作为后台。</li></ul><p>分时的具体实现方式是按<strong>时间片</strong> (time slice) 分配，各个程序在CPU上执行的轮换时间，主机连接多个终端，多个终端同时共享这个主机，那么此时要解决的问题是如何才能及时接收，如何才能及时处理。及时接收可能比较简单，可以设置一个输入缓存，把多个终端的输入放到缓存里，然后主机轮流处理即可。那么及时处理就比较复杂，这对系统提出了更高的要求，如果程序是在外存上显然不在运行状态，是不能做到及时处理的，原来的多道程序是由外存进入到内存中所以无法实现及时处理，那么分时系统则要求作业直接进入内存，只有这样系统才能及时的处理用户的输入和请求，另外通过时间片可以让每个作业一次只运行很短的时间，这样使得每个用户的输入都能被及时处理，给用户的感觉就是自己独占了这台计算机一样。</p><p><strong>分时技术</strong>把CPU的响应时间分成若干个大小相等（或不等）的时间单位，称为时间片（如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 毫秒），每个终端用户获得CPU（获得一个时间片）后开始运行，当时间片到，该用户程序暂停运行，等待下一次运行。</p><p>分时具有如下特点：</p><ul><li><strong>多路性</strong>：众多联机用户可以同时使用同一台计算机；</li><li><strong>独占性</strong>：各终端用户感觉到自己独占了计算机；</li><li><strong>交互性</strong>：用户与计算机之间可进行“会话”；</li><li><strong>及时性</strong>：用户的请求能在很短时间内获得响应。</li></ul><p>在分时系统的基础上，操作系统的发展开始分化，如实时系统、通用（桌面）系统、网络系统、分布式系统等。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用gcc指令体验C语言编译过程</title>
    <link href="/2020/03/11/%E7%94%A8gcc%E6%8C%87%E4%BB%A4%E4%BD%93%E9%AA%8CC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/03/11/%E7%94%A8gcc%E6%8C%87%E4%BB%A4%E4%BD%93%E9%AA%8CC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-环境说明"><a class="markdownIt-Anchor" href="#1-环境说明"></a> 1 环境说明</h1><ul><li>系统：Windows；</li><li>编译器：<a href="http://gcc.gnu.org/">gcc</a>；</li><li>命令行工具：<a href="https://cmder.net/">cmder</a>  （用系统自带的命令行工具也可以）。</li></ul><h1 id="2-gcc编译步骤"><a class="markdownIt-Anchor" href="#2-gcc编译步骤"></a> 2 gcc编译步骤</h1><table><thead><tr><th>#</th><th>步骤名</th><th>生成文件</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>编辑(Edit)</td><td><code>test.c</code></td><td>进行<strong>编码</strong>工作</td></tr><tr><td>2</td><td>预处理(Pre-processing)</td><td><code>test.i</code></td><td>将<code>#include</code>头文件以及宏定义<strong>替换</strong>成其真正的内容</td></tr><tr><td>3</td><td>编译(Compiling)</td><td><code>test.s</code></td><td>将经过预处理之后的程序转换成特定<strong>汇编代码</strong>(assembly code)的过程</td></tr><tr><td>4</td><td>汇编处理(Assembling)</td><td><code>test.o</code></td><td>将上一步的汇编代码转换成<strong>机器码</strong>(machine code)，生成<strong>目标文件</strong></td></tr><tr><td>5</td><td>链接(Linking)</td><td><code>test.exe</code></td><td>将多个目标文以及所需的库文件链接成最终的<strong>可执行文件</strong>(executable file)</td></tr></tbody></table><p>下图是预处理，编译，汇编处理和链接的流程图：<br /><img src="https://img-blog.csdnimg.cn/20200311125820515.png" style="zoom:80%;" /></p><h2 id="21-编辑"><a class="markdownIt-Anchor" href="#21-编辑"></a> 2.1  编辑</h2><p>编写以下代码，命名文件名为<code>test.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="22-预处理"><a class="markdownIt-Anchor" href="#22-预处理"></a> 2.2 预处理</h2><p>预处理gcc指令如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gcc -E test.c -o test.i<br></code></pre></div></td></tr></table></figure><ul><li>参数<code>-E</code> - 执行编译预处理；</li><li>参数<code>-o</code> - 指明输出文件的文件名。</li></ul><p>执行过后控制台没有任何输出，打开文件夹会发现生成了一个<code>test.i</code>文件：<br /><img src="https://img-blog.csdnimg.cn/20200311130527354.png" style="zoom:80%;" /><br />可以发现生成的<code>test.i</code>文件会比<code>test.c</code>文件大得多，因为进行了大量的替换，<code>test.i</code>文件可以通过记事本方式打开的，也可以输入指令<code>type test.i</code>在控制台查看，由于文件内容很多，下面仅展示最后部分，可以发现末尾部分还是我们编写的源代码，而头文件<code>#include&lt;stdio.h&gt;</code>进行了全部替换。<br /><img src="https://img-blog.csdnimg.cn/20200311130953519.png" style="zoom:80%;" /></p><h2 id="23-编译"><a class="markdownIt-Anchor" href="#23-编译"></a> 2.3 编译</h2><p>编译gcc指令如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gcc -S test.i -o test.s<br></code></pre></div></td></tr></table></figure><ul><li>参数<code>-S</code> - 编译指令；</li><li>参数<code>-o</code> - 指明输出文件的文件名。</li></ul><p>执行过后控制台没有任何输出，打开文件夹会发现生成了一个<code>test.s</code>文件：<br /><img src="https://img-blog.csdnimg.cn/20200311131303161.png" style="zoom:80%;" /></p><p>我们这里用指令<code>type test.s</code>在控制台查看文件内容，可以发现程序被转换成了<strong>汇编代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">        .file   <span class="hljs-string">&quot;test.c&quot;</span><br>        .def    __main; .scl    <span class="hljs-number">2</span>;      .type   <span class="hljs-number">32</span>;     .endef<br>        .section .rdata,<span class="hljs-string">&quot;dr&quot;</span><br>.LC0:<br>        .ascii <span class="hljs-string">&quot;Hello World!\0&quot;</span><br>        .text<br>        .globl  main<br>        .def    main;   .scl    <span class="hljs-number">2</span>;      .type   <span class="hljs-number">32</span>;     .endef<br>        .seh_proc       main<br>main:<br>        pushq   %rbp<br>        .seh_pushreg    %rbp<br>        movq    %rsp, %rbp<br>        .seh_setframe   %rbp, <span class="hljs-number">0</span><br>        subq    $<span class="hljs-number">32</span>, %rsp<br>        .seh_stackalloc <span class="hljs-number">32</span><br>        .seh_endprologue<br>        call    __main<br>        leaq    .LC0(%rip), %rcx<br>        call    <span class="hljs-built_in">printf</span><br>        movl    $<span class="hljs-number">0</span>, %eax<br>        addq    $<span class="hljs-number">32</span>, %rsp<br>        popq    %rbp<br>        ret<br>        .seh_endproc<br>        .ident  <span class="hljs-string">&quot;GCC: (tdm64-1) 4.9.2&quot;</span><br>        .def    <span class="hljs-built_in">printf</span>; .scl    <span class="hljs-number">2</span>;      .type   <span class="hljs-number">32</span>;     .endef<br></code></pre></div></td></tr></table></figure><h2 id="24-汇编处理"><a class="markdownIt-Anchor" href="#24-汇编处理"></a> 2.4 汇编处理</h2><p>汇编处理gcc指令如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gcc -c test.s -o test.o<br></code></pre></div></td></tr></table></figure><ul><li>参数<code>-c</code> - 汇编转机器码</li><li>参数<code>-o</code> - 指明输出文件的文件名</li></ul><p>执行过后控制台没有任何输出，打开文件夹会发现生成了一个<code>test.o</code>文件：<br /><img src="https://img-blog.csdnimg.cn/20200311131842562.png" style="zoom:80%;" /></p><p>由于文件已经是机器码了，打开文件的话显然都是乱码了，用指令<code>type test.o</code>在控制台查看文件内容如下：<br /><img src="https://img-blog.csdnimg.cn/20200311132001964.png" style="zoom:80%;" /></p><h2 id="25-链接"><a class="markdownIt-Anchor" href="#25-链接"></a> 2.5 链接</h2><p>链接处理gcc指令如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gcc test.o -o test<br></code></pre></div></td></tr></table></figure><ul><li>参数<code>-o</code> - 指明输出文件的文件名。</li></ul><p>执行过后控制台没有任何输出，打开文件夹会发现生成了一个<code>test.exe</code>文件：<br /><img src="https://img-blog.csdnimg.cn/20200311132139690.png" style="zoom:80%;" /></p><p>既然已经转换成了<code>.exe</code>可执行文件，在Windows操作系统下可以直接执行，直接在控制台输入<code>test</code>，执行结果如下：<br /><img src="https://img-blog.csdnimg.cn/20200311132237408.png" style="zoom:80%;" /></p><p>可以发现最后输出了<code>Hello World!</code>那么整个过程就结束了。</p><h1 id="3-一步到位的方法"><a class="markdownIt-Anchor" href="#3-一步到位的方法"></a> 3 一步到位的方法</h1><p>直接可以从<code>.c</code>文件到<code>.exe</code>可执行文件，这里就不演示了。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gcc test.c -o test<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宏定义#define的用法</title>
    <link href="/2020/03/09/%E5%AE%8F%E5%AE%9A%E4%B9%89define%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2020/03/09/%E5%AE%8F%E5%AE%9A%E4%B9%89define%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不带参宏定义"><a class="markdownIt-Anchor" href="#1-不带参宏定义"></a> 1 不带参宏定义</h1><p>这种用法是最简单最常见的一种方式，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAI 3.14</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>注意</strong>：宏定义原则上用大写表示，虽然这并不是规定，由于宏定义是预处理指令，并非是C语言语句，所以末尾不必加分号。</p></blockquote><p>它的功能是在程序中若出现了 <code>PAI</code>，就把它<strong>替换</strong>为 <code>3.14</code>，示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAI 3.14 <span class="hljs-comment">// 不带参宏定义</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> r = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;半径为%.2lf的圆的周长为%.2lf&quot;</span>, r, <span class="hljs-number">2</span>*PAI*r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="2-带参宏定义"><a class="markdownIt-Anchor" href="#2-带参宏定义"></a> 2 带参宏定义</h1><p>使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(a,b) (a+b)</span><br></code></pre></div></td></tr></table></figure><p>它的功能是计算 <code>a+b</code> 的结果，示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(a,b) (a+b)</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a+b=%d&quot;</span>, ADD(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，我们习惯上会把后面表达式添上括号，如 <code>(a+b)</code>，在本例中去掉这个括号也是可以的，但有些情况下会出现问题，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(a,b) a+b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUB(a,b) a-b</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ADD(a,b)*SUB(a,b)); <span class="hljs-comment">// ab的和与差相乘</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个程序的功能是计算 <code>a+b</code> 乘以 <code>a-b</code> 的值，实际上程序的输出结果为 <code>1</code>，我们稍加思考发现本例中 <code>a+b&gt;0</code>，<code>a-b&lt;0</code> 答案必然是负数，结果却是正数，显然出了问题，那么再把表达式的括号加上试试看：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(a,b) (a+b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUB(a,b) (a-b)</span><br></code></pre></div></td></tr></table></figure><p>程序运行后输出结果为 <code>-3</code>，可以口算发现此结果是正确的，出现问题的原因就要从<code>#define</code> 预编译指令的原理说起，在编译一个C语言程序时，第一步执行的是预编译这个过程中会把 <code>#define</code> 中定义的宏进行替换，如不加括号的程序中就替换成了如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a+b*a-b); <span class="hljs-comment">// 输出结果为1</span><br></code></pre></div></td></tr></table></figure><p>显然根据数学运算规则会先算乘法后算加法，所以结果为 <code>1</code>，那么加上括号的程序中替换后结果如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-number">1</span>+<span class="hljs-number">2</span>)*(<span class="hljs-number">1</span><span class="hljs-number">-2</span>)); <span class="hljs-comment">// 输出结果为-3</span><br></code></pre></div></td></tr></table></figure><p>先算括号里的式子，整个式子的结果显然为 <code>-3</code>，通过本例可以发现为了避免替换后出现类似这种错误，尽量将表达式加上括号，特别是表达式中有多个变量时</p><blockquote><p><strong>带参宏定义和函数有点像，他们的区别如下</strong>：</p><ul><li>函数参数传递时会计算实参的值再传递给形参，如执行函数 <code>func(1+2)</code>，会先计算 <code>1+2</code> 的值为 <code>3</code> 再交给函数体，而带参宏定义不进行任何计算，直接<strong>替换</strong>；</li><li>根据上面例子可以发现，带参宏定义对数据类型没有定义，可以使用多种合法类型带入，但函数要根据定义函数时声明的参数类型传递值；</li><li>带参宏定义仅占用预编译的时间，而函数的执行会占用空间和时间，如分配内存空间，入栈保留现场，返回值等。</li></ul></blockquote><h1 id="3-与字符串有关的用法"><a class="markdownIt-Anchor" href="#3-与字符串有关的用法"></a> 3 与字符串有关的用法</h1><h2 id="31-字符串转换"><a class="markdownIt-Anchor" href="#31-字符串转换"></a> 3.1 字符串转换</h2><p>使用方法如下，在 <code>s</code> 前加上 <code>#</code>，它的作用是将传入的 <code>s</code> 转换为字符串：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(s) #s</span><br></code></pre></div></td></tr></table></figure><p>示例程序如下，给出参数 <code>Wuhan jia you</code>，最后以字符串的形式输出来：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(s) #s</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">puts</span>(STR(Wuhan jia you));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，转换的是 <code>s</code>，而不是 <code>s</code> 里的值，见下面两个程序：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 程序1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(s) #s</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s = <span class="hljs-string">&quot;Wuhan jia you&quot;</span>;<br>    <span class="hljs-built_in">puts</span>(STR(s));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 程序2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(s) #s</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">2020</span>;<br>    <span class="hljs-built_in">puts</span>(STR(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一个程序输出结果为 <code>s</code>，第二个程序的输出结果为 <code>n</code>，可见这个用法就是你给它什么，它就把它直接转换为字符串，不管它是不是变量。</p><h2 id="32-字符转换"><a class="markdownIt-Anchor" href="#32-字符转换"></a> 3.2 字符转换</h2><p>使用方法如下，在 <code>c</code> 的前面加上 <code>#@</code>，它的作用是把 <code>c</code> 转换为字符</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(c) #@c</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意：本用法不支持gcc编译器，如在gcc编译器下编译，会出现下面的错误信息 <code>error: '#' is not followed by a macro parameter</code>，这个用法仅支持微软系列 <code>(Microsoft Specific)</code></p></blockquote><p>示例程序如下，给出参数 <code>1</code>，最后把 <code>1</code> 转换为字符 <code>1</code> 输出：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STR(c) #@c</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">putchar</span>(STR(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关于它的转换规则和 <code>3.1 字符串转换</code> 的类似</p><h2 id="33-字符连接"><a class="markdownIt-Anchor" href="#33-字符连接"></a> 3.3 字符连接</h2><p>使用方法如下，在两个参数中间添加 <code>##</code>，它的作用是连接前后两个参数，把它们变成一个参数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAT(a,b) a##b</span><br></code></pre></div></td></tr></table></figure><p>示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAT(a,b) a##b</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = CAT(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果为 <code>123456</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP运输连接管理</title>
    <link href="/2020/03/08/TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/08/TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-运输连接概述"><a class="markdownIt-Anchor" href="#1-运输连接概述"></a> 1 运输连接概述</h1><p>TCP 是<strong>面向连接</strong>的协议，TCP 连接有三个阶段：**连接建立，数据传送，连接释放，**TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。</p><p>TCP 连接建立过程中要解决的三个问题：</p><ol><li>要使每一方能够确知对方的存在，确认双方接收和发送的功能是能够正常工作的；</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）；</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol><p>TCP连接的建立采用的是客户—服务器方式，即<strong>主动</strong>发起连接建立的应用进程叫做<strong>客户 (client)</strong>，<strong>被动</strong>等待连接建立的应用进程叫做<strong>服务器 (server)</strong>。</p><h1 id="2-tcp的连接建立"><a class="markdownIt-Anchor" href="#2-tcp的连接建立"></a> 2 TCP的连接建立</h1><p>TCP 建立连接的过程被比喻成<strong>握手</strong>，握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>，采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到服务器，因而产生错误。三次报文握手的过程：</p><img src="https://img-blog.csdnimg.cn/2020030813301456.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200308133133657.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200308133248795.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：大写的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">ACK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 和小写的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">ack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 代表的含义不同，大写 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">ACK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 代表确认位，小写 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">ack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 代表确认号，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>k</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ack=x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 代表之前序号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 报文已经正确收到了，并期待收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 报文，服务器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 也选择了序号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">seq=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 代表双方各自发送的序号的独立的。</p></blockquote><img src="https://img-blog.csdnimg.cn/20200308133409835.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200308133432501.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的确认后还会发送一次确认报文给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，即确认的确认，主要是为了防止已失效的连接请求报文段突然又传送到服务器，因而产生错误，考虑这样一种情况，比如说 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的第一个连接报文由于在某个站点滞留，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 收到之后会认为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 又重新发了一次连接，这个时候 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 会发送确认报文同意建立新的连接，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 收到确认连接的报文时由于这个确认是对一个并不存在的连接请求，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 不去理睬 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的确认，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 如果没有对确认的再次确认就会误以为连接已经建立好了而等待 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 去发送数据，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 并没有数据要发送，双方就进入了一个误会的状态，所以第三次的握手对确认的再确认时非常必要的。</p></blockquote><img src="https://img-blog.csdnimg.cn/20200308133503280.png" alt="在这里插入图片描述"  /><h1 id="3-tcp的连接释放"><a class="markdownIt-Anchor" href="#3-tcp的连接释放"></a> 3 TCP的连接释放</h1><p>TCP 连接释放过程比较复杂，数据传输结束后，通信的双方都可释放连接，TCP 连接释放过程是**四报文握手。**四次报文握手的过程如下：</p><img src="https://img-blog.csdnimg.cn/20200308144523661.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：上述操作实际上是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 告诉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的数据已经发送完了，现在需要把发送方向这个连接释放掉。</p></blockquote><img src="https://img-blog.csdnimg.cn/20200308144737963.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 接收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的释放连接报文，会发出确认报文，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>k</mi><mo>=</mo><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ack=u+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 表示已经收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发出的释放连接报文，而自己的序号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">seq=v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 仍然是独立的，意味着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 这个时刻不一定需要释放连接，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 可能还有数据要发送，所以说 TCP 连接处于半关闭状态。</p></blockquote><img src="https://img-blog.csdnimg.cn/2020030814513891.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/2020030814552866.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">seq=v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">seq=w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 是相互独立的，实际上是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>  在发送数据时，又消耗了一部分字节。在最后一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的确认报文中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">seq=u+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 和第一轮 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>  向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送的确认报文中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>k</mi><mo>=</mo><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ack=u+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是一样的。</p></blockquote><img src="https://img-blog.csdnimg.cn/2020030814554740.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200308145626552.png" alt="在这里插入图片描述"  /><blockquote><p><strong>注意</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 必须等待 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>M</mi><mi>S</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">2MSL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span></span></span></span> 的时间（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">MSL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span></span></span></span>即报文最长寿命时间）再彻底释放连接，第一，为了保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送的最后一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">ACK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 报文段能够到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，第二，防止 “已失效的连接请求报文段”出现在本连接中，简单来说就是设一个长一点的等待时间，在这段时间内所有请求都消失在网络里，这样让新的请求来的时候不会产生误会。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞控制</title>
    <link href="/2020/03/07/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/03/07/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-拥塞概念"><a class="markdownIt-Anchor" href="#1-拥塞概念"></a> 1 拥塞概念</h1><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为<strong>拥塞 (congestion)</strong>，若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降，出现拥塞的原因是 ∑ 对资源需求  &gt; 可用资源，这里的资源包括很多方面，比如路由器的缓存、路由器的处理速度、通信线路的容量等等。拥塞的现象和堵车的现象有点相似，比如出现堵车有一个原因就是道路不够宽，我们红绿灯的交替速度不够快等等诸多方面元素。</p><p>既然拥塞是因为可用资源不足，那么增加资源是否可以解决拥塞现象？答案是不可以，这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏，如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，会进一步的加剧拥塞，解决不了网络拥塞，如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组，但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要車传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃，如提高处理机处理的速率会将瓶颈转移到其他地方，只提高某一方面是不可能提高整体效率的，即限制堵车的办法不是多修路，而是限制车到路上。</p><p>拥塞控制与流量控制的区别是拥塞控制对全局的每一个发送端进行控制，而流量控制对单一的发送端进行控制。<br /><img src="https://img-blog.csdnimg.cn/20200307205309190.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h1 id="2-拥塞控制的一般原理"><a class="markdownIt-Anchor" href="#2-拥塞控制的一般原理"></a> 2 拥塞控制的一般原理</h1><p>对理想的拥塞控制在达到资源上限之前，网络的吞吐量是平稳上升的，而达到最高点之后，整个网络的吞吐量可在最高点延续，这个时候哪怕有更多的分组注入网络，也能够以最高的吞吐量进行发送和接收数据，实际的拥塞控制不可能达到理想拥塞控制的效果，随着注入网络的分组增加，吞吐量会逐渐增加，但达不到上限；</p><img src="https://img-blog.csdnimg.cn/20200307215643248.png" alt="在这里插入图片描述"  /><p>在设计拥塞算法时，由于拥塞都是动态的，每一时刻的可用资源和需求资源都是动态变化的，所以无法明确的确定一个边界，由于拥塞控制是一个全局问题，而发送方的一点无法获取到全局的网络状况，所以这使得拥塞控制的设计极为复杂。</p><p>在设计拥塞控制算法时，有两类控制方法：</p><ol><li><strong>开环控制</strong>：事先将有关发生拥塞的因素都考虑周到，力求在网络工作的时候不发生拥塞，这需要全面的考虑到各方面原因并以参数的形式将其设计到算法中来；</li><li><strong>闭环控制</strong>：监测网络系统，以便检测到拥塞在何时、何处发生，将拥塞发生的信息传送到可采取行动的地方，通常是发送方或中间路由器，调整网络系统的运行以解决出现的问题，比如可以限制发送方发送报文的速度，通常闭环控制是最常用的控制方式。</li></ol><p>两种方式的区别如下：<br /><img src="https://img-blog.csdnimg.cn/20200307221326690.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h1 id="3-拥塞控制的方法"><a class="markdownIt-Anchor" href="#3-拥塞控制的方法"></a> 3 拥塞控制的方法</h1><p>TCP 采用基于<strong>窗口</strong>的方法进行拥塞控制。该方法属于闭环控制方法，TCP 发送方维持一个<strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span></strong> (Congestion Window)，发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量，发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<code>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</code>。</p><p>控制拥塞窗口的原则是只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率，但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><p>当前是否出现拥塞有两种判断方法：</p><ul><li><strong>重传定时器超时</strong>：现在通信线路的传输质量一般都很好，因传输岀差错而丟弃分组的概率是很小的（远小于1%）。只要出现了超时，就可以猜想网络可能出现了拥塞；</li><li><strong>收到三个相同（重复）的ACK</strong>：个别报文段会在网络中丢失，预示可能会出现拥塞（也可能未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</li></ul><p>TCP拥塞控制算法分为四种，分别用于数据传输的不同阶段：</p><ol><li><strong>慢开始 (slow-start)；</strong></li><li><strong>拥塞避免 (congestion avoidance)；</strong></li><li><strong>快重传 (fast retransmit)；</strong></li><li><strong>快恢复 (fast recovery)。</strong></li></ol><h2 id="31-慢开始-slow-start"><a class="markdownIt-Anchor" href="#31-慢开始-slow-start"></a> 3.1 慢开始 (Slow start)</h2><ul><li><strong>目的</strong>：用来确定网络的负载能力或拥塞程度；</li><li><strong>算法的思路</strong>：由小到大逐渐增大拥塞窗口数值；</li><li><strong>初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置</strong>：旧的规定在刚刚开始发送报文段时，先把初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个发送方的最大报文段 SMSS（ Sender Maximum Segment Size）的数值，新的 RFC5681 把初始拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 设置为不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个SMSS 的数值；</li><li><strong>慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span>（状态变量）</strong>：防止拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 增长过大引起网络拥塞，当我们发送的报文段数量达到慢开始门限后，就会从慢开始阶段转换为<strong>拥塞避免</strong>阶段。</li></ul><blockquote><p><strong>慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 的用法如下</strong>：</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &lt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，使用慢开始算法；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &gt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，停止使用慢开始算法而改用拥塞避免算法；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></blockquote><ul><li><strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>  控制方法</strong>：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的数值，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 每次的增加量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= min (N, SMSS)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>，即在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 之中取一个最小值，其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数，不难看出，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>&lt;</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">N &lt; SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 时，拥塞窗口每次的增加量要小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。用这样的方法逐步增大发送方的拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>，可以使分组注入到网络的速率更加合理。<br /><img src="https://img-blog.csdnimg.cn/20200307225634244.png" alt="在这里插入图片描述"  /></li></ul><blockquote><p><strong>传输轮次</strong>：使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 就加倍，一个传输轮次所经历的时间其实就是往返时间 RTT，“传输轮次”更加强调把拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认，例如，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">cwnd = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，这时的往返时间 RTT 就是发送方连续发送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个报文段，并收到这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个报文段的确认，总共经历的时间。</p></blockquote><h2 id="32-拥塞避免算法"><a class="markdownIt-Anchor" href="#32-拥塞避免算法"></a> 3.2 拥塞避免算法</h2><p>首先要提出一点，拥塞避免算法并不是完全避免拥塞，而是让拥塞来的更慢一些。其思路是让拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 缓慢地增大，即毎经过一个往返时间 RTT 就把发送方的<strong>拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，而不是加倍</strong>，使拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 按<strong>线性规律缓慢增长</strong>，因此在拥塞避免阶段就有“<strong>加法增大</strong>”（ Additive Increase）的特点。这表明在拥塞避免阶段，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 按线性规律缓慢增长，比慢开始算法的拥基窗口增长速率缓馒得多。</p><p>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（<strong>重传定时器超时</strong>），则要减少慢开始门限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ssthresh = max (cwnd/2,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，再初始化拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，执行慢开始算法，也就是说当进入了拥塞状态，会重新调整 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 大小并重新进入慢开始阶段，其目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。慢开始和拥塞避免算法的实现举例如下：<br /><img src="https://img-blog.csdnimg.cn/20200307231451337.png" alt="在这里插入图片描述"  /></p><ol><li>在执行慢开始算法时，拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，发送第一个报文段；</li><li>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 随着传输轮次按指数规律增长；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 增长到慢开始门限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时（图中的点❶ ，此时拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">cwnd = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> ），就改为执行拥塞避免算法，拥塞窗口按线性规律增长；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">cwnd = 24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 时，网络出现了超时（图中的点❷ ），发送方判断为网络拥塞。于是调整门限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">ssthresh = cwnd / 2 = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>，同时设置拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cwnd = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，进入慢开始阶段；</li><li>按照慢开始算法，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">cwnd = ssthresh = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>  时（图中的点❸，这是新的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 值），改为执行拥塞避免算法，拥塞窗口按线性规律增大；</li><li>当拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">cwnd = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 时（图中的点❹），出现了一个新的情况，就是发送方一连收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个对同一个报文段的重复确认（图中记为 3-ACK）。发送方改为执行<strong>快重传</strong>和<strong>快恢复</strong>算法。</li></ol><p><strong>需要注意的是：</strong></p><ul><li>“拥塞避免”并非指完全能够避免了拥塞，利用以上的措施要完全避免网络拥塞还是不可能的；</li><li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h2 id="33-快重传算法"><a class="markdownIt-Anchor" href="#33-快重传算法"></a> 3.3 快重传算法</h2><p>快重传和快恢复的目的，是为了<strong>防止因为报文段丢失重新进入到慢启动的过程</strong>，通过收到 3-ACK（接收 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 次对同一报文的确认）判断，发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞，采用快重传 FR (Fast Retransmission) 算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>，快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认，快重传举例如下。</p><p>发送方发送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时传输过程中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 丢失，但是接收方接收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">M_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 报文段，那么接收方必须对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行重复的确认，当发送方接收到连续 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的确认后，发送方就知道了接收方没有接收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，应当立即重传 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这也就是<strong>快重传</strong>的由来，这样也不会出现超时，发送方也不会认为这是网络拥塞。</p><img src="https://img-blog.csdnimg.cn/20200307233507221.png" alt="在这里插入图片描述"  /><h2 id="34-快恢复算法"><a class="markdownIt-Anchor" href="#34-快恢复算法"></a> 3.4 快恢复算法</h2><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行<strong>快恢复</strong>算法 FR (Fast Recovery) 算法，减小慢开始门限 $ssthresh = cwnd / 2 $，设置新拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> ，开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。<br /><img src="https://img-blog.csdnimg.cn/20200307234259997.png" alt="在这里插入图片描述"  /></p><h2 id="35-加法增大乘法减小-aimd"><a class="markdownIt-Anchor" href="#35-加法增大乘法减小-aimd"></a> 3.5 加法增大，乘法减小 (AIMD)</h2><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“<strong>加法增大</strong>” AI (Additive Increase)，当出现超时或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“<strong>乘法减小</strong>”MD (Multiplicative Decrease)，二者合在一起就是所谓的 AIMD 算法。</p><h2 id="36-拥塞控制流程图"><a class="markdownIt-Anchor" href="#36-拥塞控制流程图"></a> 3.6 拥塞控制流程图</h2><img src="https://img-blog.csdnimg.cn/20200307234633536.png" alt="在这里插入图片描述"  /><h2 id="37-发送窗口的上限值"><a class="markdownIt-Anchor" href="#37-发送窗口的上限值"></a> 3.7 发送窗口的上限值</h2><p>发送方的发送窗口的上限值应当取为接收方窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 和拥塞窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 这两个变量中较小的一个，即应按以下公式确定：发送窗口的上限值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= Min ( rwnd, cwnd )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>；</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd &lt; cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，是接收方的接收能力限制发送窗口的最大值；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd &lt; rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，则是网络的拥塞限制发送窗口的最大值；</li></ul><p>也就是说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 中数值较小的一个，控制了发送方发送数据的速率。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2020/03/07/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/03/07/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h1><p>传输控制协议（TCP，Transmission Control Protocol），它是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。</p><p>我们可以作这样一个类比，TCP的工作过程，就像是打电话，在打电话时首先要进行拨号，对方接通之后才能进行通话，若是对方忙或者其他不能接听的情况，不能建立通话连接，双方也就不能进行通话，TCP也是如此，只有连接建立之后才能进行通信，打电话通话过程中同时能够进行听和说，TCP也是如此，能同时进行收发数据的操作，也就是TCP是支持全双工通信的，打完电话，任何一方挂断，就能结束本次通话，而TCP在传输完数据之后，也是要释放连接的。</p><h1 id="2-tcp的主要特点"><a class="markdownIt-Anchor" href="#2-tcp的主要特点"></a> 2 TCP的主要特点</h1><ol><li>TCP 是<strong>面向连接</strong>的运输层协议，传输数据之前，一定要建立连接并保持连接，传输完成也要释放连接（注意：UDP是无连接的）；</li><li>每一条 TCP 连接只能有两个端点 (endpoint)，<strong>每一条 TCP 连接只能是点对点的（一对一）</strong>（注意：UDP是可以一对一、一对多、多对一和多对多的交互通信）；</li><li>TCP 提供<strong>可靠交付</strong>的服务，能保证数据传输时没有差错的，顺序也是对的（注意：UDP是不可靠交付）；</li><li>TCP 提供<strong>全双工通信</strong>，可以同时进行收发数据的操作；</li><li>TCP是<strong>面向字节流</strong>的（注意：UDP是面向报文的）。</li></ol><blockquote><p><strong>面向字节流</strong>：TCP 中的“流”(stream) 指的是流入或流出进程的字节序列，“面向字节流”的含义是虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流，也就是说其实数据都是有一定结构的，但是在TCP眼里它都是无结构的字节串；</p><p>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，也就是说发送方发送一定规格和数量的数据块，接收方不一定最后收到的是同样规格和数量的数据块，但是能保证的是最后得到的数据，一定是无差错的，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样，在发送过程中到底如何分块，TCP不关心，TCP只关心最后数据肯定是和发送方发送过来的数据完全一样。<br /><img src="https://img-blog.csdnimg.cn/20200307154043562.png" alt="在这里插入图片描述" style="zoom:80%;" /><br /><img src="https://img-blog.csdnimg.cn/20200307154154620.png" alt="在这里插入图片描述" style="zoom:80%;" /></p></blockquote><p><strong>需要注意的是：</strong></p><ul><li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接；</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的；</li><li>TCP 根据对方给出的<strong>窗口值</strong>和当前<strong>网络拥塞</strong>的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的，不管给出多长，UDP都不进行合并、拆分等操作）；</li><li>TCP 可把太长的数据块划分短一些再传送，TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h1 id="3-tcp的连接"><a class="markdownIt-Anchor" href="#3-tcp的连接"></a> 3 TCP的连接</h1><p>TCP的连接是一条点对点的连接，TCP 把连接作为最基本的抽象，每一条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。<strong>TCP 连接的端点叫做套接字 (socket) 或插口</strong>，端口号拼接到 IP 地址即构成了<strong>套接字</strong>，如下所示：<br /><img src="https://img-blog.csdnimg.cn/20200307155800476.png" alt="在这里插入图片描述" style="zoom:50%;" /><br />套接字我们认为是TCP连接的一端，有了两个套接字，我们就可以 建立一条TCP连接：<br /><img src="https://img-blog.csdnimg.cn/20200307155833986.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h1 id="4-可靠传输的工作原理"><a class="markdownIt-Anchor" href="#4-可靠传输的工作原理"></a> 4 可靠传输的工作原理</h1><h2 id="41-停止等待协议"><a class="markdownIt-Anchor" href="#41-停止等待协议"></a> 4.1 停止等待协议</h2><p>TCP协议是一个很复杂的协议，它在面向连接的基础上，通过若干控制，可以达到可靠传输，拥塞控制，连接管理等功能，在运输层之下的网络层，IP 协议能够做到尽最大努力交付，也就是说 IP 数据报从一台主机到达另一台主机是可以通过路由来找到一条合适的路径到达对方，但是最后能不能到达对方，中间会不会出错，这个 IP 协议是不能保证的，在 IP 之上，运输层当中的TCP协议，在连接的基础之上，可以做到在不可靠的通信链路上实现可靠传输。</p><p>我们可以想象，理想的传输条件应该具有以下两个特点：</p><ul><li>传输信道不产生差错，也就是传输过程中，数据的比特不会因为干扰出现任何差错；</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ul><p>然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输，其中<strong>停止等待协议</strong>就是其中典型的一个协议，“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组，对方确认保证了数据的无差错，由于发送的数据也是按顺序发送的，所有最后数据的顺序也不会出现错乱。</p><p>全双工通信的双方既是发送方也是接收方，但为了讨论方便，这里仅说明其中一方发送，另一方接收的情况。</p><h3 id="411-无差错情况"><a class="markdownIt-Anchor" href="#411-无差错情况"></a> 4.1.1 无差错情况</h3><img src="https://img-blog.csdnimg.cn/20200307161813694.png" alt="在这里插入图片描述"  /><h3 id="412-出现差错"><a class="markdownIt-Anchor" href="#412-出现差错"></a> 4.1.2 出现差错</h3><p><strong>在接收方 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 会出现两种情况：</strong></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 接收 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时检测出了差错，就<strong>丢弃</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其他什么也不做（不通知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 收到有差错的分组）；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在传输过程中丢失了，这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 当然什么都不知道，也什么都不做。</li></ol><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在传输过程中丢失了，这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 当然什么都不知道，也什么都不做，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 都必须重发分组，直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 正确接收为止，这样才能实现可靠通信，但是此时又出现了如下问题。</p><hr /><p><strong>问题1</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 如何知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 是否正确收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 呢？ <strong>解决办法</strong>：<strong>超时重传</strong></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 为每一个已发送的分组都设置了一个超时计时器；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 在超时计时器规定时间内没有收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的确认，就认为分组错误或丢失，就重发该分组。</li></ol><hr /><p><strong>问题2</strong>：若分组正确到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 回送的确认丢失或延迟了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 未收到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的确认，会超时重发。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 可能会收到重复的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 如何知道收到了重复的分组，需要丢弃呢？<strong>解决办法</strong>：<strong>编号</strong></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 为每一个发送的分组都进行编号。若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 为发送的确认也进行编号，指示该确认是对哪一个分组的确认；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</li></ol><img src="https://img-blog.csdnimg.cn/20200307162537973.png" alt="在这里插入图片描述"  /><hr /><p><strong>问题3</strong>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 正确收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的报文，并发送了确认报文给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，但是这个确认报文丢失了怎么办？<strong>解决办法</strong>：<strong>超时重传</strong></p><ol><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 所发送的对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的确认丢失了，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 在设定的超时重传时间内不能收到确认，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 并无法知道是自己发送的分组出错、丢失了，或者 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发送的确认丢失了。因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 在超时计时器到期后就要重传 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>假定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 又收到了重传的分组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 应采取两个行动：第一，丢弃这个重复的分组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，不向上层交付，第二，向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送确认。不能认为已经发送过确认就不再发送，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 之所以重传 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 没有收到对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的确认；</li></ol><hr /><p><strong>问题4</strong>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 正确收到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的报文，并发送了确认报文给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，但是这个确认报文迟到了怎么办？<strong>解决方法</strong>：<strong>丢弃</strong></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 仍然会收到重复的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并且同样要丢弃重复的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并重传确认分组；</li></ol><img src="https://img-blog.csdnimg.cn/20200307164312373.png" alt="在这里插入图片描述"  />**需要注意的是**：<ul><li>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发；</li><li>分组和确认分组都必须进行编号，超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ul><h2 id="42-自动重传请求arq"><a class="markdownIt-Anchor" href="#42-自动重传请求arq"></a> 4.2 自动重传请求ARQ</h2><p>通常 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 最终总是可以收到对所有发出的分组的确认。如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信，使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信，像上述的这种可靠传输协议常称为<strong>自动重传请求 ARQ</strong>  (Automatic Repeat reQuest)，意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p><h2 id="43-连续-arq-协议"><a class="markdownIt-Anchor" href="#43-连续-arq-协议"></a> 4.3 连续 ARQ 协议</h2><p>通过上述描述，我们发现若是每次发送一个数据报，然后等待确认，这样信道利用率是非常低的，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200307165209998.png" alt="在这里插入图片描述" style="zoom: 67%;" /><br />为了提高信道利用率，采用了流水线工作方式，即批量发送数据，然后逐个等待确认，注意每次发送数据的量是有限制的，如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200307165308564.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h3 id="431-基本思想"><a class="markdownIt-Anchor" href="#431-基本思想"></a> 4.3.1 基本思想</h3><p>发送方一次可以发出多个分组，使用<strong>滑动窗口</strong>协议控制发送方和接收方所能发送和接收的分组的数量和编号：</p><blockquote><p><strong>滑动窗口</strong>：位于滑动窗口内的分组才能够发送，位于滑动窗口内的分组才能确认接收。</p></blockquote><p>每收到一个确认，发送方就把发送窗口<strong>向前滑动：</strong><br /><img src="https://img-blog.csdnimg.cn/20200307170126496.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>接收方一般采用<strong>累积确认</strong>的方式：</p><blockquote><p><strong>累积确认</strong>：即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p></blockquote><p>采用<strong>回退N</strong>（Go-Back-N）方法进行重传。</p><blockquote><p><strong>回退N</strong>：如果发送方发送了前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 个分组，而中间的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次，这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个分组。</p></blockquote><h1 id="5-tcp的流量控制"><a class="markdownIt-Anchor" href="#5-tcp的流量控制"></a> 5 TCP的流量控制</h1><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失，<strong>流量控制</strong> (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞，利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。<br /><img src="https://img-blog.csdnimg.cn/20200307171945518.png" alt="在这里插入图片描述"  /><br /><img src="https://img-blog.csdnimg.cn/20200307172004925.png" alt="在这里插入图片描述"  /><br /><img src="https://img-blog.csdnimg.cn/20200307172115795.png" alt="在这里插入图片描述"  /></p><h1 id="6-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#6-tcp的拥塞控制"></a> 6 TCP的拥塞控制</h1><p>TCP的拥塞控制详细内容请参考我的这篇文章：<a href="https://syzdev.cn/2020/03/07/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">计算机网络-TCP拥塞控制</a>。</p><h1 id="7-tcp的运输连接管理"><a class="markdownIt-Anchor" href="#7-tcp的运输连接管理"></a> 7 TCP的运输连接管理</h1><p>TCP的运输连接管理详细内容请参考我的这篇文章：<a href="https://syzdev.cn/2020/03/08/TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/">计算机网络-TCP运输连接管理</a> 。</p><h1 id="8-tcp报文段的首部格式"><a class="markdownIt-Anchor" href="#8-tcp报文段的首部格式"></a> 8 TCP报文段的首部格式</h1><img src="https://img-blog.csdnimg.cn/20200307170926886.png" alt="在这里插入图片描述"  /><ul><li><strong>源端口和目的端口字段</strong>：各占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现；</li><li><strong>序号字段</strong>：占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li></ul><blockquote><p><strong>序号字段</strong>：</p><ul><li>现有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3000</mn></mrow><annotation encoding="application/x-tex">3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个字节的数据。假设报文段的最大数据长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个字节，初始序号为 <code>1001</code>；</li><li>报文段 1 序号 = <code>1001</code> （数据字节序号：<code>1001 ~ 2000</code>）；</li><li>报文段 2 序号 = <code>2001</code> （数据字节序号：<code>2001 ~ 3000</code>）；</li><li>报文段 3 序号 = <code>3001</code> （数据字节序号：<code>3001 ~ 4000</code>）。</li></ul></blockquote><ul><li><strong>确认号字段</strong>：占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号；</li><li><strong>数据偏移（即首部长度）</strong>：占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位字（以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节为计算单位）；</li><li><strong>保留字段</strong>：占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 位，保留为今后使用，但目前应置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li><li><strong>紧急 URG</strong> ： 当 <code>URG = 1</code> 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)；</li><li><strong>确认 ACK</strong> ： 只有当 <code>ACK = 1</code> 时确认号字段才有效。当 <code>ACK = 0</code> 时，确认号无效；</li><li><strong>推送 PSH (PuSH)</strong> ： 接收 TCP 收到 <code>PSH = 1</code> 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付；</li><li><strong>复位 RST (ReSeT)</strong> ： 当 <code>RST = 1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接；</li><li><strong>同步 SYN</strong> ： 同步 <code>SYN = 1</code> 表示这是一个连接请求或连接接受报文；</li><li><strong>终止 FIN (FINish)</strong> ： 用来释放一个连接。<code>FIN = 1</code> 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接；</li><li><strong>窗口字段</strong> ： 占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 字节，用来让对方设置发送窗口的依据，单位为字节；</li><li><strong>检验和</strong> ： 占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 字节的伪首部；</li><li><strong>紧急指针字段</strong> ： 占 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）；</li><li><strong>选项字段</strong> ： 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”；</li><li><strong>填充字段</strong> ： 这是为了使整个首部长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节的整数倍。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UDP协议</title>
    <link href="/2020/03/07/UDP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/03/07/UDP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h1><p>用户数据报协议（UDP，User Datagram Protocol），UDP作为传输层的一个重要的协议，它的主要的功能是在IP 端到端的服务之上，增加了有限的两个功能：</p><ol><li>端口的复用和分用功能；</li><li>差错检测的功能。</li></ol><p>另外，虽然UDP协议只提供<strong>不可靠</strong>的交付，看起来似乎非常不完美，但是UDP协议在某些方面具有特殊的优点，比如我们在看在线视频的时候我们要求数据是最新的最快的，如果这个时候要求数据的准确性，那么会带来较大的延迟，就像我们在看直播球赛的时候，我们希望看到准备直播画面，而不是有延迟半分钟或一分钟的画面，另外一个典型的例子就是在网络管理过程中我们希望采集到网络的实时数据，这个时候网络管理会使用某种基于UDP协议的方式，采集到最新最快的数据，若是采集过来的数据有延迟，那么这个数据已经不是实时数据了，不能表示此时网络的状况了。所以在有些情况下，UDP协议简单快速的特点，比TCP协议更有优势。</p><h1 id="2-udp的主要特点"><a class="markdownIt-Anchor" href="#2-udp的主要特点"></a> 2 UDP的主要特点</h1><ol><li><strong>UDP 是无连接的</strong>：发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延，这个特点是UDP协议的首要特点，可以这么说，UDP其他的特点，都是或多或少源自于这个特点；</li><li><strong>UDP 使用尽最大努力交付</strong>：即不保证可靠交付，因此主机不需要维持复杂的连接状态表，发送端只需要把数据打包成UDP数据报，交给IP协议传输，中间经过了哪些路由器，最后有没有到达目的主机，数据有没有出错，需不需要重传，这些问题主机都不知道；</li><li><strong>UDP 是面向报文的</strong>：所谓报文就是应用层交下来的报文，应用层有各种各样的报文，比如HTTP报文，FTP报文等，根据不同的应用层协议封装成不同的报文，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文，在网络层，IP协议可能会进行拆分工作；</li></ol><blockquote><p><strong>应用程序必须选择合适大小的报文</strong>：</p><ul><li>若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率；</li><li>若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。</li></ul></blockquote><ol start="4"><li><strong>UDP 没有拥塞控制</strong>：因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求，也就是说使用UDP协议的发送端，完全不会感知当前网路的状态是拥塞还是通畅，UDP协议还是会发送出去；</li><li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>：这时目的主机不一定是单个主机，有可能是多个主机同时接收到发送端发送的UDP报文；</li><li><strong>UDP 的首部开销小</strong>：只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个字节，比 TCP 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个字节的首部要短，这样也就意味着把数据组成UDP报文时所要做的工作更少，消耗资源小，发送速度也更快。</li></ol><h1 id="3-udp的首部格式"><a class="markdownIt-Anchor" href="#3-udp的首部格式"></a> 3 UDP的首部格式</h1><h2 id="31-传输关系"><a class="markdownIt-Anchor" href="#31-传输关系"></a> 3.1 传输关系</h2><p>UDP协议作为传输层的一个经典协议，它和上下层的传输关系如下：</p><ol><li>应用层会把应用层报文交付给运输层；</li><li>运输层的UDP协议，直接把上层交付下来的所有数据当作UDP数据报的数据部分，再加上UDP首部交付给下层IP层；</li><li>IP层把运输层交付下来的整个UDP数据报当作IP数据报的数据部分，再加上IP首部，继续交给下一层。</li></ol><p>上述过程如下图所示：<br /><img src="https://img-blog.csdnimg.cn/20200307141819316.png" alt="在这里插入图片描述"  /><br /><img src="https://img-blog.csdnimg.cn/20200307142357399.png" alt="在这里插入图片描述"  /></p><h2 id="32-首部格式"><a class="markdownIt-Anchor" href="#32-首部格式"></a> 3.2 首部格式</h2><p>除去两个端口号字段，还有一个长度字段，它用来标明整个UDP报文的长度是多少，最后一个字段是校验和字段，它实现了对整个UDP报文的校验功能。<br /><img src="https://img-blog.csdnimg.cn/2020030714273429.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h2 id="33-udp-基于端口的分用和复用"><a class="markdownIt-Anchor" href="#33-udp-基于端口的分用和复用"></a> 3.3 UDP 基于端口的分用和复用</h2><p>在UDP首部前两个字段当中，是源端口和目的端口，从接收端来讲，当接收端从 UDP报文中拆解出两个端口号之后，会根据端口号标识的内容，发送给上一层的应用程序，从而实现了端口的分用。</p><p>复用是分用的相反过程，应用程序把数据交付下来之后，其中的端口号就标明了这是哪一个应用进程。<br /><img src="https://img-blog.csdnimg.cn/2020030714330598.png" alt="在这里插入图片描述"  /></p><h2 id="34-udp校验"><a class="markdownIt-Anchor" href="#34-udp校验"></a> 3.4 UDP校验</h2><p>在计算检验和时，临时把“<strong>伪首部</strong>”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和：<br /><img src="https://img-blog.csdnimg.cn/20200307143933688.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>所谓伪首部，可以理解它就是一个“假的”首部，它并没有一个实际的地址空间，在进行 UDP 报文封装的时候并没有这部分内容，要不然UDP协议的首部是 $20 (8+12) $ 字节，而不是我们所说的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个字节，实际传输过程中，也并没有这样的字段。</p><p>设置这个伪首部，只是为了计算 校验和，这个伪首部包含的内容，如上图所示，这就有所疑问了，对于运输层来讲，本身没有IP地址这一概念，因为IP地址是在网络层中路由器转发所用的地址，为了计算校验和而强制引入的伪首部，包含IP地址信息，实际上会破坏网络分层，引入伪首部的目的，就是为了让 UDP 两次检查数据是不是正确的到达了目的地，其中一次是对UDP端口号和其他数据的校验，另一次是对IP地址的再校验，因为 IP 地址在路由器转发过程中，有可能会发现 IP 地址错误，所以 UDP 协议觉得 IP 地址校验是很有必要的。</p><p>如下就是校验的例子，简单来说就是把首部部分，每 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个字节写成一行，然后按列排下来，每一列对应的每一位进行求和，得出来的结果再求反码，再将其放入校验和的位置中。<br /><img src="https://img-blog.csdnimg.cn/20200307145415697.png" alt="在这里插入图片描述"  /></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OSPF协议</title>
    <link href="/2020/03/06/OSPF%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/03/06/OSPF%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>开放最短路径优先 OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在 1989 年开发出来的，OSPF 的原理很简单，但实现起来却较复杂，“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的，“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF，采用分布式的链路状态协议 (link state protocol)。</p><h1 id="2-ospf协议的三个要点"><a class="markdownIt-Anchor" href="#2-ospf协议的三个要点"></a> 2 OSPF协议的三个要点</h1><p>路由表的更新依赖于路由器之间相互交换信息，有以下三个要点：</p><ol><li><strong>与谁交换</strong>：与本自治系统中<strong>所有路由器</strong>交换（注意：在RIP协议中只是和<strong>相邻路由器</strong>交换）；</li><li><strong>交换什么</strong>：相邻的所有路由器的链路状态，本路由器和哪些路由器相邻，与相邻路由器的链路的“度量”（ metric）（注意：在RIP协议中交换路由表）；</li></ol><blockquote><p><strong>度量</strong>：表示费用、距离、带宽、时延等等，这是由网络管理员来决定的，这样用起来灵活很多，在RIP协议中的度量，就是”跳数“，即网络间相隔的路由器的个数。</p></blockquote><ol start="3"><li><strong>何时交换</strong> ：只有当链路状态发生变化时才交换（注意：在RIP协议中是定时交换）。</li></ol><h1 id="3-链路状态路由协议算法"><a class="markdownIt-Anchor" href="#3-链路状态路由协议算法"></a> 3 链路状态路由协议算法</h1><img src="https://img-blog.csdnimg.cn/2020030615350143.png" alt="在这里插入图片描述" style="zoom:67%;" /><ol><li>图中有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 四个路由器分别通过不同的链路相连，通过 OSPF 协议，它们都会把相邻的路由器的链路状态发送给在本自治系统中的所有其他路由器，那么每台路由器数据库中就保存了在这个自治系统中所有路由器的链路状态，也就是说四个路由器中，都保存了其他三个路由器的链路状态；</li><li>每个路由器根据链路状态数据库，就可以获得本自治系统中的带权有向图；</li><li>以带权有向图为基础，以自己为根节点，来计算到其他节点的最短路径，比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 节点获取到与各个节点的最短路径后，就得到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 节点的路由表，如图若想到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 路由器，那么要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 路由器，若想到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 路由器，可直接下一跳到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 路由器。</li></ol><h1 id="4-区域的概念"><a class="markdownIt-Anchor" href="#4-区域的概念"></a> 4 区域的概念</h1><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作<strong>区域</strong>，每一个区域都有一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位的标识符，用点分十进制表示，如下图中 <code>0.0.0.1</code> 就为区域标识符，白色部分为整个自治系统，而每个绿色部分就是划分的区域：<br /><img src="https://img-blog.csdnimg.cn/20200306154422879.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><p>划分的区域不能太大，一个区域内的路由器最好不要超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个，在区域内部可以使用 OSPF 协议，也就是将原来在整个自治系统中使用 OSPF 协议生成最短路径图，换成在每个区域内生成最短路径图，各个区域只管自己内部的路由不往外广播链路状态，这样就减少了整个网络的通信量，提高了网络通信效率。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RIP协议</title>
    <link href="/2020/03/06/RIP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/03/06/RIP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议，在一个自治系统内，RIP 是一种分布式的、<strong>基于距离向量的路由选择协议</strong>。</p><blockquote><p><strong>自治系统</strong>：计算机网络中的自治系统是指能够自主决定在本系统中应采取某种路由协议的单位。</p></blockquote><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的<strong>距离</strong>记录；</p><blockquote><p>**距离：**从一个路由器到直接连接的网络的距离定义为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，RIP 协议中的“距离”也称为“跳数” (hop count)，因为每经过一个路由器，跳数就加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这里的“距离”实际上指的是“最短距离”，RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”，如下图：R1 距离网 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和网 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的距离都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，而R1距离网 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，距离网 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 。<br /><img src="https://img-blog.csdnimg.cn/20200306132319612.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>RIP 允许一条路径最多只能包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 个路由器，“距离”的最大值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 时即相当于不可达。可见 RIP 只适用于小型互联网，RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。</p></blockquote><h1 id="2-rip协议的三个要点"><a class="markdownIt-Anchor" href="#2-rip协议的三个要点"></a> 2 RIP协议的三个要点</h1><p>RIP 协议归根结底就是要更新路由器中的路由表，它采用的更新方式就是通过与其他路由器交换信息来获取最新的路由信息，有三个要点：</p><ol><li><strong>与谁交换</strong>：仅和<strong>相邻</strong>的路由器交换信息；</li><li><strong>交换什么</strong>：交换的信息是本路由器当前所知道的全部信息，即自己的路由表；</li><li><strong>何时交换</strong>：定时交换路由信息，例如，每隔 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 秒。</li></ol><h1 id="3-路由表的建立"><a class="markdownIt-Anchor" href="#3-路由表的建立"></a> 3 路由表的建立</h1><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）。它的路由表是空的，以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息，经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址，RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程，也就是很快就能达到“最优状态”。</p><h2 id="31-距离向量算法"><a class="markdownIt-Anchor" href="#31-距离向量算法"></a> 3.1 距离向量算法</h2><p>距离向量算法就是路由器收到相邻路由器发来的RIP报文时，它所处理的一个过程，如收到相邻路由器（其地址为 <code>X</code> ）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目，把“下一跳”字段中的地址都改为 <code>X</code>，并把所有的“距离”字段的值加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，（因为只要 <code>X</code> 发过来的路由项我们可以使用，那么它的下一跳必然要经过 <code>X</code> ）；</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：若项目中的目的网络不在路由表中，则把该项目加到路由表中（因为通过 <code>X</code> 发过来的RIP报文中表示目的网络是可以到达的，而原来的路由表中是没有这一项的，所以现在该目的网络就变得可以到达了），否则若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目（因为路由表是要更新的，即使路由地址相同，那么由于给的最新地址是表示当前网络的一个最新状态的，所以要替换），否则若收到项目中的距离小于路由表中的距离，则进行更新（因为原本经过本路由器可以到达目的网络，现在经过 <code>X</code> 后到达目的网络距离变短了，所以就更新成下一跳经过 <code>X</code> 到达目的网络的更短的路径），否则什么也不做；</li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>（距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>  表示不可达）；</li><li>返回。</li></ol><p>距离向量算法的基础就是 Bellman-Ford 算法（或 Ford-Fulkerson 算法），这个算法的关键点如下：</p><ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 是结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的最短路径上的一个结点，若把路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 拆成两段路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A→X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">X→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，则每一段路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A→X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">X→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 也都分别是结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的最短路径；</li><li>简单来说就是最短路径上的某两个节点的路径，必然是这两个节点的最短路径。</li></ul><p>路由器之间交换信息与路由表更新：</p><ul><li>RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）；</li><li>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</li></ul><h2 id="32-路由表更新过程举例"><a class="markdownIt-Anchor" href="#32-路由表更新过程举例"></a> 3.2 路由表更新过程举例</h2><img src="https://img-blog.csdnimg.cn/20200306141554282.png" alt="在这里插入图片描述" style="zoom:80%;" /><ol><li>首先把 R4 发来的路由表修改一下，把每一个目的网络的距离都 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>，这是因为我们在路由器 R6 想经过路由器R4 到达目的网络的话，距离必然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>，接下来把下一跳路由器都改成 R4，因为要利用 R4 转发的话，下一跳必然要经过R4，修改后的表为 <code>表4-9(c)</code>；</li><li>把 R6 的路由表，和修改后的 R4 路由表综合起来更新 R6 的路由表；</li><li>在 R4 的路由表中有 <code>Net1 4 R4</code> 这一项，它的意思是要向到达 <code>Net1</code>，下一跳到 R4 ，经过距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 就可以到达，而 R6 的路由表中没有到达 <code>Net1</code> 的路由表项，则直接将该项添加到 R6 的路由表中；</li><li>在 R6 的路由表中，到达 <code>Net2</code> 的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 且经过的正好是 R4，而 R4 路由表中到达 <code>Net2</code> 的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，而每次更新路由表，都反映着整个网络的最新状态，则 R6 要修改 <code>Net2</code> 的距离，修改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>；</li><li>对于 <code>Net3</code>，在修改后的路由表 R4 中是 <code>Net3 2 R4</code>，而 R6 的路由表中是 <code>Net3 4 R5</code>，说明在原 R6 路由表中到达 <code>Net3</code> 的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，不如新更新的路径短，所以把路由项更新为最短的项 <code>Net3 2 R4</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子网划分举例</title>
    <link href="/2020/03/05/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%BE%E4%BE%8B/"/>
    <url>/2020/03/05/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-子网概述"><a class="markdownIt-Anchor" href="#1-子网概述"></a> 1 子网概述</h1><h2 id="11-从两级-ip-地址到三级-ip-地址"><a class="markdownIt-Anchor" href="#11-从两级-ip-地址到三级-ip-地址"></a> 1.1 从两级 IP 地址到三级 IP 地址</h2><p>在 ARPANET 的早期，两级的 IP 地址的设计确实不够合理，所谓两级的IP地址指的是如下网络号与主机号两级，如下图：<br /><img src="https://img-blog.csdnimg.cn/20200304175244180.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><p>这种划分方法的缺点如下：</p><ul><li>IP 地址空间的利用率有时很低；</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏；</li><li>两级的 IP 地址不够灵活。</li></ul><p>从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址，这种做法叫做划分子网 (subnetting) ，划分子网已成为互联网的正式标准协议。</p><p>划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络，从主机号借用若干个位作为子网号 <code>ubnet-id</code>，而主机号 <code>host-id</code> 也就相应减少了若干个位，此时 IP 地址就表示为<code>&#123;&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;&#125;</code> 如下图：<br /><img src="https://img-blog.csdnimg.cn/2020030515025528.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><p>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 <code>net-id</code>，先找到连接在本单位网络上的路由器，然后此路由器在收到 IP 数据报后，再按目的网络号 <code>net-id</code> 和子网号 <code>subnet-id</code> 找到目的子网，最后就将 IP 数据报直接交付目的主机。</p><h2 id="12-子网掩码"><a class="markdownIt-Anchor" href="#12-子网掩码"></a> 1.2 子网掩码</h2><p>子网掩码就是用来计算某个IP地址所属网段的工具，通过与目标IP地址进行与 <code>AND</code> 运算，得到的结果就是子网号，从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分，子网掩码是一个网络或一个子网的重要属性，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器，路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码，若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p><h1 id="2-例题按要求确定子网和子网掩码"><a class="markdownIt-Anchor" href="#2-例题按要求确定子网和子网掩码"></a> 2 例题：按要求确定子网和子网掩码</h1><h2 id="21-题干"><a class="markdownIt-Anchor" href="#21-题干"></a> 2.1 题干</h2><p>已分配了一个C类地址：<code>192.168.5.0</code>，假设需要  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>  个子网，毎个子网有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 台主机试确定各子网地址和子网掩码。</p><h2 id="22-划分过程"><a class="markdownIt-Anchor" href="#22-划分过程"></a> 2.2 划分过程</h2><ol><li>对于这个问题，我们首先要确定的是，要从 C 类地址中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 位主机号中分出多少位来交给子网号使用，现在需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>个子网，若分出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 位作为子网号，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2^4=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 不够，若分出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 位作为子网号，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5 = 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>，去掉全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的子网，那么可分配的子网号有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 个，可以满足要求，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>&lt;</mo><mn>20</mn><mo>&lt;</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^4&lt;20&lt;2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，最后选择分出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 位来交给子网号使用；</li><li>检测剩余的位数能否满足对每个子网中主机个数的要求，由第一步可知用于主机号分配的位数只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>−</mo><mn>5</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">8-5 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 位，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 每个子网中可以提供 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 台主机，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>&gt;</mo><mn>5</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">8&gt; 5+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">2</span></span></span></span> 是因为主机号中全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的主机号是不能分配的），所以得出主机号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 位是可以满足要求的；</li><li>选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 位作为子网号后，子网掩码的最后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 位为 <code>11111000</code>，十进制为 <code>248</code>，从而推出子网掩码为<code>255.255.255.248</code>；</li><li>接下来看看哪些子网地址是可用的，可以看出子网地址可在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mi mathvariant="normal">、</mi><mn>16</mn><mi mathvariant="normal">、</mi><mn>24</mn><mi mathvariant="normal">、</mi><mn>32</mn><mi mathvariant="normal">、</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">、</mi><mn>240</mn></mrow><annotation encoding="application/x-tex">8、16、24、32、...、240</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord cjk_fallback">、</span><span class="mord">1</span><span class="mord">6</span><span class="mord cjk_fallback">、</span><span class="mord">2</span><span class="mord">4</span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord cjk_fallback">、</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span></span></span></span> 共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 个地址中任意选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个来使用；</li><li>为了避免网络和子网号混淆，所以我们一般不使用子网号全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的情况，即 <code>192.168.5.0</code> 是不使用的，那么第一个可使用的子网号为 <code>192.168.5.00001000</code>，全十进制表示为 <code>192.168.5.8</code>，第二个可使用的子网号为 <code>192.168.5.00010000</code>，全十进制为 <code>192.168.5.16</code>，依次类推；</li><li>为了避免子网号和广播地址混淆，所以全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的子网号也不使用，即不使用<code>192.168.5.11111000</code>，那么最后一个可使用的子网号为 <code>192.168.5.11110000</code>，全十进制为 <code>192.168.5.240</code>；</li><li>所以所有可以使用的子网个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">2^5-2 = 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 个，每个子网内可使用的主机号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2^3-2 = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 个 。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IP地址的分类</title>
    <link href="/2020/03/04/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2020/03/04/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>我们把整个互联网看成为一个单一的、抽象的网络，IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位的标识符</strong>，IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers) 进行分配，每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 <code>net-id</code>，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 <code>host-id</code>，它标志该主机（或路由器），这种两级的 IP 地址结构如下：<br /><img src="https://img-blog.csdnimg.cn/20200304175244180.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h1 id="2-分类"><a class="markdownIt-Anchor" href="#2-分类"></a> 2 分类</h1><h2 id="21-各类-ip-地址的网络号字段和主机号字段"><a class="markdownIt-Anchor" href="#21-各类-ip-地址的网络号字段和主机号字段"></a> 2.1 各类 IP 地址的网络号字段和主机号字段</h2><img src="https://img-blog.csdnimg.cn/20200304175355232.png" alt="在这里插入图片描述" style="zoom:80%;" /><h2 id="22-点分十进制记法"><a class="markdownIt-Anchor" href="#22-点分十进制记法"></a> 2.2 点分十进制记法</h2><img src="https://img-blog.csdnimg.cn/20200304175445145.png" alt="在这里插入图片描述" style="zoom:80%;" /><h2 id="23-a类ip地址"><a class="markdownIt-Anchor" href="#23-a类ip地址"></a> 2.3 A类IP地址</h2><img src="https://img-blog.csdnimg.cn/20200304175541679.png" alt="在这里插入图片描述" style="zoom:67%;" /><ul><li>A类IP地址的网络号<code>net-id</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 位，主机号<code>host-id</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 位；</li><li>A类IP地址的网络号<code>net-id</code>的第一位固定为 <code>0</code>；</li><li>A类IP地址能表示的地址范围为 <code>0.0.0.0 ~ 127.255.255.255</code>。</li></ul><blockquote><p>注：实际应用中，网络号和主机号为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 称为特殊的IP地址，有特殊的用处，不分配给主机使用，所以实际上可分配的IP地址，要减去这些特殊的IP地址：</p><ul><li>A类IP地址的保留地址如下：</li><li><code>10.0.0.0 ~ 10.255.255.255</code> 是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）；</li><li><code>127.0.0.0 ~ 127.255.255.255</code> 是保留地址，用做循环测试用的；</li><li><code>0.0.0.0 ~ 0.255.255.255</code> 也是保留地址，用做表示所有的IP地址。</li></ul></blockquote><ul><li>由于网络号不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以网络号取得的最小值为 <code>0000 0001</code> 十进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，网络号取得的最大值为 <code>0111 1110</code> 十进制为 <code>126</code>；</li><li>实际上可用于分配的IP地址范围为 <code>1.x.y.z ~ 126.x.y.z</code>，其中 <code>x.y.z</code> 各位不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或者全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li><li>所以判断一个IP地址是不是A类地址，只要判断他的第一个十进制数是不是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>126</mn></mrow><annotation encoding="application/x-tex">126</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">6</span></span></span></span> 即可。</li></ul><h2 id="24-b类ip地址"><a class="markdownIt-Anchor" href="#24-b类ip地址"></a> 2.4 B类IP地址</h2><img src="https://img-blog.csdnimg.cn/20200304180739539.png" alt="在这里插入图片描述" style="zoom: 67%;" /><ul><li>B类IP地址的网络号 <code>net-id</code> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 位，主机号 <code>host-id</code> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 位；</li><li>B类IP地址的网络号 <code>net-id</code> 的前两位固定为 <code>10</code>；</li><li>B类IP地址能表示的地址范围为 <code>128.0.0.0 ~ 191.255.255.255</code>。</li></ul><blockquote><ul><li><code>172.16.0.0 ~ 172.31.255.255</code> 是私有地址。</li></ul></blockquote><ul><li>由于网络号不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以网络号取得的最小值为 <code>1000 0000 0000 0000</code> 十进制为 <code>128.0</code>，网络号取得的最大值为 <code>1011 1111 1111 1111</code> 十进制为 <code>191.255</code>；</li><li>实际上可用于分配的IP地址范围为 <code>128.0.y.z ~ 191.255.y.z</code>，其中 <code>y.z</code> 各位不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或者全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ul><h2 id="25-c类ip地址"><a class="markdownIt-Anchor" href="#25-c类ip地址"></a> 2.5 C类IP地址</h2><img src="https://img-blog.csdnimg.cn/20200304181919756.png" alt="在这里插入图片描述" style="zoom:67%;" /><ul><li>C类IP地址的网络号 <code>net-id</code> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 位，主机号 <code>host-id</code> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 位；</li><li>C类IP地址的网络号 <code>net-id</code> 的前两位固定为 <code>110</code>；</li><li>C类IP地址能表示的地址范围为 <code>192.0.0.0 ~ 223.255.255.255</code>。</li></ul><blockquote><ul><li><code>192.168.0.0～192.168.255.255</code>是私有地址。</li></ul></blockquote><ul><li>由于网络号不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以网络号取得的最小值为 <code>1100 0000 0000 0000 0000 0000</code> 十进制为<code>192.0.0</code>，网络号取得的最大值为 <code>1101 1111 1111 1111 1111 1111</code> 十进制为 <code>223.255.255</code>；</li><li>实际上可用于分配的IP地址范围为 <code>192.0.0.z ~ 223.255.255.z</code>，其中 <code>z</code> 各位不能为全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或者全 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ul><h2 id="26-ip-地址的指派范围"><a class="markdownIt-Anchor" href="#26-ip-地址的指派范围"></a> 2.6 IP 地址的指派范围</h2><img src="https://img-blog.csdnimg.cn/20200304183652725.png" alt="在这里插入图片描述" style="zoom:80%;" /><h2 id="27-特殊的ip地址"><a class="markdownIt-Anchor" href="#27-特殊的ip地址"></a> 2.7 特殊的IP地址</h2><img src="https://img-blog.csdnimg.cn/20200304183606836.png" alt="在这里插入图片描述" style="zoom:80%;" /><h3 id="271-直接的广播地址"><a class="markdownIt-Anchor" href="#271-直接的广播地址"></a> 2.7.1 直接的广播地址</h3><p>直接广播地址是主机号全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的地址，它的功能是使路由器将一个分组以广播的方式发送给特定网络上的所有主机。</p><h3 id="272-受限的广播地址"><a class="markdownIt-Anchor" href="#272-受限的广播地址"></a> 2.7.2 受限的广播地址</h3><p>网络号和主机号共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span> 位全为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的地址，它的功能是将一个分组以广播的方式发送给本网的所有主机，分组将被本网的所有主机接收而路由器会阻挡这个分组的通过，它只能在网络内部发送和广播。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>扩展以太网</title>
    <link href="/2020/03/04/%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <url>/2020/03/04/%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-在物理层扩展以太网"><a class="markdownIt-Anchor" href="#1-在物理层扩展以太网"></a> 1 在物理层扩展以太网</h1><h2 id="11-使用光纤扩展"><a class="markdownIt-Anchor" href="#11-使用光纤扩展"></a> 1.1 使用光纤扩展</h2><p>主机使用光纤和一对光纤调制解调器连接到集线器，很容易使主机和几公里以外的集线器相连接。<br /><img src="https://img-blog.csdnimg.cn/20200304142417957.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><blockquote><p>光纤是光纤通信的传输媒体，在日常生活中，由于光在光导纤维的传导损耗比电在电线传导的损耗低得多，光纤被用作长距离的信息传递。</p><p>光纤的原理是使用光的全反射，如图，光纤分为内纤芯和外包层，由于纤芯的折射率大于包层的折射率，当光线从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，光也就沿着光纤传输下去。<br /><img src="https://img-blog.csdnimg.cn/202003041437296.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><p>只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射。<br /><img src="https://img-blog.csdnimg.cn/20200304143831466.png" alt="在这里插入图片描述" style="zoom:50%;" /></p></blockquote><h2 id="12-使用集线器扩展"><a class="markdownIt-Anchor" href="#12-使用集线器扩展"></a> 1.2 使用集线器扩展</h2><p>将多个以太网段连成更大的、多级星形结构的以太网，如某个部门有一系，二系，三系通过集线器扩展：<br /><img src="https://img-blog.csdnimg.cn/20200304142606304.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><blockquote><p>集线器的主要功能是对接收到的信号进行再生整形放大转发，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。它工作于“物理层”，如下图是具有三个接口的集线器：<br /><img src="https://img-blog.csdnimg.cn/20200304144252673.png" alt="在这里插入图片描述" style="zoom:50%;" /></p></blockquote><p>使用集线器扩展以太网的优点是使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信，同时扩大了以太网覆盖的地理范围。</p><p>其缺点是使碰撞域增大了，但总的吞吐量并未提高，如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p><blockquote><p>碰撞域（collision domain）又称为冲突域，是指网络中一个计算机点发出的帧会与其他计算机点发出的帧产生碰撞或冲突的那部分网络，碰撞域越大，发生碰撞的概率越高；<br /><img src="https://img-blog.csdnimg.cn/2020030414292761.png" alt="在这里插入图片描述" style="zoom:67%;" /></p></blockquote><h1 id="2-在数据链路层扩展以太网-网桥"><a class="markdownIt-Anchor" href="#2-在数据链路层扩展以太网-网桥"></a> 2 在数据链路层扩展以太网-网桥</h1><p>扩展以太网更常用的方法是在数据链路层进行，早期使用网桥，现在使用以太网交换机。<br /><img src="https://img-blog.csdnimg.cn/20200304144536100.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h2 id="21-网桥"><a class="markdownIt-Anchor" href="#21-网桥"></a> 2.1 网桥</h2><p>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发，网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，网桥的内部结构如下图；<br /><img src="https://img-blog.csdnimg.cn/20200304144725961.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>使用网桥扩展以太网的优点是过滤通信量，扩大了物理范围，提高了可靠性，可互连不同物理层、不同 MAC 子层和不同速率（如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">10 Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100 Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span> 以太网）的局域网。</p><p>其缺点是存储转发增加了时延，在 MAC 子层并没有流量控制功能，具有不同 MAC 子层的网段桥接在一起时时延更大，网桥只适合于用户数不太多（不超过几百个）和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞，这就是所谓的广播风暴。</p><p>网桥能使各网段成为隔离开的碰撞域：<br /><img src="https://img-blog.csdnimg.cn/2020030414480884.png" alt="在这里插入图片描述" style="zoom:67%;" /><br />网桥和集线器不同：</p><ol><li>集线器在转发帧时，不对传输媒体进行检测；</li><li>网桥在转发帧之前必须执行 CSMA/CD 算法，若在发送过程中出现碰撞，就必须停止发送和进行退避；</li><li>集线器工作在物理层，网桥工作在数据链路层。</li></ol><h3 id="211-透明网桥"><a class="markdownIt-Anchor" href="#211-透明网桥"></a> 2.1.1 透明网桥</h3><p>目前使用得最多的网桥是透明网桥 (transparent bridge)，“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。</p><p>网桥的工作原理是将接收到的帧进行过滤转发，所以转发表的建立是网桥中至关重要的问题，网桥应当按照以下自学习算法处理收到的帧和建立转发表：</p><ul><li>若站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送一个帧从网桥的某一接口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 进入网桥，那么反之从接口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 沿着反方向则一定能返回到站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>；</li><li>网桥每次收到一个帧，就记录下发送站点的源地址和进入网桥的接口号，作为转发表中的一项；</li><li>在创建转发表时，就把发送方的源地址写在地址栏处，同时记录下进入网桥的接口，在后续转发帧时则可以查询转发表确定转发的接口。</li></ul><p>建立转发表过程举例：<br /><img src="https://img-blog.csdnimg.cn/20200304154054557.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><ol><li>如图由网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 连接了三个网段 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">LAN1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">LAN3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">3</span></span></span></span>，实现了三个网段的互连，两个网桥各有端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ；</li><li>网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 初始的时候转发表都为空，现图中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">LAN1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">1</span></span></span></span> 网段中的站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 向站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发送数据帧，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 会从它的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 收到该数据帧并查找转发表，此时在转发表中未找到目的地址为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的记录，所以网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就向除端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 以外的其他端口广播这个数据帧，那么这个帧就广播到了网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 所连接的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 上，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 发现源MAC地址不在自己的转发表中，就将源地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 写入到自己的转发表中并记录下进入网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的端口号；</li><li>在发送广播时，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 也收到了这个数据帧，就查找转发表，在转发表中也未找到目的地址为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的目的地址，此时网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 就向除端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之外的其他端口转发这个数据帧，此时这个数据帧就广播到了网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 所连接的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">LAN3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">3</span></span></span></span> 中，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 发现源MAC地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 不在转发表中，就将源地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的MAC地址写入网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的转发表中并记录进入网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的端口号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">LAN3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">3</span></span></span></span> 上的站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 上的站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 发送数据帧时，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 是从端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 接收到站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 发送过来的数据帧，在转发表中未找到目的地址为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的转发表项，此时端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 就向除端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 以外的其他端口转发这个数据帧，这个数据帧就广播到了网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 所连接的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 中的所有站点都可以收到这个数据帧，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 中的站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 发现这个数据帧时发给自己的就接收这个数据帧，其他站点发现不是给自己的就丢弃数据帧，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 发现源地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 不在转发表中，并记录下源地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 和进入网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的端口号，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因为连接这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>A</mi><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">LAN2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span> 也会受到广播 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 发给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的数据帧，网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的转发表中未找到转发表项，所以网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 向除端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 以外的其他端口转发，这个数据帧就转发到了网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的端口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 上，此时网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 发现站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 不在其转发表上，就在转发表中记录下站点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的源地址和进入网桥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的端口号。</li></ol><p>通过上述过程我们可以发现建立转发表是通过不断的发送广播来实现的，但是若有的网络为环形网络，此时这个数据帧会一直在网络在“转圈圈”，在透明网桥中，为了避免这个问题，引入了生成树算法。<br /><img src="https://img-blog.csdnimg.cn/20200304154320569.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h1 id="3-在数据链路层扩展以太网-交换机"><a class="markdownIt-Anchor" href="#3-在数据链路层扩展以太网-交换机"></a> 3 在数据链路层扩展以太网-交换机</h1><p>在第二节中所讲的网桥扩展方法是早期的一种方法，现在使用的方法是<strong>以太网交换机</strong>，以太网交换机通常都有十几个接口。因此，<strong>以太网交换机实质上就是一个多接口的网桥</strong>，可见<strong>交换机也是工作在数据链路层</strong>，以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式，交换机能同时连通许多对的接口，使<strong>每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据</strong>，以太网交换机由于使用了<strong>专用的交换结构芯片</strong>，通过硬件来转发就比靠软件转发的网桥速度快得多，所以交换机的出现很快的就淘汰掉了网桥；<br /><img src="https://img-blog.csdnimg.cn/20200304154648861.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><p>使用交换机能够使用户独享带宽，增加了交换机总带宽，如下图，用集线器扩展的以太网，要平分带宽，而用交换机扩展的以太网，每个站点独享带宽；<br /><img src="https://img-blog.csdnimg.cn/20200304155752770.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><p>在逻辑上，以集线器扩展的以太网，本质还是总线型以太网，必须采用 CSMA/CD 协议来处理碰撞，并且只能以半双工模式工作，而交换机采用的是星型以太网，不使用共享总线，没有碰撞问题，不必使用 CSMA/CD，且采用全双工模式工作，但仍使用以太网帧的结构。<br /><img src="https://img-blog.csdnimg.cn/20200304161542891.png" alt="在这里插入图片描述"  /></p><h2 id="31-以太网交换机的交换方式"><a class="markdownIt-Anchor" href="#31-以太网交换机的交换方式"></a> 3.1 以太网交换机的交换方式</h2><p>以太网交换机的交换方式分为存储转发方式和直通方式：</p><ul><li><strong>存储转发方式</strong>：把整个数据帧先缓存后再进行处理；</li><li><strong>直通 (cut-through) 方式</strong>：接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度，缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul><h2 id="32-以太网交换机的自学习功能"><a class="markdownIt-Anchor" href="#32-以太网交换机的自学习功能"></a> 3.2 以太网交换机的自学习功能</h2><p>交换机的转发依然是依赖于转发表，以太网交换机运行自学习算法自动维护转发表：</p><img src="https://img-blog.csdnimg.cn/20200304161740726.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200304161812299.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200304161841809.png" alt="在这里插入图片描述"  /><img src="https://img-blog.csdnimg.cn/20200304161926366.png" alt="在这里插入图片描述"  />]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSMA/CD协议</title>
    <link href="/2020/03/03/CSMA-CD%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/03/03/CSMA-CD%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>最初的以太网是将许多计算机都连接到一根总线上，易于实现广播通信，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件，总线上每一个计算机都能检测到其他计算机发出的信号，这就是广播通信方式：<br /><img src="https://img-blog.csdnimg.cn/2020030317354712.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />但有时我们想一对一的通信，这种情况下就要在发送数据帧的首部中写明接收主机的地址，如图，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 发送数据时，可以指明接收主机 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 的地址，由于只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 的地址和数据中的接收地址相同，所以只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 接收到数据，其他主机检测到不是发给自己的数据则会丢弃数据，这样就在广播通信中实现了一对一的通信：<br /><img src="https://img-blog.csdnimg.cn/20200303173825595.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h1 id="2-以太网采取了两种重要的措施"><a class="markdownIt-Anchor" href="#2-以太网采取了两种重要的措施"></a> 2 以太网采取了两种重要的措施</h1><p>为了通信的简便，以太网采取了两种重要的措施：</p><ol><li>采用较为灵活的无连接的工作方式 ；</li><li>以太网发送的数据都使用曼彻斯特 (Manchester) 编码。</li></ol><h2 id="21-无连接的工作方式"><a class="markdownIt-Anchor" href="#21-无连接的工作方式"></a> 2.1 无连接的工作方式</h2><p>无连接的工作方式不必先建立连接就可以直接发送数据，对发送的数据帧不进行编号，也不要求对方发回确认，这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的，以太网提供的服务是不可靠的交付，即尽最大努力的交付当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定，如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p><h2 id="22-使用曼彻斯特-manchester-编码"><a class="markdownIt-Anchor" href="#22-使用曼彻斯特-manchester-编码"></a> 2.2 使用曼彻斯特 (Manchester) 编码</h2><p>关于曼彻斯特 (Manchester) 编码，可参考我的这篇文章 <a href="https://syzdev.cn/2020/03/02/%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6/">计算机网络-关于信号的调制</a>  。<br /><img src="https://img-blog.csdnimg.cn/202003031747152.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h2 id="23-存在的问题"><a class="markdownIt-Anchor" href="#23-存在的问题"></a> 2.3 存在的问题</h2><p>总线型以太网在同一时间内只允许一台计算机发送数据，那么该如何协调各个计算机之间的工作？下面介绍的 <strong>CSMA/CD协议</strong> 就是解决方案。</p><h1 id="3-csmacd协议"><a class="markdownIt-Anchor" href="#3-csmacd协议"></a> 3 CSMA/CD协议</h1><p><strong>CSMA/CD</strong>的含义是载波监听多点接入/碰撞检测  (Carrier Sense Multiple Access with Collision Detection) ，“<strong>多点接入</strong>”表示许多计算机以多点接入的方式连接在一根总线上，“<strong>载波监听</strong>”是指每一个计算机在发送数据之前和发送过程中要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞：<br /><img src="https://img-blog.csdnimg.cn/20200303175543163.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>总线上并没有什么载波，因此， 载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号，碰撞检测就是计算机边发送数据边检测信道上的信号电压大小，当几个计算机同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加），当一个计算机检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个计算机同时在发送数据，表明产生了碰撞，在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来，每一个正在发送数据的计算机，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p><p>CSMA/CD协议 的工作流程图：<br /><img src="https://img-blog.csdnimg.cn/20200303180020991.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h2 id="31-存在的问题"><a class="markdownIt-Anchor" href="#31-存在的问题"></a> 3.1 存在的问题</h2><p>既然每一个计算机在发送之前都已经检测到信道当前为空闲那为何还会出现碰撞呢？这是因为数据电磁波在总线上传输时是以有限的速度传播的，如某个计算机监听到总线是空闲时，总线并非真的是空闲的，如下图中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 两个计算机距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">1km</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">m</span></span></span></span>，之间用同轴电缆相连，电磁波在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">1km</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">m</span></span></span></span> 电缆上的传播时延大约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">5ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，因此从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的信息，大约要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">5ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 才能到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送给自己的消息之前也发送了一个数据出去，则必然在某个时间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发出的数据会和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发出的数据在总线上发生碰撞。</p><p>我们把总线上端到端的一趟时间记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，图中当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送数据，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 检测到总线为空闲，在时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>τ</mi><mo>−</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">t=τ-δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>  时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 发送的数据还没有到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 因为检测到总线空闲，就开始发送数据，设在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>τ</mi><mo>−</mo><mi>δ</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t=τ-δ/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 时，发生了碰撞，这时由于数据还在总线上传输，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 都不知道数据发生了碰撞，但当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">t=τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>  时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的数据发送到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 就检测到碰撞了于是停止发送数据，在时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn><mi>τ</mi><mo>−</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">t=2τ-δ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 发送给A的数据到达了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 检测到了碰撞，也停止发送了数据：<br /><img src="https://img-blog.csdnimg.cn/20200303180407609.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h2 id="32重要特性"><a class="markdownIt-Anchor" href="#32重要特性"></a> 3.2重要特性</h2><p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信），每个计算机在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性，这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p><h2 id="33-争用期"><a class="markdownIt-Anchor" href="#33-争用期"></a> 3.3 争用期</h2><p>最先发送数据帧的计算机，在发送数据帧后至多经过时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞，以太网的端到端往返时延 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>  称为<strong>争用期</strong>，或碰撞窗口，经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>以太网取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>51.2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">51.2 us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span> 为争用期的长度，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">10 Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span> 以太网，在争用期内可发送 <code>512 bit</code>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 字节，以太网在发送数据时，若前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span>字节没有发生冲突，则后续的数据就不会发生冲突。如果发生冲突，就一定是在发送的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 字节之内，由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 字节，以太网规定了<strong>最短有效帧长</strong>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 字节，凡长度小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 字节的帧都是由于冲突而异常中止的无效帧。</p><h2 id="34-二进制指数类型退避算法"><a class="markdownIt-Anchor" href="#34-二进制指数类型退避算法"></a> 3.4 二进制指数类型退避算法</h2><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据，这个随机时间就要用到二进制指数类型退避算法 (truncated binary exponential type)：</p><ol><li>确定基本退避时间，一般是取为争用期 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> ；</li><li>定义重传次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">k ≤ 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo></mrow><annotation encoding="application/x-tex">k = Min[</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span></span></span></span>重传次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">, 10]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> ；</li><li>从整数集合 [0,1,…, (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> -1)] 中随机地取出一个数，记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>。重传所需的时延就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 倍的基本退避时间；</li><li>当重传达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 次仍不能成功时即丢弃该帧，并向高层报告。</li></ol><h2 id="35-强化碰撞"><a class="markdownIt-Anchor" href="#35-强化碰撞"></a> 3.5 强化碰撞</h2><p>当发送数据的站一旦发现发生了碰撞时，立即停止发送数据，再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。<br /><img src="https://img-blog.csdnimg.cn/20200303183514679.png" alt="在这里插入图片描述" style="zoom: 55%;" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信道的极限容量</title>
    <link href="/2020/03/02/%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/"/>
    <url>/2020/03/02/%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰，码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。<br /><img src="https://img-blog.csdnimg.cn/202003022134446.png" alt="在这里插入图片描述" style="zoom:62%;" /></p><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p><ol><li>信道能够通过的频率范围；</li><li>信噪比。</li></ol><h1 id="2-信道能够通过的频率范围"><a class="markdownIt-Anchor" href="#2-信道能够通过的频率范围"></a> 2 信道能够通过的频率范围</h1><p>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道，1924 年，<strong>奈奎斯特 (Nyquist)</strong> 就推导出了著名的<strong>奈氏准则</strong>。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值，在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能，如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h2 id="21-奈氏-nyquist-准则"><a class="markdownIt-Anchor" href="#21-奈氏-nyquist-准则"></a> 2.1 奈氏 (Nyquist) 准则</h2><p><strong>理想低通信道</strong>的最高码元传输速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>2</mn><mi>W</mi><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">=2 W Baud</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> 是理想低通信道的带宽，单位为赫兹（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">Hz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Baud</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span></span></span></span> 是波特，是码元传输速率的单位，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 波特为每秒传送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个码元。如下图，发送信号是一种典型的巨型脉冲信号，信号中的高频分量，在传输时受到衰减，接收端收到的波形的前沿和后沿就变得不那么陡峭，这样每个码元所占的时间界限就没有那么明确了，如此一来，接收端收到的信号波形就失去了码元间的清晰界限，这种现象叫做码间串扰。<br /><img src="https://img-blog.csdnimg.cn/20200302215024470.png" alt="在这里插入图片描述" style="zoom: 50%;" /><br />所以在1924年，奈奎斯特 (Nyquist) 推导出著名的奈氏准则，他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值，每赫兹带宽的理想低通信道的最高码元传输速率是每秒  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个码元。</p><p>需要注意的是：</p><ol><li>实际的信道所能传输的最高码元速率，要明显地低于奈氏准则给出上限数值；</li><li>波特（Baud）和比特（bit）是两个不同的概念。波特是码元传输的速率单位（每秒传多少个码元）。码元传输速率也称为调制速率、波形速率或符号速率。比特是信息量的单位；</li><li>信息的传输速率“比特/秒”与码元的传输速率“波特”在数量上有一定的关系；</li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个码元只携带 <code>1 bit</code> 的信息量，则“比特/秒”和“波特”在数值上相等；</li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个码元携带 <code>n bit</code> 的信息量，则 <code>M Baud</code> 的码元传输速率所对应的信息传输速率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>×</mo><mi>n</mi><mi mathvariant="normal">（</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">M×n（b/s）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">）</span></span></span></span>。</li></ol><p>码元的传输速率受奈氏准则的制约，所以要提高信息的传输速率，就必须设法使每个码元能携带更多个比特的信息量。这就需要采用多元制的调制方法，如正交振幅调制 QAM (Quadrature Amplitude Modulation)，可以参考我的这篇文章 <a href="https://syzdev.cn/2020/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6/">计算机网络-关于信号的调制</a> 。</p><h1 id="3-信噪比"><a class="markdownIt-Anchor" href="#3-信噪比"></a> 3 信噪比</h1><p>噪声存在于所有的电子设备和通信信道中，噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误，但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小，<strong>信噪比</strong>就是<strong>信号的平均功率</strong>和<strong>噪声的平均功率</strong>之比。常记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，并用分贝 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">dB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>) 作为度量单位。即：信噪比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mn>10</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>d</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(dB)=10log_{10}(S/N ) (dB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>，例如，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">S/N=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 时，信噪比为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">10dB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，而当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">S/N=1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 时，信噪比为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">30dB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 。</p><h2 id="31-香农-shannon-公式"><a class="markdownIt-Anchor" href="#31-香农-shannon-公式"></a> 3.1 香农 (Shannon) 公式</h2><p>1984年，<strong>香农 (Shannon)</strong> 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（<strong>香农公式</strong>）：</p><ul><li>信道的极限信息传输速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 可表达为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = W log_2(1+S/N)(bit/s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> 为信道的带宽（以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">Hz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span> 为单位）；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 为信道内所传信号的平均功率；</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 为信道内部的高斯噪声功率。</li></ul><p>香农公式表明：</p><ol><li>影响信道的极限信息传输速率的因素有信道的带宽和信噪比，并且信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高；</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输；</li><li>若信道带宽 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> 或信噪比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 也就没有上限；</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li></ol><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>奈氏准则指出码元传输速率是受限的，香农定理则指出了信息传输速率的极限。也就是说，奈氏准则认为码元编码足够好，就不会限制信道传输速率。</p><p>码元传输速率（波特率），是指传输码元的速率，与信道传输速率（比特率）的区别在于，一个码元可以通过多元制的调制方法显示出多种变化，就可以代表多个比特。所以其实区别只有一个，那就是奈氏准则是针对波特率的，没有限制比特率，他认为码元传输速率一旦确定，再确定码元所载的比特数，极限信息传输速率也就确定了；而香农公式则指出信息传输速率也是有极限的，且这个极限不是由波特率单独决定，还是由信道的带宽和信噪比决定的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于信号的调制</title>
    <link href="/2020/03/02/%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6/"/>
    <url>/2020/03/02/%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><h2 id="11-数据通信系统的模型"><a class="markdownIt-Anchor" href="#11-数据通信系统的模型"></a> 1.1 数据通信系统的模型</h2><p><img src="https://img-blog.csdnimg.cn/20200302172730872.png" alt="在这里插入图片描述" /><br /><strong>数据通信的过程如下（从左到右）：</strong></p><ol><li>PC机 (左) 输入文字、图像等数据信号转换为<strong>数字比特流</strong>发送给<strong>调制解调机（Modem，俗称“猫”）</strong>，调制解调器将<strong>数字比特流</strong>转换为<strong>模拟信号</strong>，通过传输系统传输；</li><li>上述过程的逆过程，到PC机 (右)，显示PC机 (左) 发送过来的数据。</li></ol><p><strong>为什么要进行这样复杂的转换？</strong></p><ol><li>我们使用的电话线路传输的是<strong>模拟信号</strong>，而PC机之间传输的是<strong>数字信号</strong>，所以当你想通过电话线把自己的电脑连入Internet 时，就必须使用<strong>调制解调器</strong>来&quot;翻译&quot;两种不同的信号；</li><li>连入Internet 后，当PC机向 Internet 发送信息时，由于电话线传输的是模拟信号，所以必须要用调制解调器来把数字信号&quot;翻译&quot;成模拟信号，才能传送到Internet上，这个过程叫做&quot;调制&quot;。当PC机从Internet获取信息时，由于通过电话线从 Internet 传来的信息都是模拟信号，所以PC机想要看懂它们，还必须借助调制解调器这个“翻译”，这个过程叫作“解调”。总的来说就称为“调制解调”。</li></ol><h2 id="12-基带信号和带通信号"><a class="markdownIt-Anchor" href="#12-基带信号和带通信号"></a> 1.2 基带信号和带通信号</h2><ul><li><strong>基带 (base band) 信号（即基本频带信号）</strong>：来自信源的信号，如PC机 (左) 发出的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，往往包含有较多的低频成分，甚至有直流成分，而许多信道（如电话线）并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制(modulation)</strong>；</li><li><strong>带通 (band pass) 信号</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul><h1 id="2-信号的调制"><a class="markdownIt-Anchor" href="#2-信号的调制"></a> 2 信号的调制</h1><p>调制技术分为两大类，一类是<strong>基带调制</strong>，一类是<strong>带通调制</strong>。</p><h2 id="21-基带调制"><a class="markdownIt-Anchor" href="#21-基带调制"></a> 2.1 基带调制</h2><p>仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为<strong>编码</strong> (coding)。<br /><img src="https://img-blog.csdnimg.cn/20200302175207499.png" alt="在这里插入图片描述" /><br />基带调制常见的编码方式有四种：</p><ol><li><strong>不归零码</strong>：正电平代表 <code>1</code>，负电平代表 <code>0</code>；</li><li><strong>归零码</strong>：正脉冲代表 <code>1</code>，负脉冲代表 <code>0</code>；</li><li><strong>曼彻斯特编码</strong>：位周期中心的向上跳变代表<code>0</code>，位周期中心的向下跳变代表 <code>1</code>。但也可反过来定义；</li><li><strong>差分曼彻斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 <code>0</code>，而位开始边界没有跳变代表 <code>1</code>。</li></ol><h3 id="211-不归零码"><a class="markdownIt-Anchor" href="#211-不归零码"></a> 2.1.1 不归零码</h3><ul><li><strong>原理</strong>：用两种不同的电平表示二进制位 <code>0</code> 和 <code>1</code>，其中高电平为 <code>1</code>，低电平为 <code>0</code>；</li><li><strong>优点</strong>：容易实现；</li><li><strong>缺点</strong>：缺乏同步功能，难以分辨某一位的开始和另一位的结束（如图中相邻的 <code>00</code> 或 <code>11</code>，难以分辨何时开始何时结束），因此发送方和接收方必须要有时钟同步，此外若信号中的相邻 <code>0</code> 或相邻 <code>1</code> 过多，会造成直流分量的累积，但现实中的信道不能传输过多直流分量，这也是为什么要调制的原因。</li></ul><p>下图是不归零码的示意图：<br /><img src="https://img-blog.csdnimg.cn/20200302180318524.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><h3 id="212-归零码"><a class="markdownIt-Anchor" href="#212-归零码"></a> 2.1.2 归零码</h3><ul><li><strong>原理</strong>：归零码是信号电平在一个码元之内都要恢复到零的编码方式，用极性不同的脉冲分别表示二进制的 <code>1</code> 和 <code>0</code>，在脉冲结束之后要维持一段时间的零电平；</li><li><strong>优点</strong>：能够自同步；</li><li><strong>缺点</strong>：信息密度低。</li></ul><p>下图是归零码的示意图：<br /><img src="https://img-blog.csdnimg.cn/20200302180956927.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><h3 id="213-曼彻斯特编码"><a class="markdownIt-Anchor" href="#213-曼彻斯特编码"></a> 2.1.3 曼彻斯特编码</h3><ul><li><strong>原理</strong>：每一位中间都有一个跳变，从低跳到高表示 <code>1</code>，从高跳到低表示 <code>0</code>；</li><li><strong>优点</strong>：克服了不归零码的不足，每一位中间的跳变，既可以当作数据，又可以当作时钟，可以实现自动同步，因此曼彻斯特编码也被称为自带时钟的编码。</li></ul><p>下图是曼彻斯特编码的示意图：<br /><img src="https://img-blog.csdnimg.cn/2020030218160055.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><h3 id="214-差分曼彻斯特编码"><a class="markdownIt-Anchor" href="#214-差分曼彻斯特编码"></a> 2.1.4 差分曼彻斯特编码</h3><ul><li><strong>原理</strong>：每一位中间都有一个跳变，毎位开始时有跳变表示 <code>0</code>，无跳变表示 <code>1</code>。位中间跳变表示时钟，位前跳变表示数据；</li><li><strong>优点</strong>：他的时钟和数据进行了分离，便于提取。</li></ul><p>下图是差分曼彻斯特编码的示意图：<br /><img src="https://img-blog.csdnimg.cn/20200302182120829.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><h3 id="215-基带调制的比较"><a class="markdownIt-Anchor" href="#215-基带调制的比较"></a> 2.1.5 基带调制的比较</h3><p>对于比特流 <code>1000100111</code>，四种编码示意图如下：<br /><img src="https://img-blog.csdnimg.cn/20200302180006515.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p><h2 id="22-带通调制"><a class="markdownIt-Anchor" href="#22-带通调制"></a> 2.2 带通调制</h2><p>使用载波调制，将基带信号的频率范围搬移到较高的频段并转换为模拟信号。<br /><img src="https://img-blog.csdnimg.cn/20200302182610959.png" alt="在这里插入图片描述" /></p><h3 id="221-调幅调频和调相"><a class="markdownIt-Anchor" href="#221-调幅调频和调相"></a> 2.2.1 调幅，调频和调相</h3><p>最基本的二元制调制方法有以下三种：</p><ol><li><strong>调幅（AM）</strong>：载波的振幅随基带数字信号而变化；</li><li><strong>调频（FM）</strong>：载波的频率随基带数字信号而变化；</li><li><strong>调相（PM）</strong>：载波的初始相位随基带数字信号而变化。</li></ol><p>三种调制方法示意图如下：<br /><img src="https://img-blog.csdnimg.cn/202003021828320.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h3 id="222-正交振幅调制qam"><a class="markdownIt-Anchor" href="#222-正交振幅调制qam"></a> 2.2.2 正交振幅调制QAM</h3><p>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法，如下是<strong>正交振幅调制 QAM  (Quadrature Amplitude Modulation) 星座图</strong>，可供选择的相位有 12 种（一共 4 个象限，一个象限有 3 种），而对于每一种相位有 1 或 2 种振幅可供选择（每个象限的平分角有 2 种振幅）。由于 <code>4 bit</code> 编码共有 16 种不同的组合，因此这 16 个点中的每个点可对应于一种 <code>4 bit</code> 的编码。</p><p>并不是码元越多越好，若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。<br /><img src="https://img-blog.csdnimg.cn/20200302183407342.png" alt="在这里插入图片描述" style="zoom:47%;" /></p><blockquote><p>注：图中 r 代表振幅，φ代表相位</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>typedef与#define的区别</title>
    <link href="/2020/01/16/typedef%E4%B8%8Edefine%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/01/16/typedef%E4%B8%8Edefine%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-typedef"><a class="markdownIt-Anchor" href="#1-typedef"></a> 1 typedef</h1><h2 id="11-将复杂的声明简单化"><a class="markdownIt-Anchor" href="#11-将复杂的声明简单化"></a> 1.1 将复杂的声明简单化</h2><p>声明了一个返回 <code>bool</code> 类型并带有两个（<code>int</code> 和 <code>double</code>）形参的函数的指针类型 <code>FuncPointer</code> ：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*FuncPointer)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>声明了一个 <code>FuncPointer</code> 类型的函数指针对象 <code>pFunc</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">FuncPointer pFunc;<br></code></pre></div></td></tr></table></figure><h2 id="12-定义平台无关的类型"><a class="markdownIt-Anchor" href="#12-定义平台无关的类型"></a> 1.2 定义平台无关的类型</h2><p>定义与平台无关的类型，屏蔽不同平台的类型差异化，如定义一个叫 <code>REAL</code> 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> REAL;<br></code></pre></div></td></tr></table></figure><p>在不支持 <code>long double</code> 的平台二上，改为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> REAL;<br></code></pre></div></td></tr></table></figure><p>在连 <code>double</code> 都不支持的平台三上，改为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">float</span> REAL;<br></code></pre></div></td></tr></table></figure><p>也就是说，当跨平台时，只要改下 <code>typedef</code> 本身就行，不用对其他源码做任何修改。</p><h2 id="13-与struct的结合使用"><a class="markdownIt-Anchor" href="#13-与struct的结合使用"></a> 1.3 与struct的结合使用</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">float</span> height;<br>&#125; Person;<span class="hljs-comment">//这是Person是结构体的一个别名</span><br>Person person;<br></code></pre></div></td></tr></table></figure><h2 id="14-typedef使用公式"><a class="markdownIt-Anchor" href="#14-typedef使用公式"></a> 1.4 typedef使用公式</h2><ol><li>先按定义变量的方法写出定义体，如 <code>int i;</code></li><li>将变量名换成新类型名，如将 <code>i</code> 换成 <code>Count</code></li><li>在最前面加上 <code>typedef</code>，如 <code>typedef int Count</code></li><li>然后可以使用新类型名去定义变量。</li></ol><h1 id="2-define"><a class="markdownIt-Anchor" href="#2-define"></a> 2 #define</h1><p>宏定义#define的用法请参考我的这篇文章  <a href="https://syzdev.cn/2020/03/09/%E5%AE%8F%E5%AE%9A%E4%B9%89define%E7%9A%84%E7%94%A8%E6%B3%95/">#define的用法</a>。</p><h1 id="3-typedef与define的区别"><a class="markdownIt-Anchor" href="#3-typedef与define的区别"></a> 3 typedef与#define的区别</h1><h2 id="31-执行时间不同"><a class="markdownIt-Anchor" href="#31-执行时间不同"></a> 3.1 执行时间不同</h2><ul><li>关键字 <code>typedef</code> 在编译阶段有效，由于是在编译阶段，因此 <code>typedef</code> 有类型检查的功能；</li><li><code>#define</code> 则是宏定义，发生在预处理阶段，也就是编译之前，它<strong>只进行简单而机械的字符串替换</strong>，而不进行任何检查。</li></ul><h2 id="32-功能有差异"><a class="markdownIt-Anchor" href="#32-功能有差异"></a> 3.2 功能有差异</h2><ul><li><code>typedef</code> 用来定义类型的别名，定义与平台无关的数据类型，与 <code>struct</code> 的结合使用等；</li><li><code>#define</code> 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li></ul><h2 id="33-作用域不同"><a class="markdownIt-Anchor" href="#33-作用域不同"></a> 3.3 作用域不同</h2><ul><li><code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用；</li><li>而 <code>typedef</code> 有自己的作用域。</li></ul><h2 id="34-对指针的操作"><a class="markdownIt-Anchor" href="#34-对指针的操作"></a> 3.4 对指针的操作</h2><p>二者修饰指针类型时，作用不同，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POINTER int*    <span class="hljs-comment">// #define 定义int*为POINTER</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span>* pointer;   <span class="hljs-comment">// typedef 定义int*为pointer</span><br></code></pre></div></td></tr></table></figure><p>当使用他们定义多个变量时，由于两者实现的形式有所不同，效果也不同，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">pointer p1, p2;<br>POINTER p3, p4;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;<br>p1 = &amp;a;<span class="hljs-comment">// 正确，p1为指针，将a地址赋值给p1</span><br>p2 = &amp;a;<span class="hljs-comment">// 正确，p2为指针，将a地址赋值给p1</span><br>p3 = &amp;a;<span class="hljs-comment">// 正确，p3为指针，将a地址赋值给p1</span><br>p4 = &amp;a;<span class="hljs-comment">// 错误，p4为int型变量</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>变量生存期及作用域</title>
    <link href="/2019/12/13/%E5%8F%98%E9%87%8F%E7%94%9F%E5%AD%98%E6%9C%9F%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2019/12/13/%E5%8F%98%E9%87%8F%E7%94%9F%E5%AD%98%E6%9C%9F%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-变量的生存期和作用域"><a class="markdownIt-Anchor" href="#1-变量的生存期和作用域"></a> 1 变量的生存期和作用域</h1><ul><li>变量的储存方式：动态储存（自动、寄存器）、静态储存（静态和外部）；</li></ul><table><thead><tr><th>储存方式</th><th>名称</th></tr></thead><tbody><tr><td>自动变量</td><td>anto</td></tr><tr><td>寄存器变量</td><td>register</td></tr><tr><td>静态储存</td><td>static</td></tr><tr><td>外部变量</td><td>extern</td></tr></tbody></table><ul><li>基本类型的静态变量（static）系统初始值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，全局变量也会自动初始化 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ；</li><li><code>extern</code> 声明外部变量时，类型名可以写也可以不写，如 <code>extern int A,B,C</code>，也可以写成 <code>extern A,B,C</code>，因为它不是定义变量，可以不指定类型，只需写出外部变量名即可；</li><li>若希望某些外部变量只限于本文件引用，而不能被其他文件引用，可以在定义外部变量时加一个 <code>static</code> 声明，如 <code>static int A;</code>，那么在其他文件引用 <code>extern A</code> 就会报错；</li><li>对局部变量声明 <code>static</code>，作用是把它分配在静态内存，它在整个程序执行过程中不会被释放。对全局变量声明 <code>static</code>，则限定该变量作用域只限于本文件；</li><li>若要求函数只能被本文件内调用，称为<strong>内部函数</strong>，在定义内部函数时，加上 <code>static</code> 即可；</li><li>若要定义外部函数，加上 <code>extern</code> 即可，但C语言默认不加 <code>static</code> 的就会外部函数，可以被其他文件调用；</li></ul><blockquote><ul><li><p><strong>Stack</strong> （栈内存）：主要是用来存储 <strong>function calls</strong>（函数调用）和 <strong>local variables</strong>（局部变量） 的空间，其本质就是一个 <strong>Stack</strong>（栈）。最底层的便是 <code>main()</code> 函数，每调用一个函数时就会执行 <strong>push</strong> 操作，每当函数 <strong>return</strong> 时便执行 <strong>pop</strong> 操作。什么时候 <strong>main()</strong> 也被 <strong>pop</strong> 了，整个程序也就结束了。（如果这个 <strong>stack</strong> 变得太高以至于超出了最大内存地址，就会出现所谓的 <strong>stackoverflow</strong>）；</p></li><li><p><strong>HEAP</strong>（堆内存）：主要是用来存储由 <code>malloc()</code> 等申请的内存位置。如果 <code>malloc()</code> 返回 <strong>null</strong> 的话就往往表示这一块空间已经用完了；</p></li><li><p><strong>Static</strong> (静态内存)：这里的变量的生命周期与整个程序相同，即在进程创建是被申明，在程序退出时被销毁。<strong>global variables</strong>（全局作用域变量）， <strong>file scope variables</strong>（文件作用域变量）和被 <strong>static</strong> 关键字修饰的变量会存在这里。</p></li></ul></blockquote><h1 id="2-默认初始化规则c11"><a class="markdownIt-Anchor" href="#2-默认初始化规则c11"></a> 2 默认初始化规则（C++11）</h1><ul><li>栈中的变量（函数体中的自动变量）和堆中的变量（动态内存）会保有不确定的值；</li><li>全局变量（静态内存）和静态变量（包括局部静态变量，静态内存）会初始化为零。</li></ul><blockquote><p>C++11: If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value. Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件操作总结</title>
    <link href="/2019/12/13/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/13/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-fopen文件操作方式"><a class="markdownIt-Anchor" href="#1-fopen文件操作方式"></a> 1 fopen文件操作方式</h1><table><thead><tr><th>操作方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”只读</td><td>为了输入数据，打开一个已存在的文本文件</td><td>出错</td></tr><tr><td>“w”只写</td><td>为了输出数据，打开一个文本文件（清空）</td><td>建立新文件</td></tr><tr><td>“a”追加</td><td>向文本文件末尾添加数据</td><td>出错</td></tr><tr><td>“rb”只读</td><td>为了输入数据，打开一个已存在的二进制文件</td><td>出错</td></tr><tr><td>“wb”只读</td><td>为了输出数据，打开一个二进制文件（清空）</td><td>建立新文件</td></tr><tr><td>“ab”追加</td><td>向二进制文件末尾添加数据</td><td>出错</td></tr><tr><td>“r+”读写</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”读写</td><td>为了读和写，打开一个文本文件（清空）</td><td>建立新文件</td></tr><tr><td>“a+”读写</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“rb+”读写</td><td>为了读和写，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”读写</td><td>为了读和写，打开一个二进制文件（清空）</td><td>建立新文件</td></tr><tr><td>“ab+”读写</td><td>为了读和写，打开一个二进制文件</td><td>出错</td></tr></tbody></table><ul><li>用“<code>r</code>”方式打开文件只能用于向计算机输入而不能用作向该文件输出数据（<strong>即读数据到变量中</strong>），若文件不存在会出错；</li><li>用“<code>w</code>”方式打开文件只能用于向该文件写数据（<strong>即往文件里写数据</strong>），而不能用来向计算机输入，如果原文件不存在，则创建该文件，若该文件已存在，则打开文件前将其删除，再重新创建一个；</li><li>若要向文件末尾添加数据（不希望删除原有数据），则使用“<code>a</code>”方式，文件不存在会出错；</li><li>带“<code>+</code>”的方式，既可用来输入数据，也可用来输出数据；</li><li>若以任意方式打开文件失败，<code>fopen</code> 函数会返回 <code>NULL；</code></li><li><strong>在以文本文件（ASCII）读入字符时，遇到回车换行符（<code>\r\n</code>），系统把它转换为一个换行符（<code>\n</code>），在输出时把换行符（<code>\n</code>）转换为回车（<code>\r</code>）和换行（<code>\n</code>）两个字符</strong>；</li><li><strong>在以二进制方式时，不进行上述转换，在内存中的数据形式与输出到外部文件中的数据形式完全一致，一一对应</strong>。</li></ul><h2 id="11-打开文件fopen"><a class="markdownIt-Anchor" href="#11-打开文件fopen"></a> 1.1 打开文件fopen</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;abc.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="12-关闭文件fclose"><a class="markdownIt-Anchor" href="#12-关闭文件fclose"></a> 1.2 关闭文件fclose</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">fclose(fp); <span class="hljs-comment">// 关闭成功返回0，否则返回EOF(-1)</span><br></code></pre></div></td></tr></table></figure><h1 id="2-向文件读写字符"><a class="markdownIt-Anchor" href="#2-向文件读写字符"></a> 2 向文件读写字符</h1><h2 id="21-读字符fgetc"><a class="markdownIt-Anchor" href="#21-读字符fgetc"></a> 2.1 读字符fgetc</h2><p>函数原型 <code>int fgetc(FILE *stream)</code>：</p><ul><li>调用形式<code>ch = fgetc(fp)</code>；</li><li>从<code>fp</code>指向的文件读入一个字符，该函数以无符号<code>char</code> 强制转换为<code>int</code>的形式返回读取的字符，读成功，带回所读的字符，失败则返回文件结束标志<code>EOF</code>(-1)。</li></ul><h2 id="22-写字符fputc"><a class="markdownIt-Anchor" href="#22-写字符fputc"></a> 2.2 写字符fputc</h2><p>函数原型 <code>int fputc(int char, FILE *stream)</code>：</p><ul><li>调用形式<code>fputc(ch, fp)</code>；</li><li>把字符 <code>ch</code> 写到文件指针变量 <code>fp</code> 所指的文件中，输出成功返回值就是输出的字符，输出失败则返回<code>EOF</code>(-1)。</li></ul><h1 id="3-向文件读写字符串"><a class="markdownIt-Anchor" href="#3-向文件读写字符串"></a> 3 向文件读写字符串</h1><h2 id="31-读字符串fgets"><a class="markdownIt-Anchor" href="#31-读字符串fgets"></a> 3.1 读字符串fgets</h2><p>函数原型 <code>char *fgets(char *str, int n, FILE *stream)</code>：</p><ul><li>调用形式 <code>fgets(str, n, fp)</code>；</li><li><code>n</code> 为要求得到字符个数（但实际上只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>），从 <code>fp</code> 所指的文件读入一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的字符串，并在最后加一个<code>\0</code>；</li><li>然后把这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个字符存放在字符数组 <code>str</code> 中，若在读完 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个字符之前遇到换行符（<code>\n</code>）或文件结束符<code>EOF</code>，读入结束；</li><li>若执行函数成功，则返回 <code>str</code> 数组首元素的地址，若一开始就遇到文件末尾或读数据出错，则返回 <code>NULL</code>。</li></ul><h2 id="32-写字符串fputs"><a class="markdownIt-Anchor" href="#32-写字符串fputs"></a> 3.2 写字符串fputs</h2><p>函数原型 <code>int fputs(const char *str, FILE *stream)</code>：</p><ul><li>调用形式 <code>fputs(str, fp)</code>，把 <code>str</code> 所指向的字符串写到文件指针变量 <code>fp</code> 指向的文件中，字符串末尾的 <code>\0</code>不输出；</li><li>输出成功返回 <code>0</code>，失败返回 <code>EOF</code>。</li></ul><h1 id="4-格式化方式读写文件"><a class="markdownIt-Anchor" href="#4-格式化方式读写文件"></a> 4 格式化方式读写文件</h1><p><code>fprintf</code> 和 <code>fscanf</code>，在输入时要将文件的ASCII码转换为二进制形式在保存，再输出时又要将二进制形式转换为字符，要花费较多时间。</p><h2 id="41-格式化写fprintf"><a class="markdownIt-Anchor" href="#41-格式化写fprintf"></a> 4.1 格式化写fprintf</h2><p>函数原型 <code>int fprintf(FILE *stream, const char *format, ...)</code>：</p><ul><li>如果成功，则返回写入的字符总数，否则返回一个负数。</li></ul><h2 id="42-格式化读fscanf"><a class="markdownIt-Anchor" href="#42-格式化读fscanf"></a> 4.2 格式化读fscanf</h2><p>函数原型 <code>int fscanf(FILE *stream, const char *format, ...)</code>：</p><ul><li>如果成功，返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 <code>EOF</code>。</li></ul><h1 id="5-二进制向文件读写一组数据"><a class="markdownIt-Anchor" href="#5-二进制向文件读写一组数据"></a> 5 二进制向文件读写一组数据</h1><h2 id="51-二进制读fread"><a class="markdownIt-Anchor" href="#51-二进制读fread"></a> 5.1 二进制读fread</h2><p>函数原型 <code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>，</p><ul><li><code>ptr</code> 为从文件读入的数据保存的地址</li><li><code>size</code> 为要读的字节数</li><li><code>nmemb</code> 为元素的个数，每个元素的大小为 <code>size</code> 字节；</li><li><code>stream</code> 输出流的 <code>FILE</code> 指针；</li><li>返回成功读取的个数。</li></ul><h2 id="52-二进制写fwrite"><a class="markdownIt-Anchor" href="#52-二进制写fwrite"></a> 5.2 二进制写fwrite</h2><p>函数原型 <code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</code>：</p><ul><li><code>ptr</code>为要向文件写入的数据首地址；</li><li><code>size</code>为要写的字节数；</li><li><code>nmemb</code>为元素的个数，每个元素的大小为 <code>size</code> 字节；</li><li><code>stream</code>输入流的<code>FILE</code>指针；</li><li>返回成功写入的个数。</li></ul><h1 id="6-随机读写数据文件"><a class="markdownIt-Anchor" href="#6-随机读写数据文件"></a> 6 随机读写数据文件</h1><h2 id="61-指向文件开头rewind"><a class="markdownIt-Anchor" href="#61-指向文件开头rewind"></a> 6.1 指向文件开头rewind</h2><p>函数原型 <code>void rewind(FILE *stream)</code>：</p><ul><li><code>rewind</code> 的作用是使文件位置标记重新返回文件的开头；</li><li>此函数没有返回值；</li><li>调用形式 <code>rewind(fp);</code>，将 <code>fp</code> 指向文件开头。</li></ul><h2 id="62-改变位置fseek"><a class="markdownIt-Anchor" href="#62-改变位置fseek"></a> 6.2 改变位置fseek</h2><p>函数原型 <code>int fseek(FILE *stream, long int offset, int whence)</code>：</p><ul><li><code>stream</code> 为所操作的文件指针；</li><li><code>offset</code> 这是相对 <code>whence</code> 的偏移量，以字节为单位，<strong>注意它是<code>long int</code>类型</strong>；</li><li><code>whence</code> 这是表示开始添加偏移 <code>offset</code> 的位置。它一般指定为下列常量之一：</li></ul><table><thead><tr><th>常量</th><th>描述</th><th>数字表示</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件的开头</td><td>0</td></tr><tr><td>SEEK_CUR</td><td>文件指针的当前位置</td><td>1</td></tr><tr><td>SEEK_END</td><td>文件的末尾</td><td>2</td></tr></tbody></table><ul><li>向后移动，调用形式 <code>fseek(fp,100L,SEEK_SET);</code>，表示从文件的开头，向后偏移到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个字节；</li><li>向前移动，调用形式 <code>fseek(fp,-200L,SEEK_END);</code>，表示从文件的末尾，向前偏移到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个字节；</li><li>如果成功，则该函数返回零，否则返回非零值。</li></ul><h2 id="63-测定当前位置ftell"><a class="markdownIt-Anchor" href="#63-测定当前位置ftell"></a> 6.3 测定当前位置ftell</h2><p>函数原型 <code>long int ftell(FILE *stream)</code>：</p><ul><li><code>stream</code> 文件指针；</li><li><code>ftell</code> 函数的作用是得到流式文件中文件位置标记的当前位置；</li><li>该函数返回位置标识符的当前值。如果发生错误，则返回 <code>-1L</code>，全局变量 <code>errno</code> 被设置为一个正值。</li></ul><h1 id="7-文件读写出错检测"><a class="markdownIt-Anchor" href="#7-文件读写出错检测"></a> 7 文件读写出错检测</h1><h2 id="71-函数ferror"><a class="markdownIt-Anchor" href="#71-函数ferror"></a> 7.1 函数ferror</h2><ul><li>在调用一个输入输出函数后，可以使用 <code>ferror(fp)</code> 检测是否出现错误；</li><li>返回 <code>0</code> 代表未出错，返回非零表示出错；</li><li>对同一个文件每调用一次输入输出函数，都会产生新的值，应该在每次输入输出函数调用后，立即检测。</li></ul><h2 id="72-函数clearerr"><a class="markdownIt-Anchor" href="#72-函数clearerr"></a> 7.2 函数clearerr</h2><ul><li>若调用一个输入输出函数出错后，<code>ferror</code> 为非零值；</li><li>调用 <code>clearerr(fp);</code>可以将错误标记的值置位 <code>0</code>，以便一下次检测。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>打字机效果实现</title>
    <link href="/2018/05/25/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/05/25/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-效果展示"><a class="markdownIt-Anchor" href="#1-效果展示"></a> 1 效果展示</h1> <iframe   height=150  width=100%  src="https://syzdev.gitee.io/page/p/typing.html"   frameborder=0 > </iframe><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><p>打字机效果实际上是在固定时间间隔内不断刷新显示页面内容的过程，如字符串 <code>str = '今天又是美好的一天'</code> ，时间间隔假设为 150 毫秒，则每隔 150 毫秒就多显示一个字，那么就要讲字符串拆分成子串在不同的时间段显示，实现拆分字符串需要用到 JavaScript Array 对象中的 <code>slice()</code> 方法，该方法可从已有的数组中返回选定的元素，调用语句为 <code>arrayObject.slice(start,end)</code>，意思是取出 <code>arrayObject</code> 中从 <code>start</code> 到 <code>end</code> 的子串，如要取出字符串 <code>str</code> 中的子串 <code>今天</code> ，调用语句为 <code>str.slice(0, 2)</code> 。</p><p>实现固定时间间隔需要用到 Windows 对象中的 <code>setTimeout()</code> 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，在本例中调用的方法是拆分字符串和显示页面内容的方法，只有这样才能在不同时间间隔显示不同的内容，其调用语句为 <code>setTimeout(typing, 150)</code>，句中 <code>typing</code> 为实现上述功能的函数，<code>150</code> 表示时间间隔（单位为毫秒），那么函数 <code>typing</code> 将会每隔 150 毫秒执行一次，为了让每次执行拆分的字符串不同，只需要声明一个外部变量 <code>i</code>，每次执行就 <code>i++</code>，将 <code>i</code> 置于函数 <code>slice</code> 的第二个参数，即 <code>slice(0, i)</code>。</p><p>将字符串显示在页面中需要是用 Document 对象的 <code>getElementById()</code> 方法，该方法可返回对拥有指定 ID 的第一个对象的引用，在本例中想把内容显示在 <code>&lt;div id=&quot;input&quot;&gt;&lt;/div&gt;</code> 中，那么获取其引用的语句为 <code>let content = document.getElementById('input')</code>，再调用 <code>innerHTML</code>，便可将内容显示在页面上。</p><p>实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">typing</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;text&quot;</span>).value<br>    <span class="hljs-keyword">if</span> (i &lt;= str.length) &#123;<br>        content.innerHTML = str.slice(<span class="hljs-number">0</span>, i++) + <span class="hljs-string">&#x27;_&#x27;</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(typing, <span class="hljs-number">150</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        content.innerHTML = str<br>        <span class="hljs-built_in">clearTimeout</span>(timer) <span class="hljs-comment">// 执行结束清除定时器</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽屉侧边栏实现</title>
    <link href="/2018/03/17/%E6%8A%BD%E5%B1%89%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/03/17/%E6%8A%BD%E5%B1%89%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-效果预览"><a class="markdownIt-Anchor" href="#1-效果预览"></a> 1 效果预览</h1> <iframe   height=370  width=100%  src="https://syzdev.gitee.io/page/p/navmenu3.html"   frameborder=0 > </iframe><blockquote><p>注：点击页面中的“三条横杠”打开菜单。</p></blockquote><h1 id="2-实现代码"><a class="markdownIt-Anchor" href="#2-实现代码"></a> 2 实现代码</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>nav-menu-3<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;https://cdn.staticfile.org/ionicons/2.0.1/css/ionicons.min.css&#x27;</span>;</span><br><span class="css">    <span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">font-family</span>: sans-serif;</span><br>    &#125;<br>    .sidebar&#123;<br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#2c3e50</span>;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.8s</span> all;</span><br>    &#125;<br>    .side&#123;<br><span class="css">      <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">list-style</span>: none;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">      <span class="hljs-attribute">color</span>: white;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">80px</span>;</span><br><span class="css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="css">      <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.6s</span> all;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;</span><br><span class="css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#34495e</span>;</span><br>    &#125;<br>    .btn&#123;<br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;</span><br><span class="css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#2c3e50</span>;</span><br><span class="css">      <span class="hljs-attribute">font-family</span>: Ionicons;</span><br><span class="css">      <span class="hljs-attribute">cursor</span>: pointer;</span><br>    &#125;<br>    .btn:before&#123;<br><span class="css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;\f20d&#x27;</span>;</span><br>    &#125;<br>    .btnc:before&#123;<br><span class="css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;\f12a&#x27;</span>;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ion-android-folder&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ion-android-mail&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ion-android-image&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ion-android-cloud&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    $(<span class="hljs-string">&#x27;.btn&#x27;</span>).on(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      $(<span class="hljs-string">&#x27;.btn&#x27;</span>).toggleClass(<span class="hljs-string">&#x27;btnc&#x27;</span>);</span><br><span class="javascript">      $(<span class="hljs-string">&#x27;.sidebar&#x27;</span>).toggleClass(<span class="hljs-string">&#x27;side&#x27;</span>);</span><br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>纯CSS实现两种二级导航栏</title>
    <link href="/2018/03/15/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%A7%8D%E4%BA%8C%E7%BA%A7%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    <url>/2018/03/15/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%A7%8D%E4%BA%8C%E7%BA%A7%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-说明"><a class="markdownIt-Anchor" href="#1-说明"></a> 1 说明</h1><p>两种导航栏分别为横向和纵向，由纯 HTML 和 CSS 实现，实现的原理是 <code>display</code> 属性，默认列表采用  <code>display: none</code>，当鼠标触碰时改为 <code>display: block</code> 。</p><h1 id="2-横向二级导航栏"><a class="markdownIt-Anchor" href="#2-横向二级导航栏"></a> 2 横向二级导航栏</h1><h2 id="21-效果预览"><a class="markdownIt-Anchor" href="#21-效果预览"></a> 2.1 效果预览</h2> <iframe   height=170  width=100%  src="https://syzdev.gitee.io/page/p/navmenu1.html"   frameborder=0 > </iframe><h2 id="22-实现代码"><a class="markdownIt-Anchor" href="#22-实现代码"></a> 2.2 实现代码</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>NavMenu1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>    * &#123;<br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">26px</span>;</span><br>      <br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">list-style-type</span>: none;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#d0d0d0</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">90px</span>;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">26px</span>;</span><br><span class="css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;</span><br><span class="css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#F00</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">float</span>: none</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: black;</span><br><span class="css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#d0d0d0</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">display</span>: none;</span><br>      <br>    &#125;<br><br><span class="css">    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">display</span>: block;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>HTML5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>CSS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Ajax<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>jQuery<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>后台<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>C++<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>PHP<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>C#<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>移动应用<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Android<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>iOS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>数据库<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Oracle<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MySql<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>SqlServer<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MongoDB<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>DB2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>操作系统<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Linux<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Unix<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Mac<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>服务器<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>WebSphere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="3-纵向二级导航栏"><a class="markdownIt-Anchor" href="#3-纵向二级导航栏"></a> 3 纵向二级导航栏</h1><h2 id="31-效果预览"><a class="markdownIt-Anchor" href="#31-效果预览"></a> 3.1 效果预览</h2> <iframe   height=230  width=100%  src="https://syzdev.gitee.io/page/p/navmenu2.html"   frameborder=0 > </iframe><h2 id="32-实现代码"><a class="markdownIt-Anchor" href="#32-实现代码"></a> 3.2 实现代码</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>NavMenu2<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>        #menu &#123;<br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#menu</span> <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">            <span class="hljs-attribute">list-style</span>: none;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#menu</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#d0d0d0</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">26px</span>;</span><br><span class="css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">26px</span>;</span><br><span class="css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">            <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;</span><br><span class="css">            <span class="hljs-attribute">position</span>: relative;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: block;</span><br><span class="css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;</span><br><span class="css">            <span class="hljs-attribute">text-decoration</span>: none;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#F00</span>;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#menu</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: none;</span><br><span class="css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;</span><br><span class="css">            <span class="hljs-attribute">border-bottom</span>: none;</span><br><span class="css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#menu</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: block;</span><br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#menu</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: block;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>HTML5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>CSS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Ajax<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>jQuery<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>后台<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>C++<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>PHP<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>C#<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>移动应用<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Android<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>iOS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>数据库<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Oracle<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MySql<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>SqlServer<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MongoDB<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>DB2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>操作系统<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Linux<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Unix<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Mac<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>服务器<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>WebSphere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>导入css的三种方式</title>
    <link href="/2018/02/22/%E5%AF%BC%E5%85%A5css%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2018/02/22/%E5%AF%BC%E5%85%A5css%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-行内方式"><a class="markdownIt-Anchor" href="#1-行内方式"></a> 1 行内方式</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:red;&quot;</span>&gt;</span>行内方式<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="2-内部样式表"><a class="markdownIt-Anchor" href="#2-内部样式表"></a> 2 内部样式表</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;gbk&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">            <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="css">                <span class="hljs-attribute">background</span>: red;</span><br>            &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内部样式表<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="3-外链方式"><a class="markdownIt-Anchor" href="#3-外链方式"></a> 3 外链方式</h1><h2 id="31-链接式"><a class="markdownIt-Anchor" href="#31-链接式"></a> 3.1 链接式</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;styleSheet&quot;</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;CSS文件路径&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="32-导入式"><a class="markdownIt-Anchor" href="#32-导入式"></a> 3.2 导入式</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">  <span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;CSS文件路径&quot;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="33-链接式和导入式的区别"><a class="markdownIt-Anchor" href="#33-链接式和导入式的区别"></a> 3.3 链接式和导入式的区别</h2><p>链接式 <code>&lt;link&gt;</code> 属于 <code>XHTML</code>，它会优先加载CSS文件到页面。导入式 <code>@import</code> 属于CSS2.1，它会先加载HTML结构在加载CSS文件。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>导入js的三种方式</title>
    <link href="/2018/02/22/%E5%AF%BC%E5%85%A5js%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2018/02/22/%E5%AF%BC%E5%85%A5js%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-行内导入方式不推荐不安全"><a class="markdownIt-Anchor" href="#1-行内导入方式不推荐不安全"></a> 1 行内导入方式（不推荐，不安全）</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;第一种方式&#x27;)&quot;</span>&gt;</span>导入js的第一种方式，行内导入<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="2-内嵌式"><a class="markdownIt-Anchor" href="#2-内嵌式"></a> 2 内嵌式</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;gbk&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">alert(<span class="hljs-string">&#x27;第二种方式&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="3-外链式"><a class="markdownIt-Anchor" href="#3-外链式"></a> 3 外链式</h1><p>如果把 script 元素放在 <code>head</code> 元素里，待浏览器经过下载、解析、执行完 js 文件之后，才会呈现页面内容。如果一个页面需要很多个 js 文件，那么浏览器可能会出现短暂的“白板”，用户体验不好。所以，我们应该把 js 文件放在 <code>&lt;/body&gt;</code> 的前面，这样浏览器会先展现页面给用户，<code>type</code> 属性可以不写。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/xxx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="4-注意点"><a class="markdownIt-Anchor" href="#4-注意点"></a> 4 注意点</h1><p>内嵌导入和外链导入不能合并到一起。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/xxx.js&quot;</span>&gt;</span><br><span class="javascript">alert(<span class="hljs-string">&#x27;这个不会被执行&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>判断合法的出栈序列</title>
    <link href="/2017/11/09/%E5%88%A4%E6%96%AD%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <url>/2017/11/09/%E5%88%A4%E6%96%AD%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-引例"><a class="markdownIt-Anchor" href="#1-引例"></a> 1 引例</h2><blockquote><p>（例）设栈的入栈序列是 1 2 3 4，则下列不可能是其出栈序列的是（  ）。<br />A. 1 2 4 3<br />B. 2 1 3 4<br />C. 1 4 3 2<br />D. 4 3 1 2<br />E. 3 2 1 4</p></blockquote><p>一般人看到此类题目，都会拿起草稿纸，将各个选项都模拟一遍选出正确答案，这当然可以得出正确的答案 （<strong>D</strong> ），但当元素个数过多的时候，这个方法不可取，而且，这种人工模拟过程浪费时间且容易出错，下面将介绍一种简单的做题方法。</p><h2 id="2-做题方法"><a class="markdownIt-Anchor" href="#2-做题方法"></a> 2 做题方法</h2><p><strong>按顺序入栈的序列，任意元素 e ，比 e 先入栈的元素，并且比 e 后出栈的元素，一定是逆序的。</strong></p><p>读起来有点绕口，那么先记下 <strong>“ 后出先入逆序 ”</strong></p><p>以最上面的例题为例，若要<strong>写出所有以 1 2 3 4 为入栈顺序的出栈序列</strong>：<br />暴力求解：4个元素一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mn>4</mn><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">A_4^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span> 共24种排列（下表<strong>加粗<em>斜体</em></strong>部分）</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><em><strong>1234</strong></em></td><td><em><strong>1243</strong></em></td><td><em><strong>1324</strong></em></td><td><em><strong>1342</strong></em></td><td>1423</td><td><em><strong>1432</strong></em></td></tr><tr><td><em><strong>2134</strong></em></td><td><em><strong>2143</strong></em></td><td><em><strong>2314</strong></em></td><td><em><strong>2341</strong></em></td><td>2413</td><td><em><strong>2431</strong></em></td></tr><tr><td>3124</td><td>3142</td><td><em><strong>3214</strong></em></td><td><em><strong>3241</strong></em></td><td>3412</td><td><em><strong>3421</strong></em></td></tr><tr><td>4123</td><td>4132</td><td>4213</td><td>4231</td><td>4312</td><td><em><strong>4321</strong></em></td></tr></tbody></table><p>表格中加粗的排列为合法排列一共有 <strong>14</strong> 个，现在可以随意选一个序列来理解一下什么是  <strong>“ 后出先入逆序 ”</strong>，比如序列：<strong>3 1 2 4</strong></p><ol><li>选择任意元素 e ，这里选择 3</li><li>比 3 后出栈的有三个元素 1 2 4</li><li>其中比 3 先入栈的有两个元素 1 2</li><li>但是 1 2 是正序的，而不是逆序的</li><li>所以这个序列不是合法出栈序列</li></ol><p>（注：可以利用递归设计出相应的算法来判断所有合法序列）</p><p>若只要<strong>求出一共有多少个合法出栈序列</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC53aWtpbWVkaWEub3JnL21hdGgvNC84LzIvNDgyOGZhZjFjMjllNGI2OTk1MjlmMjI3NWNjNjM0NTMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述" /></p><p>将元素个数替换 n 计算即可，计算得 14，该公式称为卡塔兰数（Catalan number）公式，了解更多 <a href="https://en.wikipedia.org/wiki/Catalan_number">点这里</a>。</p><blockquote><p>注：上式中的括号上下两个数（2n 和 n）代表数学中排列组合公式中的 C 上下两个数，即用组合公式来求即可。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组名真的不是指针</title>
    <link href="/2017/10/25/%E6%95%B0%E7%BB%84%E5%90%8D%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88/"/>
    <url>/2017/10/25/%E6%95%B0%E7%BB%84%E5%90%8D%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>参照我之前的两篇文章：</p><ol><li><a href="https://syzdev.cn/2017/09/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/">二维数组做函数的参数</a> ；</li><li><a href="https://syzdev.cn/2017/10/25/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/">动态创建二维数组</a> 。</li></ol><p>事实告诉我们，二维数组名不等于二级指针。</p><h1 id="2-关于一维数组"><a class="markdownIt-Anchor" href="#2-关于一维数组"></a> 2 关于一维数组</h1><p>对于一维数组，用一级指针指向数组名，用一级指针做参数传递一维数组，似乎毫无问题。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> *p = arr;<br>    f(arr); <span class="hljs-comment">// 传参无误，执行无误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-sizeof-运算符和自增运算符"><a class="markdownIt-Anchor" href="#3-sizeof-运算符和自增运算符"></a> 3 <code>sizeof</code> 运算符和自增运算符</h1><p>下面分别用 <code>sizeof</code> 运算符计算指针 <code>p</code> 和 数组 <code>arr</code> 的大小：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *p;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(p) = %d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(p));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(arr) = %d &quot;</span>, <span class="hljs-keyword">sizeof</span>(arr));<br></code></pre></div></td></tr></table></figure><p>上述程序输出结果如下，可见 <code>sizeof</code> 指针是指针的大小，<code>sizeof</code> 数组名是整个数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(p) = <span class="hljs-number">8</span><br><span class="hljs-keyword">sizeof</span>(arr) = <span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure><p class="note note-info">注意：以上程序的运行环境为 64 位操作系统，指针大小为 8 个字节。</p><p>下面分别对指针 <code>p</code> 和数组 <code>arr</code> 进行自增操作：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span> *p = arr;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(++p) = %d&quot;</span>, *(++p));<span class="hljs-comment">// 输出：*(++p) = 2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(++arr) = %d&quot;</span>, *(++arr));   <span class="hljs-comment">// error</span><br></code></pre></div></td></tr></table></figure><p>上述程序输出结果如下，可见指针可以递增操作，而数组名不可以：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">error: lvalue required as increment operand<br></code></pre></div></td></tr></table></figure><p>通过以上两个例子，可以想到：</p><ol><li>数组名不能递增，那数组名有没有可能是常量指针 <code>int *const arr</code>；</li><li>根据错误提示，数组名是不能作为左值的，数组名只能作为右值。</li></ol><h1 id="4-数组名不是常量指针"><a class="markdownIt-Anchor" href="#4-数组名不是常量指针"></a> 4 数组名不是常量指针</h1><p>常量指针可以作为左值，而数组名不可以，给数组名赋值会报错：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p = &amp;i; <span class="hljs-comment">// OK</span><br>arr = &amp;i;<span class="hljs-comment">// error</span><br></code></pre></div></td></tr></table></figure><p>事实上，查阅资料可以发现：</p><blockquote><ol><li>数组的类型是 <code>type[SIZE]</code> （二维数组的类型是 <code>type(*)[SIZE]</code>）；</li><li>常量指针的类型是 <code>type* const</code> 。</li></ol></blockquote><p>两者并不是同一种数据类型，关于这一点，我个人认为在C语言中，数组也是一种数据类型，一种特殊的数据类型，我们知道，在向函数传递二维数组的时候，我们使用了数组指针，即 <code>int (*p)[n]</code>，而数组指针，我们可以理解为C语言为数组创造的一种特殊的指针类型。</p><p>观察下面例子，详细内容可见 <a href="https://syzdev.cn/2017/09/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/">二维数组做函数的参数</a> 。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">0x9ffe40</span> <br><span class="hljs-number">0x9ffe40</span> <br><span class="hljs-number">0x9ffe40</span> <br><span class="hljs-number">0x9ffe40</span><br></code></pre></div></td></tr></table></figure><p>我们可以发现，对于数组名，处于不同类型下取得的值（地址）都是一样的，这个例子的意思是<strong>数组名和指针存在着隐式转换</strong>，这也是很多人把数组名当作指针的一个原因，因为数组名在大多数的情况下都会隐式转换为指针，由于数组名只能作为右值，所以指针也是一个右值的指针。</p><p>既然大多数情况下会隐式转换为指针，那么下面就是少数情况（不会转换为指针）：</p><ol><li>对数组名取地址的时候；</li><li>用 <code>sizeof</code> 运算符计算大小的时候；</li><li>用字符串字面量初始化数组的时候。</li></ol><h1 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5 总结</h1><p>在C语言中，数组名确实和指针有着微妙的关系，但是数组名并不是指针，由于它大部分情况下都表现为一个指针，所以很多地方都认为它是指针，事实上并不是，它只是很像指针而已，我个人认为数组是C语言中一种特殊的数据类型，有着特定类型的指针。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态创建二维数组</title>
    <link href="/2017/10/25/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2017/10/25/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>参照我之前的一篇文章 <a href="https://syzdev.cn/2017/09/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/">二维数组做函数的参数</a>，文章中提到，当我们想向函数传递二维数组的时候，是不可以用二级指针作为形参的，正确的方法是用数组指针作为形参，详细内容点击上面的链接。</p><p>在C语言中，想把 <code>int arr[2][3]</code> 这样的二维数组传递到函数 <code>void f(int **arr)</code> 是不可能的，那么有没有办法可以实现呢？答案是可以的，但是需要用到另一种方法，就是<strong>动态创建二维数组</strong>。</p><p>我们知道，在C语言中，创建一个数组，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 维也好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 维也好，都是在内存中线性存储的。现在以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 维数组为例，C语言中声明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 维数组的语句为 <code>int arr[ROW][COLUMN];</code>，现声明<code>int arr[2][5]</code> ，其在内存中的排列如下：<br /><img src="https://img-blog.csdnimg.cn/20200422145731117.jpg" style="zoom:90%;" /></p><h1 id="2-动态创建的实现方法"><a class="markdownIt-Anchor" href="#2-动态创建的实现方法"></a> 2 动态创建的实现方法</h1><h2 id="21-方法1适用于二级指针传递"><a class="markdownIt-Anchor" href="#21-方法1适用于二级指针传递"></a> 2.1 方法1（适用于二级指针传递）</h2><p>动态分配的思路是：</p><ol><li>分配一段内存保存 <code>ROW</code> 个指针；</li><li>为 <code>ROW</code> 个指针每个都分配 <code>COLUMN</code> 大小的空间。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ROW (2)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COLUMN (3)</span><br><br><span class="hljs-keyword">int</span> **p = (<span class="hljs-keyword">int</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> *) * ROW);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ROW; i++) &#123;<br>    p[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * COLUMN);<br>&#125;<br></code></pre></div></td></tr></table></figure><p class="note note-info">需要注意第4行的 malloc 和第6行的 malloc 两者的区别</p><p>创建后其在内存的示意图如下：<br /><img src="https://cdn.u1.huluxia.com/g3/M03/4F/11/wKgBOV6f7jCAJiXOAABmJXkxoFo306.jpg" alt="这里写图片描述" style="zoom:80%;" /></p><h2 id="22-方法2模拟c语言数组的储存方式"><a class="markdownIt-Anchor" href="#22-方法2模拟c语言数组的储存方式"></a> 2.2 方法2（模拟C语言数组的储存方式）</h2><p>动态分配的思路是：</p><ol><li>创建一段 <code>ROW * COLUMN</code> 长的内存空间；</li><li>用 <code>p[ i * COLUMN + j ]</code> 的方式模拟 <code>p[i][j]</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ROW (2)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COLUMN (3)</span><br><br><span class="hljs-keyword">int</span> *p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * ROW * COLUMN);<br></code></pre></div></td></tr></table></figure><p>创建后其在内存的示意图如下：<br /><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI1MjAxNzI1MzMx?x-oss-process=image/format,png" alt="这里写图片描述" /></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是补码，怎么求补码</title>
    <link href="/2017/10/15/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A5%E7%A0%81%EF%BC%8C%E6%80%8E%E4%B9%88%E6%B1%82%E8%A1%A5%E7%A0%81/"/>
    <url>/2017/10/15/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A5%E7%A0%81%EF%BC%8C%E6%80%8E%E4%B9%88%E6%B1%82%E8%A1%A5%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>上一篇文章谈到在汇编语言中，<a href="https://syzdev.cn/2017/10/09/%E4%B8%BA%E4%BB%80%E4%B9%88SHL%E5%92%8CSAL%E7%9B%B8%E5%90%8C/#">为什么 SHL 和 SAL 相同，而 SHR 和 SAR 不同</a>，由此产生的疑惑更多了，到底什么是符号位，什么是补码？</p><h1 id="2-为什么要有补码"><a class="markdownIt-Anchor" href="#2-为什么要有补码"></a> 2 为什么要有补码</h1><p>理由是<strong>计算机内部只有加法器，并没有减法器</strong>，所以在计算机中，在我们人类眼中很简单的算术运算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>−</mo><mn>3</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2-3=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 计算机是无法完成的，依照计算机只能做加法，可以把计算转换为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 + (-3) = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，因此数在计算机中必然要有特定的表示，那么补码就诞生了。</p><h1 id="3-什么是补码"><a class="markdownIt-Anchor" href="#3-什么是补码"></a> 3 什么是补码</h1><p>无符号（unsigned）的一个字节数表示如下：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">0000 </span><span class="hljs-number">0000</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0001</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0010</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1111 </span><span class="hljs-number">1111</span> <span class="hljs-string">=</span> <span class="hljs-number">255</span><br></code></pre></div></td></tr></table></figure><p>有符号数（signed）的一个字节数表示如下：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">0000 </span><span class="hljs-number">0000</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0001</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0010</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1000 </span><span class="hljs-number">0000</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><br><span class="hljs-number">1000 </span><span class="hljs-number">0001</span> <span class="hljs-string">=</span> <span class="hljs-number">-1</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1111 </span><span class="hljs-number">1111</span> <span class="hljs-string">=</span> <span class="hljs-number">-127</span><br></code></pre></div></td></tr></table></figure><p>那么问题就出现了，<code>0000 0000</code> 和 <code>1000 0000</code> 都代表着数字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，不仅如此，且计算两个数相加由于存在符号位会非常复杂，比如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">    0000 0010</span><br>+   1000 1100<br>---------------<br><span class="hljs-code">    ???? ????</span><br></code></pre></div></td></tr></table></figure><p>这必然给计算机运算器带来麻烦，于是约定，将 <code>1000 0000</code> 约定为 <code>-128</code>，了解更多 <a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/bias.html">点这里</a>，因此范围被定义为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">-128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> X <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">+127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span> ，虽然两个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的表示问题解决了，但是计算问题依旧相当复杂，于是就引进了补码。</p><p>查阅教材，对于补码的定义如下：</p><blockquote><p>正数的补码就是原码，负数的补码是符号位不变（1），其余位取反，然后加一。并且给出以下规定：一个有符号数的最高位为符号位，0 代表这个数为正数，1 代表这个数为负数。</p></blockquote><p>依照这种定义，先来看几个简单的例子：<br />【例1】用补码计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn><mo>+</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">45 + 24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">0010 1101</span><br>+   0001 1000<br>---------------<br><span class="hljs-code">0100 0101</span><br></code></pre></div></td></tr></table></figure><p>正确答案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>69</mn></mrow><annotation encoding="application/x-tex">69</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">9</span></span></span></span> 也是轻而易举的求出来了</p><p>【例2】用补码计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn><mo>−</mo><mn>38</mn></mrow><annotation encoding="application/x-tex">45 - 38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span></span></span></span> 。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">    0010 1101</span><br>+   1101 1010 <br>-----------------<br>(1) 0000 0111<br></code></pre></div></td></tr></table></figure><p>计算这一题的时候就有些犹豫了，因为进位已经到了符号位，那么符号位到底参与运算吗？常理来说，符号位顾名思义，代表着数的正负，怎么可以参与运算呢？事实却恰恰相反，符号位参与运算的结果才是正确的，如上例所示。</p><h1 id="4-什么才是正真的补码"><a class="markdownIt-Anchor" href="#4-什么才是正真的补码"></a> 4 什么才是正真的补码</h1><p>上述的例子说明了一个非常矛盾的事情，把一个数的最高位定义为了符号位，计算中符号位却能参与运算，想必这也是很多人蒙在鼓里的地方了。</p><p>补码的定义（以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 位字长数为例）：</p><table><thead><tr><th>表示</th><th>范围</th><th></th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">+127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span></td><td></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">-128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td><td></td></tr></tbody></table><p>也就是说，正数的补码就是原码，而反码的补码等于位数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span> 减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 的绝对值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|X|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span></span></span></span>，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>38</mn></mrow><annotation encoding="application/x-tex">-38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">8</span></span></span></span> 的补码：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">  1 0000 0000</span><br><span class="hljs-bullet">-   </span>0010 0110<br>----------------<br><span class="hljs-code">    1101 1010</span><br></code></pre></div></td></tr></table></figure><p>所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>38</mn></mrow><annotation encoding="application/x-tex">-38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">8</span></span></span></span> 的补码为<code>1101 1010</code> ，在这种定义下，没有反码的概念，也没有符号位的概念。</p><h1 id="5-参考"><a class="markdownIt-Anchor" href="#5-参考"></a> 5 参考</h1><ol><li><a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/bias.html">Signed Int: Bias/Excess Notation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>组成原理与汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么SHL和SAL相同</title>
    <link href="/2017/10/09/%E4%B8%BA%E4%BB%80%E4%B9%88SHL%E5%92%8CSAL%E7%9B%B8%E5%90%8C/"/>
    <url>/2017/10/09/%E4%B8%BA%E4%BB%80%E4%B9%88SHL%E5%92%8CSAL%E7%9B%B8%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-移位指令简介"><a class="markdownIt-Anchor" href="#1-移位指令简介"></a> 1 移位指令简介</h1><h2 id="11-左移"><a class="markdownIt-Anchor" href="#11-左移"></a> 1.1 左移</h2><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SALOPD, OPS <span class="hljs-comment">; 算术左移，操作数左移，最低位补0，最高位进CF</span><br><span class="hljs-keyword">SHL</span>OPD, OPS <span class="hljs-comment">; 逻辑左移，操作数左移，最低位补0，最高位进CF</span><br></code></pre></div></td></tr></table></figure><h2 id="12-右移"><a class="markdownIt-Anchor" href="#12-右移"></a> 1.2 右移</h2><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">SAROPD, OPS <span class="hljs-comment">; 算术右移，操作数右移，最高位不变，最低位进CF</span><br><span class="hljs-keyword">SHR</span>OPD, OPS <span class="hljs-comment">; 逻辑右移，操作数右移，最高位补0，最低位进CF</span><br></code></pre></div></td></tr></table></figure><p>观察发现，左移指令 <code>SAL</code> 和 <code>SHL</code> 是进行同样的操作，而右移指令 <code>SAR</code> 和 <code>SHR</code> 进行的是不同的操作。</p><h1 id="2-为什么两者会有不同"><a class="markdownIt-Anchor" href="#2-为什么两者会有不同"></a> 2 为什么两者会有不同</h1><p>先来看一段 C 语言程序，该程序将 <code>char</code> 类型的有符号数 <code>n</code> 和无符号数 <code>m</code> 分别左移一位并输出：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> n = <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> m = <span class="hljs-number">64</span>;<br>    n = n &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 左移一位</span><br>    m = m &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 左移一位</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n = %d\n&quot;</span>, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;m = %d&quot;</span>, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">n = <span class="hljs-number">-128</span><br>m = <span class="hljs-number">128</span><br></code></pre></div></td></tr></table></figure><p>我们知道C语言中移位操作常用于快速乘除（左移为乘，右移为除），但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 为什么左移 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 位后变成了一个负数呢？十进制数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span> 的二进制码为 <code>01000000</code>，当它左移后变成 <code>10000000</code> ， <code>n</code> 为一个有符号数，所以 <code>10000000</code> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">-128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>，<code>m</code> 为一个无符号数，所以 <code>10000000</code> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 。</p><h2 id="21-关于左移操作"><a class="markdownIt-Anchor" href="#21-关于左移操作"></a> 2.1 关于左移操作</h2><p>可以发现，<strong>左移操作相当于乘法操作，它是会让操作数变大的</strong>，也就是说<strong>它随时存在着溢出的风险</strong>，<strong>若左移操作保留符号位</strong>的话，那么左移会出现越来越小的情况，但你的本意是让这个数变大。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDA5MjEzNzM2ODM1?x-oss-process=image/format,png" alt="这里写图片描述" /></p><p>左移后却发现数变小了，为了避免这种溢出带来的问题，统一了左移操作，也就是说在左移操作中，寄存器只负责储存这个数（不管是否合乎人意，它只要是个数就行），若没有溢出的时候则原样存储。所以说左移操作是会改变符号位的（也就是上述 C 语言的例子）。</p><h2 id="22-关于右移操作"><a class="markdownIt-Anchor" href="#22-关于右移操作"></a> 2.2 关于右移操作</h2><p>右移操作的算术操作是除法，那么在计算机中是肯定让这个数变小的，所以<strong>不存在溢出的风险</strong>，那么设计者就把是否保留符号位的权力交给了程序编写人员，<strong>所以 <code>SAR</code> 和<code>SHR</code> 是两个不同的操作</strong>。</p><h2 id="23-左移与右移的操作码"><a class="markdownIt-Anchor" href="#23-左移与右移的操作码"></a> 2.3 左移与右移的操作码</h2><h3 id="231-左移操作"><a class="markdownIt-Anchor" href="#231-左移操作"></a> 2.3.1 左移操作</h3><p>下面是 <code>SAL</code> 的操作码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDA5MjE1ODE3MDk3?x-oss-process=image/format,png" alt="这里写图片描述" /></p><p>下面是 <code>SHL</code> 的操作码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDA5MjE1ODMxOTA1?x-oss-process=image/format,png" alt="这里写图片描述" /></p><p>可以明显发现，两者对应操作的机器码是完全相同的，由此可以断定， <strong><code>SHL</code> 和 <code>SAL</code>是不同名的同种操作</strong>。</p><h3 id="232-右移操作"><a class="markdownIt-Anchor" href="#232-右移操作"></a> 2.3.2 右移操作</h3><p>下面是 <code>SAR</code> 的操作码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDA5MjIwMTM1NzMx?x-oss-process=image/format,png" alt="这里写图片描述" /></p><p>下面是 <code>SHR</code> 的操作码：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDA5MjIwMTQ5MDEz?x-oss-process=image/format,png" alt="这里写图片描述" /></p><p>可以发现它们对应的机器码是不同的，<strong>所以 <code>SAR</code>和 <code>SHR</code>是两个不同的操作</strong>。</p><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ol><li><a href="https://en.wikibooks.org/wiki/X86_Assembly">x86 Assembly - wikibooks</a></li><li><a href="http://scc.qibebt.cas.cn/docs/optimization/VTune%28TM%29%20User%27s%20Guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/instruct32_hh/vc283.htm">SAL/SAR/SHL/SHR - 移位操作码表</a></li></ol><p>维基百科提到：</p><blockquote><p>Logical shifts are best used with unsigned numbers ，In an arithmetic shift, the spaces are filled in such a way to preserve the sign of the number being slid. For this reason, arithmetic shifts are better suited for signed numbers in two’s complement format.</p><p>逻辑移位最好用于无符号数，在算术移位中，移位空间被补 0 或者保留高位（即符号位）的方式处理，因此，算术移位操作更适用于两个有符号数的补码操作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>组成原理与汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是尾递归</title>
    <link href="/2017/09/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    <url>/2017/09/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1-尾递归简介"><a class="markdownIt-Anchor" href="#1-尾递归简介"></a> 1 尾递归简介</h1><p>想必大家都知道递归是什么，第一次接触尾递归，首先要从它的定义说起：</p><p><strong>尾递归</strong>：当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作。</p><p>举一个简单的例子，用递归算阶乘：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * factorial(n<span class="hljs-number">-1</span>); <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们模拟一下程序的过程，例如当 <code>n = 5</code> 的时候：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">factorial(<span class="hljs-number">5</span>)<br><span class="hljs-number">5</span> * factorial(<span class="hljs-number">4</span>)<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * factorial(<span class="hljs-number">3</span>))<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * (<span class="hljs-number">3</span> * factorial(<span class="hljs-number">2</span>)))<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * (<span class="hljs-number">3</span> * (<span class="hljs-number">2</span> * factorial(<span class="hljs-number">1</span>))))<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * (<span class="hljs-number">3</span> * (<span class="hljs-number">2</span> * <span class="hljs-number">1</span>)))<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * (<span class="hljs-number">3</span> * <span class="hljs-number">2</span>))<br><span class="hljs-number">5</span> * (<span class="hljs-number">4</span> * <span class="hljs-number">6</span>)<br><span class="hljs-number">5</span> * <span class="hljs-number">24</span><br><span class="hljs-number">120</span><br></code></pre></div></td></tr></table></figure><p>上述的递归过程中，“最长”的部分，即代表着此刻占用的栈内存最大，所以在一般的递归中，它的内存占用，先是增大，后来到达一个峰值，然后缩小。</p><p>下面给出尾递归的实现方法，看到这段代码后，第一印象会发现函数参数多了一个 <code>tmp</code>，事实上 <code>tmp</code> 代表着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">！</mi></mrow><annotation encoding="application/x-tex">1！</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">！</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的阶乘的值）也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，于是在使用函数的时候，第二个参数传递一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>, n * tmp);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们同样模拟一下程序的过程，例如当 <code>n = 5</code> 的时候：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">factorial(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)<br>factorial(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>factorial(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>)<br>factorial(<span class="hljs-number">2</span>, <span class="hljs-number">60</span>)<br>factorial(<span class="hljs-number">1</span>, <span class="hljs-number">120</span>)<br><span class="hljs-number">120</span><br></code></pre></div></td></tr></table></figure><p>通过这个过程，我们可以发现，它完全对应着<strong>尾递归</strong>的定义，即当递归调用是整个函数体中最后执行的语句且它的返回值<strong>不属于表达式的一部分时</strong>，这个递归调用就是尾递归。尾递归函数的特点是在<strong>回归过程中不用做任何操作</strong>。</p><p>尾递归比线性递归（第一个例子称为线性递归）多一个参数，这个参数是上一次调用函数得到的结果，并且每次递归的时候都会保留着上次递归的结果，它不属于表达式的一部分，而且它需要回归的数据，本身已经通过参数携带，所以回归过程中不用做任何操作，所以，<strong>相比较线性递归，尾递归占用的栈内存是恒定的</strong>。</p><h1 id="2-总结"><a class="markdownIt-Anchor" href="#2-总结"></a> 2 总结</h1><p>既然尾递归相比线性递归解决了线性递归致命的缺点（stack overflow风险），是不是更提倡使用尾递归呢？</p><p>答案不是的，参考<a href="https://www.amazon.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%BB%B4%E6%96%AF/dp/B002WC7NGS/ref=sr_1_1/461-9973757-8677354?s=books&amp;ie=UTF8&amp;qid=1504591133&amp;sr=1-1&amp;keywords=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">数据结构与算法分析-C语言描述</a>中的一个例子，打印一个链表：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Bad use of recursion : Printing a linked list */</span><br><span class="hljs-comment">/* No header */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(List L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L != <span class="hljs-literal">NULL</span>) &#123;<br>        PrintElement(L-&gt;Element);<br>        PrintList(L-&gt;Next);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这里使用尾递归就是一个不好的例子，因为没有什么需要存储，在递归结束调用的时候，实际上并没有需要存储的值，因此，我们就可以带着在第一次递归调用中已经用过的那些值， <code>goto</code> 到函数的顶部，下面是改进后的程序（记住，应该更加自然的使用 <code>while</code> 循环结果去去除尾递归，这里使用 <code>goto</code> 只是为了说明编译器是如何自动地去除尾递归）。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Printing a linked list non-recursively */</span><br><span class="hljs-comment">/* Uses a mechanical translation */</span><br><span class="hljs-comment">/* No header */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-built_in">list</span> L)</span></span><br><span class="hljs-function"></span>&#123;<br>    top:<br>    <span class="hljs-keyword">if</span> (L != <span class="hljs-literal">NULL</span>) &#123;<br>        PrintElement(L-&gt;Element);<br>        L = L-&gt;Next;<br>        <span class="hljs-keyword">goto</span> top;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不用递归去打印一个链表，事实上尾递归的去除是如此的简单，以至于某些编译器可以自动完成，所以这些工作不用程序员去完成，但是即使如此，最好还是在编写程序时避免出现尾递归。</p><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><ol><li><a href="https://stackoverflow.com/questions/33923/what-is-tail-recursion">What is tail recursion - StackOverflow?</a></li><li><a href="https://www.amazon.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0-%E7%BB%B4%E6%96%AF/dp/B002WC7NGS/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1504591823&amp;sr=1-1&amp;keywords=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">数据结构与算法分析:C语言描述(原书第2版) - Mark Allen Weiss</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二维数组做函数的参数</title>
    <link href="/2017/09/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <url>/2017/09/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-引例"><a class="markdownIt-Anchor" href="#1-引例"></a> 1 引例</h1><p>下面的程序很简单，定义了一个<code>PrintMatrix</code>函数将一个二维数组以矩阵的形式打印出来。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE (4)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> matrix[SIZE][SIZE] = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br>    &#125;;<br>    PrintMatrix(matrix);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当我们编译这个程序的时候会出现下面的错误信息：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>cannot convert &#x27;int (* )[4]&#x27; to &#x27;int**&#x27;<br></code></pre></div></td></tr></table></figure><p>按理来说，一维数组对应着一级指针，就像我们经常使用的，作为函数参数的时候也不理外：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-attribute">int</span> *p = arr;<br></code></pre></div></td></tr></table></figure><p>那么二维数组对应着二级指针怎么就出错了呢？<br />要想解释清楚这个问题，首先需要知道二级指针和二维数组的定义：</p><ul><li><strong>二维数组</strong>：二维数组本质上是以数组作为数组元素的数组，即“数组的数组”；</li><li><strong>二级指针</strong>：指向指针的指针。</li></ul><p>下面将会从两种观点来分析这个问题。</p><h1 id="2-观点1-这种使用方法是错误的"><a class="markdownIt-Anchor" href="#2-观点1-这种使用方法是错误的"></a> 2 观点1 这种使用方法是错误的</h1><p>举一个简单的例子，定义一个二维数组。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>假如用一个二级指针指向它。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> **p = a;<br></code></pre></div></td></tr></table></figure><p>运行如下代码（打印了<code>a</code>的值和<code>a</code>，<code>a[0]</code>，<code>a[0][0]</code> 的地址）：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x \n&quot;</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure><p>运行的结果是输出的四行结果是完全一样的（不同计算机输出的地址可能不同）：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0x9ffe40</span><br><span class="hljs-number">0x9ffe40</span><br><span class="hljs-number">0x9ffe40</span><br><span class="hljs-number">0x9ffe40</span><br></code></pre></div></td></tr></table></figure><p>既然 <code>int **p = a;</code>，可以推出 <code>p</code> 保存的是 <code>a[0][0]</code> 的地址，那么用 <code>*</code> 号可以对其解引用指针而取出地址的内容，于是测试以下代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d \n&quot;</span>, *&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure><p>为 <code>p</code> 指针进行了一次解引用，和预期的一样，输出了二维数组 <code>a</code> 的第一个元素 1，理所当然的 <code>p</code> 是二级指针，那么也可以对其进行二次解引用，当我们对其进行二次解引用的时候，编译器报错了：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>invalid type argument of unary &#x27;*&#x27; (have &#x27;int&#x27;)<br></code></pre></div></td></tr></table></figure><p>还有一点值得注意的是，在二维数组中，<code>a + 1</code>，可以移动一个元素的位置（也就是移动一个一维数组的大小），而用二级指针，<code>p + 1</code> 永远移动一个 <code>sizeof(int)</code> 的大小（本例中）。</p><h1 id="3-观点2-根本不需要这么做"><a class="markdownIt-Anchor" href="#3-观点2-根本不需要这么做"></a> 3 观点2 根本不需要这么做</h1><p>学过 C/C++ 的朋友应该都知道，一位数组在内存中是线性排列的，那么二维数组也不理外，它也是线性排列的。<br /><img src="https://s1.ax1x.com/2020/04/13/GXPHAK.jpg" alt="二维数组示意图" style="zoom: 80%;" /></p><p>假如只知道 <code>arr</code> 的地址，那么能得到 <code>arr[1][1]</code> 的地址吗？<br />答案是可以的，因为数组在内存中是线性排列，那么就代表着只要知道数组的起始地址，就可以通过一次取址获得任意元素的位置，所以根本不需要二次取址。</p><p>这也就解释了为什么声明二维数组的时候，编译器根本“不关心”一维的大小，以至于可以省略掉它，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[][<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><h1 id="4-二维数组做函数参数的方法"><a class="markdownIt-Anchor" href="#4-二维数组做函数参数的方法"></a> 4 二维数组做函数参数的方法</h1><h2 id="41-方法1"><a class="markdownIt-Anchor" href="#41-方法1"></a> 4.1 方法1</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])</span></span>;<br></code></pre></div></td></tr></table></figure><p>这种方法导致只能处理2行2列的int型数组，即固定了数组大小。</p><h2 id="42-方法2"><a class="markdownIt-Anchor" href="#42-方法2"></a> 4.2 方法2</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[][<span class="hljs-number">2</span>])</span></span>;<br></code></pre></div></td></tr></table></figure><p>可以省略一维的大小，这种方法的限制略微宽松了一些，但是还是只能处理每行是2个整数长度的数组。</p><h2 id="43-方法3"><a class="markdownIt-Anchor" href="#43-方法3"></a> 4.3 方法3</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*arr)[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></div></td></tr></table></figure><p>这个方法需要重点讨论，这里引入了一个新的概念叫做数组指针。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*arr)[<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><p>在解释这个概念之前要比较一下数组指针和指针数组的不同，以防止混淆：</p><ul><li>指针数组（array of pointers）：即用于存储指针的数组，也就是数组元素都是指针，如 <code>int* a[4]</code>，表示数组 <code>a</code> 中的元素都为 <code>int</code> 型指针；</li><li>数组指针（a pointer to an array）：即指向数组的指针，如 <code>int (*a)[4]</code>，表示指向数组 <code>a</code> 的指针。</li></ul><p>通过上述概念就知道了应该用数组指针指向一个二维数组，以下是正确的示例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">2</span>] = a;<br></code></pre></div></td></tr></table></figure><h1 id="5-与java的不同"><a class="markdownIt-Anchor" href="#5-与java的不同"></a> 5 与Java的不同</h1><p>Java中声明一个二维数组：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><p>不同于 C/C++ 中的：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><p>也不同与 C/C++ 中的：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><p>在 Java 中则是分配了一个包含 2 个指针的数组，指针数组的每个元素包含一个一维数组，在 C++ 中的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> **p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> *[<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
